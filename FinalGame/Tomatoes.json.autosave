{"firstLayout":"","gdVersion":{"build":228,"major":5,"minor":5,"revision":0},"properties":{"adaptGameResolutionAtRuntime":true,"antialiasingMode":"MSAA","antialisingEnabledOnMobile":false,"folderProject":false,"orientation":"default","packageName":"com.example.gamename","pixelsRounding":false,"projectUuid":"5ed291ad-627e-41c9-b650-be6a316446a2","scaleMode":"linear","sizeOnStartupMode":"adaptWidth","templateSlug":"","version":"1.0.0","name":"Tomatoes","description":"","author":"","windowWidth":1920,"windowHeight":1080,"latestCompilationDirectory":"","maxFPS":60,"minFPS":20,"verticalSync":false,"platformSpecificAssets":{},"loadingScreen":{"backgroundColor":0,"backgroundFadeInDuration":0.2,"backgroundImageResourceName":"","gdevelopLogoStyle":"light","logoAndProgressFadeInDuration":0.2,"logoAndProgressLogoFadeInDelay":0.0,"minDuration":1.5,"progressBarColor":16777215,"progressBarHeight":20.0,"progressBarMaxWidth":200.0,"progressBarMinWidth":40.0,"progressBarWidthPercent":30.0,"showGDevelopSplash":true,"showProgressBar":true},"watermark":{"placement":"bottom-left","showWatermark":true},"authorIds":[],"authorUsernames":[],"categories":[],"playableDevices":[],"extensionProperties":[],"platforms":[{"name":"GDevelop JS platform"}],"currentPlatform":"GDevelop JS platform"},"resources":{"resources":[{"file":"New3DBox2_Front2.png","kind":"image","metadata":"","name":"New3DBox2_Front2.png","smoothed":true,"userAdded":false},{"file":"New3DBox2_Front.png","kind":"image","metadata":"","name":"New3DBox2_Front.png","smoothed":true,"userAdded":false},{"file":"assets/Knife_tex.png","kind":"image","metadata":"{\"extension\":\".png\",\"pskl\":{}}","name":"Knife_tex","smoothed":true,"userAdded":false},{"file":"knife.glb","kind":"model3D","metadata":"","name":"knife.glb","userAdded":false},{"file":"knife2.glb","kind":"model3D","metadata":"","name":"knife2.glb","userAdded":false},{"file":"kitchen.glb","kind":"model3D","metadata":"","name":"kitchen.glb","userAdded":false},{"file":"tomato.glb","kind":"model3D","metadata":"","name":"tomato.glb","userAdded":false},{"file":"InvisibleWall_Front.png","kind":"image","metadata":"","name":"InvisibleWall_Front.png","smoothed":true,"userAdded":false},{"file":"assets/New3DBox_Front.png","kind":"image","metadata":"{\"extension\":\".png\",\"pskl\":{}}","name":"New3DBox_Front","smoothed":true,"userAdded":false},{"file":"assets/New3DBox_Front2.png","kind":"image","metadata":"{\"extension\":\".png\",\"pskl\":{}}","name":"New3DBox_Front2","smoothed":true,"userAdded":false}],"resourceFolders":[]},"objects":[],"objectsFolderStructure":{"folderName":"__ROOT"},"objectsGroups":[],"variables":[{"name":"CursorX_for_knife","type":"number","value":0.0}],"layouts":[{"b":209,"disableInputWhenNotFocused":true,"mangledName":"MainScene","name":"MainScene","r":209,"standardSortMethod":true,"stopSoundsOnStartup":true,"title":"","v":209,"uiSettings":{"grid":false,"gridType":"rectangular","gridWidth":32.0,"gridHeight":32.0,"gridOffsetX":0.0,"gridOffsetY":0.0,"gridColor":10401023.0,"gridAlpha":0.8,"snap":false,"zoomFactor":0.23009220400870765,"windowMask":false},"objectsGroups":[],"variables":[],"instances":[{"angle":270.0,"customSize":false,"height":0.0,"keepRatio":true,"layer":"","name":"Camera","persistentUuid":"53fc97fb-a525-4c67-ba79-ea902e30cd00","rotationY":14.0,"width":0.0,"x":909.0,"y":1165.0,"z":370.0,"zOrder":2,"numberProperties":[],"stringProperties":[],"initialVariables":[]},{"angle":0.0,"customSize":false,"height":0.0,"keepRatio":true,"layer":"","name":"Knife","persistentUuid":"e6f31cfa-0790-4810-8013-ed643da8a769","width":0.0,"x":210.0,"y":563.0,"z":400.0,"zOrder":4,"numberProperties":[],"stringProperties":[],"initialVariables":[]},{"angle":-90.0,"customSize":false,"height":0.0,"keepRatio":true,"layer":"","locked":true,"name":"Kitchen","persistentUuid":"9be8073f-cd5c-44c7-80b9-27ae8aedb6a0","rotationX":90.0,"rotationY":180.0,"sealed":true,"width":0.0,"x":1155.0,"y":-1079.0,"z":-1880.0,"zOrder":5,"numberProperties":[],"stringProperties":[],"initialVariables":[]},{"angle":104.0,"customSize":false,"height":0.0,"keepRatio":true,"layer":"","name":"Tomato","persistentUuid":"ba83e849-d465-417b-96ed-169d10865ec3","width":0.0,"x":1190.0,"y":347.0,"z":249.0,"zOrder":6,"numberProperties":[],"stringProperties":[],"initialVariables":[]},{"angle":0.0,"customSize":true,"depth":5.0,"height":941.0000000000002,"layer":"","locked":true,"name":"Floor","persistentUuid":"f9660010-ee3f-48f5-931a-06e086f400ca","sealed":true,"width":1562.9999999999996,"x":182.0,"y":-62.0,"z":180.0,"zOrder":7,"numberProperties":[],"stringProperties":[],"initialVariables":[]},{"angle":0.0,"customSize":true,"depth":329.0,"height":1129.0,"layer":"","name":"InvisibleWall","persistentUuid":"b91a761c-9f3d-403d-b368-a132b4414a38","width":104.0,"x":1744.0,"y":-136.0,"z":80.0,"zOrder":8,"numberProperties":[],"stringProperties":[],"initialVariables":[]},{"angle":0.0,"customSize":true,"depth":329.0,"height":1129.0,"layer":"","name":"InvisibleWall","persistentUuid":"57b76580-03f9-47d1-9d10-9010547f6df7","width":104.0,"x":85.0,"y":-152.0,"z":80.0,"zOrder":8,"numberProperties":[],"stringProperties":[],"initialVariables":[]},{"angle":0.0,"customSize":true,"depth":10.0,"height":856.0,"keepRatio":true,"layer":"","name":"GuideLine","persistentUuid":"22a9e4ea-af76-43f0-8b2a-63c185eb660a","width":10.0,"x":340.0,"y":-11.0,"z":148.0,"zOrder":9,"numberProperties":[],"stringProperties":[],"initialVariables":[]},{"angle":0.0,"customSize":true,"depth":96.0,"height":568.0,"layer":"","name":"BoxCollision","persistentUuid":"79eae472-c3ae-4ae4-9431-9828052e0c94","width":15.0,"x":201.0,"y":88.0,"z":345.0,"zOrder":10,"numberProperties":[],"stringProperties":[],"initialVariables":[{"name":"Owner","type":"string","value":"Knife"}]}],"objects":[{"assetStoreId":"","name":"Floor","type":"Scene3D::Cube3DObject","variables":[],"effects":[],"behaviors":[{"isFolded":true,"name":"Physics3D","type":"Physics3D::Physics3DBehavior","object3D":"Object3D","bodyType":"Static","bullet":false,"fixedRotation":false,"shape":"Box","shapeOrientation":"Z","shapeDimensionA":0.0,"shapeDimensionB":0.0,"shapeDimensionC":0.0,"density":1.0,"friction":0.3,"restitution":0.1,"linearDamping":0.1,"angularDamping":0.1,"gravityScale":1.0,"layers":17.0,"masks":17.0}],"content":{"width":100.0,"height":100.0,"depth":100.0,"enableTextureTransparency":false,"facesOrientation":"Y","frontFaceResourceName":"","backFaceResourceName":"","backFaceUpThroughWhichAxisRotation":"X","leftFaceResourceName":"","rightFaceResourceName":"","topFaceResourceName":"","bottomFaceResourceName":"","frontFaceVisible":true,"backFaceVisible":false,"leftFaceVisible":true,"rightFaceVisible":true,"topFaceVisible":true,"bottomFaceVisible":true,"frontFaceResourceRepeat":false,"backFaceResourceRepeat":false,"leftFaceResourceRepeat":false,"rightFaceResourceRepeat":false,"topFaceResourceRepeat":false,"bottomFaceResourceRepeat":false,"materialType":"Basic","tint":"255;255;255"}},{"assetStoreId":"","name":"Camera","type":"Scene3D::Cube3DObject","variables":[],"effects":[],"behaviors":[],"content":{"width":100.0,"height":100.0,"depth":100.0,"enableTextureTransparency":false,"facesOrientation":"Y","frontFaceResourceName":"New3DBox2_Front2.png","backFaceResourceName":"New3DBox2_Front.png","backFaceUpThroughWhichAxisRotation":"X","leftFaceResourceName":"New3DBox2_Front.png","rightFaceResourceName":"New3DBox2_Front2.png","topFaceResourceName":"New3DBox2_Front.png","bottomFaceResourceName":"New3DBox2_Front.png","frontFaceVisible":true,"backFaceVisible":false,"leftFaceVisible":true,"rightFaceVisible":true,"topFaceVisible":true,"bottomFaceVisible":true,"frontFaceResourceRepeat":false,"backFaceResourceRepeat":false,"leftFaceResourceRepeat":false,"rightFaceResourceRepeat":false,"topFaceResourceRepeat":false,"bottomFaceResourceRepeat":false,"materialType":"Basic","tint":"255;255;255"}},{"assetStoreId":"","name":"TestPrint","type":"BBText::BBText","variables":[],"effects":[],"behaviors":[],"content":{"text":"X: Yaw:\nY: Pitch:\nZ: Roll:","opacity":255.0,"fontSize":40.0,"visible":true,"color":"0;0;0","fontFamily":"Arial","align":"left","wordWrap":true}},{"assetStoreId":"","name":"Knife","type":"Scene3D::Model3DObject","variables":[{"name":"State","type":"number","value":0.0},{"name":"Y_Speed","type":"number","value":0.0},{"name":"MaxHeight","type":"number","value":600.0},{"name":"b_Collision","type":"boolean","value":false}],"effects":[],"behaviors":[],"content":{"centerLocation":"ObjectCenter","crossfadeDuration":0.10000000149011612,"depth":1000.0,"height":1000.0,"keepAspectRatio":true,"materialType":"StandardWithoutMetalness","modelResourceName":"knife.glb","originLocation":"ObjectCenter","rotationX":0.0,"rotationY":180.0,"rotationZ":0.0,"width":1000.0,"animations":[]}},{"assetStoreId":"","name":"Kitchen","type":"Scene3D::Model3DObject","variables":[],"effects":[],"behaviors":[],"content":{"centerLocation":"ModelOrigin","crossfadeDuration":0.10000000149011612,"depth":8498.63076210022,"height":4287.891261099147,"keepAspectRatio":true,"materialType":"StandardWithoutMetalness","modelResourceName":"kitchen.glb","originLocation":"ObjectCenter","rotationX":0.0,"rotationY":0.0,"rotationZ":0.0,"width":6006.783843040466,"animations":[]}},{"assetStoreId":"","name":"Tomato","type":"Scene3D::Model3DObject","variables":[{"name":"State","type":"number","value":0.0},{"name":"Direction","type":"number","value":0.0}],"effects":[],"behaviors":[{"isFolded":true,"name":"Physics3D","type":"Physics3D::Physics3DBehavior","object3D":"Object3D","bodyType":"Dynamic","bullet":false,"fixedRotation":false,"shape":"Box","shapeOrientation":"Z","shapeDimensionA":0.0,"shapeDimensionB":0.0,"shapeDimensionC":0.0,"density":1.0,"friction":0.3,"restitution":0.1,"linearDamping":0.1,"angularDamping":0.1,"gravityScale":1.0,"layers":17,"masks":17},{"isFolded":true,"name":"PhysicsCharacter3D","type":"Physics3D::PhysicsCharacter3D","physics3D":"Physics3D","jumpHeight":200.0,"jumpSustainTime":0.2,"gravity":1000.0,"fallingSpeedMax":700.0,"forwardAcceleration":1200.0,"forwardDeceleration":1200.0,"forwardSpeedMax":600.0,"sidewaysAcceleration":800.0,"sidewaysDeceleration":800.0,"sidewaysSpeedMax":400.0,"slopeMaxAngle":50.0,"stairHeightMax":20.0,"shouldBindObjectAndForwardAngle":true,"canBePushed":true}],"content":{"centerLocation":"ObjectCenter","crossfadeDuration":0.10000000149011612,"depth":100.0,"height":100.0,"keepAspectRatio":true,"materialType":"StandardWithoutMetalness","modelResourceName":"tomato.glb","originLocation":"ObjectCenter","rotationX":90.0,"rotationY":0.0,"rotationZ":0.0,"width":100.0,"animations":[]}},{"assetStoreId":"","name":"InvisibleWall","type":"Scene3D::Cube3DObject","variables":[],"effects":[],"behaviors":[{"name":"Physics3D","type":"Physics3D::Physics3DBehavior","object3D":"Object3D","bodyType":"Static","bullet":false,"fixedRotation":false,"shape":"Box","shapeOrientation":"Z","shapeDimensionA":0.0,"shapeDimensionB":0.0,"shapeDimensionC":0.0,"density":1.0,"friction":0.3,"restitution":0.1,"linearDamping":0.1,"angularDamping":0.1,"gravityScale":1.0,"layers":17,"masks":17}],"content":{"width":100.0,"height":100.0,"depth":100.0,"enableTextureTransparency":false,"facesOrientation":"Y","frontFaceResourceName":"InvisibleWall_Front.png","backFaceResourceName":"InvisibleWall_Front.png","backFaceUpThroughWhichAxisRotation":"X","leftFaceResourceName":"InvisibleWall_Front.png","rightFaceResourceName":"InvisibleWall_Front.png","topFaceResourceName":"InvisibleWall_Front.png","bottomFaceResourceName":"InvisibleWall_Front.png","frontFaceVisible":true,"backFaceVisible":true,"leftFaceVisible":true,"rightFaceVisible":true,"topFaceVisible":true,"bottomFaceVisible":true,"frontFaceResourceRepeat":true,"backFaceResourceRepeat":true,"leftFaceResourceRepeat":true,"rightFaceResourceRepeat":true,"topFaceResourceRepeat":true,"bottomFaceResourceRepeat":true,"materialType":"Basic","tint":"255;255;255"}},{"assetStoreId":"","name":"GuideLine","type":"Scene3D::Cube3DObject","variables":[],"effects":[],"behaviors":[],"content":{"width":10.0,"height":500.0,"depth":10.0,"enableTextureTransparency":false,"facesOrientation":"Y","frontFaceResourceName":"New3DBox_Front","backFaceResourceName":"New3DBox_Front","backFaceUpThroughWhichAxisRotation":"X","leftFaceResourceName":"New3DBox_Front","rightFaceResourceName":"New3DBox_Front","topFaceResourceName":"New3DBox_Front","bottomFaceResourceName":"New3DBox_Front","frontFaceVisible":true,"backFaceVisible":false,"leftFaceVisible":true,"rightFaceVisible":true,"topFaceVisible":true,"bottomFaceVisible":true,"frontFaceResourceRepeat":false,"backFaceResourceRepeat":false,"leftFaceResourceRepeat":false,"rightFaceResourceRepeat":false,"topFaceResourceRepeat":false,"bottomFaceResourceRepeat":false,"materialType":"Basic","tint":"255;255;255"}},{"assetStoreId":"","name":"BoxCollision","type":"Scene3D::Cube3DObject","variables":[{"name":"Owner","type":"string","value":"Null"}],"effects":[],"behaviors":[],"content":{"width":100.0,"height":100.0,"depth":100.0,"enableTextureTransparency":true,"facesOrientation":"Y","frontFaceResourceName":"New3DBox_Front2","backFaceResourceName":"New3DBox_Front2","backFaceUpThroughWhichAxisRotation":"X","leftFaceResourceName":"New3DBox_Front2","rightFaceResourceName":"New3DBox_Front2","topFaceResourceName":"New3DBox_Front2","bottomFaceResourceName":"New3DBox_Front2","frontFaceVisible":true,"backFaceVisible":true,"leftFaceVisible":true,"rightFaceVisible":true,"topFaceVisible":true,"bottomFaceVisible":true,"frontFaceResourceRepeat":false,"backFaceResourceRepeat":false,"leftFaceResourceRepeat":false,"rightFaceResourceRepeat":false,"topFaceResourceRepeat":false,"bottomFaceResourceRepeat":false,"materialType":"Basic","tint":"255;255;255"}}],"objectsFolderStructure":{"folderName":"__ROOT","children":[{"folderName":"UI","children":[{"objectName":"TestPrint"}]},{"folderName":"3D Model","children":[{"objectName":"Knife"},{"objectName":"Tomato"},{"objectName":"InvisibleWall"},{"objectName":"GuideLine"},{"objectName":"BoxCollision"}]},{"folderName":"Enviorment","children":[{"objectName":"Kitchen"},{"objectName":"Floor"}]},{"objectName":"Camera"}]},"events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"DepartScene"},"parameters":[""]}],"actions":[],"events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"BuiltinExternalLayouts::CreateObjectsFromExternalLayout"},"parameters":["","\"UI\"","","",""]},{"type":{"value":"Cache"},"parameters":["Camera"]},{"type":{"value":"Cache"},"parameters":["InvisibleWall"]},{"type":{"value":"Cache"},"parameters":["Floor"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"MettreXY"},"parameters":["Camera","=","909","=","1235"]},{"type":{"value":"Scene3D::Base3DBehavior::SetZ"},"parameters":["Camera","Object3D","=","480"]},{"type":{"value":"Scene3D::SetCameraFov"},"parameters":["","=","69","",""]},{"type":{"value":"Scene3D::Base3DBehavior::SetRotationY"},"parameters":["Camera","Object3D","=","13"]}]}]},{"type":"BuiltinCommonInstructions::Link","include":{"includeConfig":0},"target":"TomatoAI"},{"type":"BuiltinCommonInstructions::Link","include":{"includeConfig":0},"target":"KnifeControl"},{"colorB":228,"colorG":176,"colorR":74,"creationTime":0,"name":"Debug","source":"","type":"BuiltinCommonInstructions::Group","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"SystemInfo::IsPreview"},"parameters":[""]}],"actions":[],"events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"BBText::SetBBText"},"parameters":["TestPrint","=","\"Tomato Timer: \"+ToString(TimerElapsedTime(\"DirectionSwitch\"))+\"\nTomato Direction: \"+Tomato.Direction"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"SceneInstancesCount"},"parameters":["","Tomato","<","1"]}],"actions":[{"type":{"value":"Create"},"parameters":["","Tomato","1190","347",""]},{"type":{"value":"Scene3D::Base3DBehavior::SetZ"},"parameters":["Tomato","Object3D","=","249"]},{"type":{"value":"ResetObjectTimer"},"parameters":["Tomato","\"DirectionSwitch\""]}]}]}],"parameters":[]},{"colorB":228,"colorG":176,"colorR":74,"creationTime":0,"disabled":true,"folded":true,"name":"Test Control","source":"","type":"BuiltinCommonInstructions::Group","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"KeyFromTextPressed"},"parameters":["","\"w\""]}],"actions":[{"type":{"value":"SetCenterY"},"parameters":["Camera","+","-5"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"KeyFromTextPressed"},"parameters":["","\"s\""]}],"actions":[{"type":{"value":"SetCenterY"},"parameters":["Camera","+","5"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"KeyFromTextPressed"},"parameters":["","\"a\""]}],"actions":[{"type":{"value":"Scene3D::Base3DBehavior::SetZ"},"parameters":["Camera","Object3D","+","5"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"KeyFromTextPressed"},"parameters":["","\"d\""]}],"actions":[{"type":{"value":"Scene3D::Base3DBehavior::SetZ"},"parameters":["Camera","Object3D","+","-5"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"KeyFromTextPressed"},"parameters":["","\"z\""]}],"actions":[{"type":{"value":"Scene3D::Base3DBehavior::SetRotationY"},"parameters":["Camera","Object3D","+","1"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"KeyFromTextPressed"},"parameters":["","\"x\""]}],"actions":[{"type":{"value":"Scene3D::Base3DBehavior::SetRotationY"},"parameters":["Camera","Object3D","+","-1"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"KeyFromTextPressed"},"parameters":["","\"c\""]}],"actions":[{"type":{"value":"Scene3D::SetCameraFov"},"parameters":["","+","1","",""]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"KeyFromTextPressed"},"parameters":["","\"v\""]}],"actions":[{"type":{"value":"Scene3D::SetCameraFov"},"parameters":["","+","-1","",""]}]}],"parameters":[]},{"colorB":228,"colorG":176,"colorR":74,"creationTime":0,"folded":true,"name":"Camera","source":"","type":"BuiltinCommonInstructions::Group","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"FirstPersonCamera::LookFrom3DObjectEyes"},"parameters":["","Camera","Object3D","",""]}]}],"parameters":[]}],"layers":[{"ambientLightColorB":200,"ambientLightColorG":200,"ambientLightColorR":200,"camera3DFarPlaneDistance":10000.0,"camera3DFieldOfView":45.0,"camera3DNearPlaneDistance":3.0,"cameraType":"","followBaseLayerCamera":false,"isLightingLayer":false,"isLocked":false,"name":"","renderingType":"","visibility":true,"cameras":[{"defaultSize":true,"defaultViewport":true,"height":0.0,"viewportBottom":1.0,"viewportLeft":0.0,"viewportRight":1.0,"viewportTop":0.0,"width":0.0}],"effects":[{"effectType":"Scene3D::HemisphereLight","name":"3D Light","doubleParameters":{"elevation":45.0,"intensity":1.0,"rotation":0.0},"stringParameters":{"groundColor":"64;64;64","skyColor":"255;255;255","top":"Y-"},"booleanParameters":{}}]},{"ambientLightColorB":200,"ambientLightColorG":200,"ambientLightColorR":200,"camera3DFarPlaneDistance":10000.0,"camera3DFieldOfView":45.0,"camera3DNearPlaneDistance":3.0,"cameraType":"","followBaseLayerCamera":false,"isLightingLayer":false,"isLocked":false,"name":"UI","renderingType":"","visibility":true,"cameras":[],"effects":[{"effectType":"Scene3D::HemisphereLight","name":"3D Light","doubleParameters":{"elevation":45.0,"intensity":1.0,"rotation":0.0},"stringParameters":{"groundColor":"64;64;64","skyColor":"255;255;255","top":"Y-"},"booleanParameters":{}}]}],"behaviorsSharedData":[{"name":"Animation","type":"AnimatableCapability::AnimatableBehavior"},{"name":"Effect","type":"EffectCapability::EffectBehavior"},{"name":"Flippable","type":"FlippableCapability::FlippableBehavior"},{"name":"Object3D","type":"Scene3D::Base3DBehavior"},{"name":"Opacity","type":"OpacityCapability::OpacityBehavior"},{"name":"Physics3D","type":"Physics3D::Physics3DBehavior","gravityX":0.0,"gravityY":0.0,"gravityZ":-9.8,"worldScale":100.0},{"name":"PhysicsCharacter3D","type":"Physics3D::PhysicsCharacter3D"},{"name":"Resizable","type":"ResizableCapability::ResizableBehavior"},{"name":"Scale","type":"ScalableCapability::ScalableBehavior"}]}],"externalEvents":[{"associatedLayout":"MainScene","name":"TomatoAI","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"DepartScene"},"parameters":[""]}],"actions":[{"type":{"value":"ResetObjectTimer"},"parameters":["Tomato","\"DirectionSwitch\""]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"RotateTowardAngle"},"parameters":["Tomato","90","300",""]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"CompareObjectTimer"},"parameters":["Tomato","\"DirectionSwitch\"",">","0.5"]}],"actions":[{"type":{"value":"SetNumberObjectVariable"},"parameters":["Tomato","Direction","=","RandomInRange(0,10)"]},{"type":{"value":"ResetObjectTimer"},"parameters":["Tomato","\"DirectionSwitch\""]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"NumberObjectVariable"},"parameters":["Tomato","Direction",">","5"]}],"actions":[{"type":{"value":"Physics3D::PhysicsCharacter3D::SimulateRightKey"},"parameters":["Tomato","PhysicsCharacter3D"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"NumberObjectVariable"},"parameters":["Tomato","Direction","<=","5"]}],"actions":[{"type":{"value":"Physics3D::PhysicsCharacter3D::SimulateLeftKey"},"parameters":["Tomato","PhysicsCharacter3D"]}]}]},{"associatedLayout":"MainScene","name":"KnifeControl","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"DepartScene"},"parameters":[""]}],"actions":[{"type":{"value":"Cache"},"parameters":["BoxCollision"]}]},{"disabled":true,"folded":true,"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"inverted":true,"value":"SystemInfo::IsMobile"},"parameters":[]}],"actions":[{"type":{"value":"MettreX"},"parameters":["Knife","=","CursorX_for_knife + sin(TimeFromStart()*2)*10"]}],"events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"MouseButtonFromTextReleased"},"parameters":["","\"Left\""]},{"type":{"inverted":true,"value":"MousePointerLock::isPointerLocked"},"parameters":["",""]}],"actions":[{"type":{"value":"MousePointerLock::RequestPointerLock"},"parameters":["",""]}]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetNumberVariable"},"parameters":["CursorX_for_knife","=","clamp((CursorX(\"UI\",0)/SceneWindowWidth())*1920, 0, 1920) - Knife.Width()/2"]}],"events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"StringObjectVariable"},"parameters":["BoxCollision","Owner","=","\"Knife\""]}],"actions":[{"type":{"value":"MettreX"},"parameters":["BoxCollision","=","Knife.X()-BoxCollision.Width()/2"]},{"type":{"value":"Scene3D::Base3DBehavior::SetZ"},"parameters":["BoxCollision","Object3D","=","Knife.Object3D::CenterZ() - BoxCollision.Object3D::Depth()/2 - 10"]}]}]},{"folded":true,"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"MouseButtonFromTextPressed"},"parameters":["","\"Left\""]}],"actions":[],"events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"NumberObjectVariable"},"parameters":["Knife","State","=","0"]}],"actions":[{"type":{"value":"SetNumberObjectVariable"},"parameters":["Knife","State","=","1"]},{"type":{"value":"Scene3D::Base3DBehavior::SetZ"},"parameters":["Knife","Object3D","=","Knife.MaxHeight"]}]}]},{"folded":true,"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"NumberObjectVariable"},"parameters":["Knife","State","=","0"]}],"actions":[{"type":{"value":"MettreX"},"parameters":["Knife","=","Knife.X() + (CursorX_for_knife - Knife.X()) * 0.25 + sin(TimeFromStart()*2)*2"]},{"type":{"value":"Scene3D::Base3DBehavior::SetZ"},"parameters":["Knife","Object3D","=","Knife.MaxHeight + sin(TimeFromStart()*3) * 10"]},{"type":{"value":"MettreX"},"parameters":["GuideLine","=","Knife.X()-GuideLine.Width()/2"]}],"events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"PosX"},"parameters":["Knife","<=","0"]}],"actions":[{"type":{"value":"MettreX"},"parameters":["Knife","=","0"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"PosX"},"parameters":["Knife",">=","1920"]}],"actions":[{"type":{"value":"MettreX"},"parameters":["Knife","=","1920"]}]}]},{"folded":true,"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"NumberObjectVariable"},"parameters":["Knife","State","=","1"]}],"actions":[{"type":{"value":"SetNumberObjectVariable"},"parameters":["Knife","Y_Speed","+","-6000*TimeDelta()"]},{"type":{"value":"Scene3D::Base3DBehavior::SetZ"},"parameters":["Knife","Object3D","+","Knife.Y_Speed*TimeDelta()"]}],"events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"Scene3D::Base3DBehavior::Z"},"parameters":["Knife","Object3D","<=","Floor.Object3D::CenterZ()+20"]}],"actions":[{"type":{"value":"SetNumberObjectVariable"},"parameters":["Knife","State","=","2"]},{"type":{"value":"SetNumberObjectVariable"},"parameters":["Knife","Y_Speed","=","0"]}]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"NumberObjectVariable"},"parameters":["Knife","State","=","2"]}],"actions":[{"type":{"value":"CameraShake3D::ShakeCamera"},"parameters":["","0.15","0","0.15",""]},{"type":{"value":"SetBooleanObjectVariable"},"parameters":["Knife","b_Collision","True","3"]},{"type":{"value":"Montre"},"parameters":["BoxCollision",""]},{"type":{"value":"Wait"},"parameters":["0.1"]},{"type":{"value":"SetBooleanObjectVariable"},"parameters":["Knife","b_Collision","False","3"]},{"type":{"value":"Cache"},"parameters":["BoxCollision"]},{"type":{"value":"Wait"},"parameters":["0.1"]},{"type":{"value":"SetNumberObjectVariable"},"parameters":["Knife","State","=","3"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"BooleanObjectVariable"},"parameters":["Knife","b_Collision","True",""]},{"type":{"value":"StringObjectVariable"},"parameters":["BoxCollision","Owner","=","\"Knife\""]}],"actions":[],"events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"Collision3D::AreInCollision"},"parameters":["","BoxCollision","Object3D","Tomato","Object3D","",""]}],"actions":[{"type":{"value":"Delete"},"parameters":["Tomato",""]},{"type":{"value":"RemoveObjectTimer"},"parameters":["Tomato","\"DirectionSwitch\""]}]}]},{"folded":true,"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"NumberObjectVariable"},"parameters":["Knife","State","=","3"]}],"actions":[{"type":{"value":"SetNumberObjectVariable"},"parameters":["Knife","Y_Speed","+","750*TimeDelta()"]},{"type":{"value":"Scene3D::Base3DBehavior::SetZ"},"parameters":["Knife","Object3D","+","Knife.Y_Speed*TimeDelta()"]}],"events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"Scene3D::Base3DBehavior::Z"},"parameters":["Knife","Object3D",">=","Knife.MaxHeight"]}],"actions":[{"type":{"value":"Scene3D::Base3DBehavior::SetZ"},"parameters":["Knife","Object3D","=","Knife.MaxHeight"]},{"type":{"value":"SetNumberObjectVariable"},"parameters":["Knife","Y_Speed","=","0"]},{"type":{"value":"SetNumberObjectVariable"},"parameters":["Knife","State","=","0"]}]}]}]}],"eventsFunctionsExtensions":[{"author":"","category":"General","extensionNamespace":"","fullName":"3D raycast","gdevelopVersion":">=5.5.222","helpPath":"","iconUrl":"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0ibWRpLXJheS1zdGFydC1hcnJvdyIgd2lkdGg9IjI0IiBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiPjxwYXRoIGQ9Ik0yMywxMkwxOSwxNlYxM0g2LjgzQzYuNDIsMTQuMTcgNS4zMSwxNSA0LDE1QTMsMyAwIDAsMSAxLDEyQTMsMyAwIDAsMSA0LDlDNS4zMSw5IDYuNDIsOS44MyA2LjgzLDExSDE5VjhMMjMsMTJaIiAvPjwvc3ZnPg==","name":"Raycaster3D","previewIconUrl":"https://asset-resources.gdevelop.io/public-resources/Icons/8419f46b76bce482c14b4c03b4141a64d457e4cdc92686f3470381f5d2694abd_ray-start-arrow.svg","shortDescription":"Find 3D objects that cross a line.","version":"0.1.5","description":["It can be useful to:","- Find 3D objects under the pointer","- Target objects from a 1st person view","- Make AI that detect objects in their field of view"],"origin":{"identifier":"Raycaster3D","name":"gdevelop-extension-store"},"tags":["3d","recast","collision"],"authorIds":["IWykYNRvhCZBN3vEgKEbBPOR3Oc2"],"dependencies":[],"globalVariables":[],"sceneVariables":[],"eventsFunctions":[{"fullName":"","functionType":"Action","name":"onFirstSceneLoaded","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"Raycaster3D::DefineHelperClasses"},"parameters":["",""]}]}],"parameters":[],"objectGroups":[]},{"description":"Define helper classes JavaScript code.","fullName":"Define helper classes","functionType":"Action","name":"DefineHelperClasses","private":true,"sentence":"Define helper classes JavaScript code","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"GlobalVariableAsBoolean"},"parameters":["_Raycaster3DExtension_ClassesDefined",""]}],"actions":[{"type":{"value":"SetGlobalVariableAsBoolean"},"parameters":["_Raycaster3DExtension_ClassesDefined","True"]}],"events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["gdjs.__raycaster3DExtension = gdjs.__raycaster3DExtension || {};","","class Raycaster {","    raycaster = new THREE.Raycaster();","    pointer = new THREE.Vector2();","    raycastResults = [];","    lastDistance = 0;","    lastPositionX = 0;","    lastPositionY = 0;","    lastPositionZ = 0;","    lastNormalX = 0;","    lastNormalY = 0;","    lastNormalZ = 0;","","    /**","     * @param objectsLists {Hashtable<gdjs.RuntimeObject[]>}","     * @param objects {gdjs.RuntimeObject[]}","     * @param pointerX {number}","     * @param pointerY {number}","     * @param distanceMax {number}","     */","    recastFromCamera(objectsLists, objects, pointerX, pointerY, distanceMax) {","        if (objects.length === 0) {","            return false;","        }","        const object = objects[0];","        const layer = object.getInstanceContainer().getLayer(object.getLayer());","        const camera = layer.getRenderer().getThreeCamera();","","        const raycaster = this.raycaster;","        const pointer = this.pointer;","        pointer.x = -1 + 2 * pointerX;","        pointer.y = 1 - 2 * pointerY;","        raycaster.setFromCamera(pointer, camera);","        raycaster.far = distanceMax;","","        return this._doRecast(objectsLists, objects);","    }","","    /**","     * @param objectsLists {Hashtable<gdjs.RuntimeObject[]>}","     * @param objects {gdjs.RuntimeObject[]}","     * @param originX {number}","     * @param originY {number}","     * @param originZ {number}","     * @param rotationAngle {number}","     * @param elevationAngle {number}","     * @param distanceMax {number}","     */","    recastWithAngle(","        objectsLists,","        objects,","        originX,","        originY,","        originZ,","        rotationAngle,","        elevationAngle,","        distanceMax","    ) {","        if (objects.length === 0) {","            return false;","        }","        const raycaster = this.raycaster;","        raycaster.ray.origin.set(","            originX,","            -originY,","            originZ,","        );","        const rotation = rotationAngle * Math.PI / 180;","        const elevation = elevationAngle * Math.PI / 180;","        const cosElevation = Math.cos(elevation);","        raycaster.ray.direction.set(","            Math.cos(rotation) * cosElevation,","            -Math.sin(rotation) * cosElevation,","            Math.sin(elevation),","        );","        raycaster.far = distanceMax;","","        return this._doRecast(objectsLists, objects);","    }","","    /**","     * @param objectsLists {Hashtable<gdjs.RuntimeObject[]>}","     * @param objects {gdjs.RuntimeObject[]}","     * @param originX {number}","     * @param originY {number}","     * @param originZ {number}","     * @param targetX {number}","     * @param targetY {number}","     * @param targetZ {number}","     * @param distanceMax {number}","     */","    recastBetweenPosition(","        objectsLists,","        objects,","        originX,","        originY,","        originZ,","        targetX,","        targetY,","        targetZ","    ) {","        if (objects.length === 0) {","            return false;","        }","        const raycaster = this.raycaster;","        raycaster.ray.origin.set(","            originX,","            -originY,","            originZ,","        );","        const deltaX = targetX - originX;","        const deltaY = targetY - originY;","        const deltaZ = targetZ - originZ;","        const deltaLength = Math.hypot(deltaX, deltaY, deltaZ);","        raycaster.ray.direction.set(","            deltaX / deltaLength,","            -deltaY / deltaLength,","            deltaZ / deltaLength,","        );","        raycaster.far = deltaLength;","","        return this._doRecast(objectsLists, objects);","    }","","    /**","     * @param objectsLists {Hashtable<gdjs.RuntimeObject[]>}","     * @param objects {gdjs.RuntimeObject[]}","     */","    _doRecast(objectsLists, objects) {","        const raycastResults = this.raycastResults;","        let distanceMin = Number.MAX_VALUE;","        let nearestObject = null;","        for (const object of objects) {","            raycastResults.length = 0;","            const threeObject = object.get3DRendererObject();","            if (!threeObject) {","                continue;","            }","            this.raycaster.intersectObject(threeObject, true, raycastResults);","            if (raycastResults.length > 0 && raycastResults[0].distance < distanceMin) {","                const raycastResult = raycastResults[0];","                distanceMin = raycastResult.distance;","                nearestObject = object;","                this.lastDistance = raycastResult.distance;","                this.lastPositionX = raycastResult.point.x;","                this.lastPositionY = -raycastResult.point.y;","                this.lastPositionZ = raycastResult.point.z;","                this.lastNormalX = raycastResult.normal.x;","                this.lastNormalY = raycastResult.normal.y;","                this.lastNormalZ = raycastResult.normal.z;","            }","        }","        if (!nearestObject) {","            return false;","        }","        raycastResults.length = 0;","        gdjs.evtTools.object.pickOnly(","            objectsLists,","            nearestObject","        );","        return true;","    }","}","","gdjs.__raycaster3DExtension.Raycaster = Raycaster;","gdjs.__raycaster3DExtension.raycaster = new Raycaster();",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}]}],"parameters":[],"objectGroups":[]},{"description":"Sends a ray from the given source position and angle, intersecting the closest object. The intersected object will become the only one taken into account.","fullName":"Raycast","functionType":"Condition","group":"Collision","name":"RaycastWithAngle","sentence":"Cast a ray from _PARAM2_; _PARAM3_; _PARAM4_ toward a rotation of _PARAM5_°, an elevation of _PARAM6_° and max distance of _PARAM7_ against _PARAM1_","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["eventsFunctionContext.returnValue =","    gdjs.__raycaster3DExtension.raycaster.recastWithAngle(","        eventsFunctionContext.getObjectsLists(\"Object\"),","        objects,","        eventsFunctionContext.getArgument(\"OriginX\"),","        eventsFunctionContext.getArgument(\"OriginY\"),","        eventsFunctionContext.getArgument(\"OriginZ\"),","        eventsFunctionContext.getArgument(\"RotationAngle\"),","        eventsFunctionContext.getArgument(\"ElevationAngle\"),","        eventsFunctionContext.getArgument(\"DistanceMax\")","    );",""],"parameterObjects":"Object","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"Objects to test against the ray","name":"Object","type":"objectList"},{"description":"Ray source X position","name":"OriginX","type":"expression"},{"description":"Ray source Y position","name":"OriginY","type":"expression"},{"description":"Ray source Z position","name":"OriginZ","type":"expression"},{"description":"Rotation angle (in degrees)","name":"RotationAngle","type":"expression"},{"description":"Elevation angle (in degrees)","name":"ElevationAngle","type":"expression"},{"description":"Ray maximum distance (in pixels)","name":"DistanceMax","type":"expression"}],"objectGroups":[]},{"description":"Sends a ray from the given source position to the final point, intersecting the closest object. The intersected object will become the only one taken into account.","fullName":"Raycast to a position","functionType":"Condition","group":"Collision","name":"RaycastBetweenPosition","sentence":"Cast a ray from _PARAM2_; _PARAM3_; _PARAM4_ to _PARAM5_; _PARAM6_; _PARAM7_ against _PARAM1_","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["eventsFunctionContext.returnValue =","    gdjs.__raycaster3DExtension.raycaster.recastBetweenPosition(","        eventsFunctionContext.getObjectsLists(\"Object\"),","        objects,","        eventsFunctionContext.getArgument(\"OriginX\"),","        eventsFunctionContext.getArgument(\"OriginY\"),","        eventsFunctionContext.getArgument(\"OriginZ\"),","        eventsFunctionContext.getArgument(\"TargetX\"),","        eventsFunctionContext.getArgument(\"TargetY\"),","        eventsFunctionContext.getArgument(\"TargetZ\")","    );",""],"parameterObjects":"Object","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"Objects to test against the ray","name":"Object","type":"objectList"},{"description":"Ray source X position","name":"OriginX","type":"expression"},{"description":"Ray source Y position","name":"OriginY","type":"expression"},{"description":"Ray source Z position","name":"OriginZ","type":"expression"},{"description":"Ray target X position","name":"TargetX","type":"expression"},{"description":"Ray target Y position","name":"TargetY","type":"expression"},{"description":"Ray target Z position","name":"TargetZ","type":"expression"}],"objectGroups":[]},{"description":"Sends a ray from the center of the camera, intersecting the closest object. The intersected object will become the only one taken into account.","fullName":"Raycast from camera center","functionType":"Condition","group":"Collision","name":"RaycastFromCameraCenter","sentence":"Cast a ray from the camera center to a maximum distance of _PARAM2_ against _PARAM1_","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["eventsFunctionContext.returnValue =","    gdjs.__raycaster3DExtension.raycaster.recastFromCamera(","        eventsFunctionContext.getObjectsLists(\"Object\"),","        objects,","        0.5,","        0.5,","        eventsFunctionContext.getArgument(\"DistanceMax\")","    );",""],"parameterObjects":"Object","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"Objects to test against the ray","name":"Object","type":"objectList"},{"description":"Ray maximum distance (in pixels)","name":"DistanceMax","type":"expression"}],"objectGroups":[]},{"description":"Sends a ray from the given source point on the camera screen, intersecting the closest object. The intersected object will become the only one taken into account.","fullName":"Raycast from a camera point","functionType":"Condition","group":"Collision","name":"RaycastFromCameraPoint","sentence":"Cast a ray from the camera point _PARAM2_; _PARAM3_ to a maximum distance of _PARAM4_ against _PARAM1_","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["eventsFunctionContext.returnValue =","    gdjs.__raycaster3DExtension.raycaster.recastFromCamera(","        eventsFunctionContext.getObjectsLists(\"Object\"),","        objects,","        eventsFunctionContext.getArgument(\"PointerX\"),","        eventsFunctionContext.getArgument(\"PointerY\"),","        eventsFunctionContext.getArgument(\"DistanceMax\")","    );",""],"parameterObjects":"Object","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"Objects to test against the ray","name":"Object","type":"objectList"},{"description":"X position on the screen (from 0 to 1)","name":"PointerX","type":"expression"},{"description":"Y position on the screen (from 0 to 1)","name":"PointerY","type":"expression"},{"description":"Ray maximum distance (in pixels)","name":"DistanceMax","type":"expression"}],"objectGroups":[]},{"description":"Sends a ray from the cursor on the camera screen, intersecting the closest object. The intersected object will become the only one taken into account.","fullName":"Raycast from cursor","functionType":"Condition","group":"Collision","name":"RaycastFromCameraCursor","sentence":"Cast a ray from the cursor on 2D layer: _PARAM2_ to a maximum distance of _PARAM3_ against _PARAM1_","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["const { camera, input } = gdjs.evtTools;","","const layer2D = eventsFunctionContext.getArgument(\"Layer2D\");","","const cameraMinX = camera.getCameraBorderLeft(runtimeScene, layer2D, 0);","const cameraMaxX = camera.getCameraBorderRight(runtimeScene, layer2D, 0);","const cameraMinY = camera.getCameraBorderTop(runtimeScene, layer2D, 0);","const cameraMaxY = camera.getCameraBorderBottom(runtimeScene, layer2D, 0);","","const cursorX = input.getCursorX(runtimeScene, layer2D, 0);","const cursorY = input.getCursorY(runtimeScene, layer2D, 0);","","eventsFunctionContext.returnValue =","    gdjs.__raycaster3DExtension.raycaster.recastFromCamera(","        eventsFunctionContext.getObjectsLists(\"Object\"),","        objects,","        (cursorX - cameraMinX) / (cameraMaxX - cameraMinX),","        (cursorY - cameraMinY) / (cameraMaxY - cameraMinY),","        eventsFunctionContext.getArgument(\"DistanceMax\")","    );",""],"parameterObjects":"Object","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"Objects to test against the ray","name":"Object","type":"objectList"},{"description":"2D layer","name":"Layer2D","type":"layer"},{"description":"Ray maximum distance (in pixels)","name":"DistanceMax","type":"expression"}],"objectGroups":[]},{"description":"the last recast intersection distance.","fullName":"Last recast distance","functionType":"ExpressionAndCondition","name":"Distance","sentence":"the last recast intersection distance","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":"eventsFunctionContext.returnValue = gdjs.__raycaster3DExtension.raycaster.lastDistance;","parameterObjects":"","useStrict":true,"eventsSheetExpanded":false}],"expressionType":{"type":"expression"},"parameters":[],"objectGroups":[]},{"description":"Return the last recast intersection position on X axis.","fullName":"Last recast X intersection","functionType":"Expression","name":"IntersectionX","sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":"eventsFunctionContext.returnValue = gdjs.__raycaster3DExtension.raycaster.lastPositionX;","parameterObjects":"","useStrict":true,"eventsSheetExpanded":false}],"expressionType":{"type":"expression"},"parameters":[],"objectGroups":[]},{"description":"Return the last recast intersection position on Y axis.","fullName":"Last recast Y intersection","functionType":"Expression","name":"IntersectionY","sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":"eventsFunctionContext.returnValue = gdjs.__raycaster3DExtension.raycaster.lastPositionY;","parameterObjects":"","useStrict":true,"eventsSheetExpanded":false}],"expressionType":{"type":"expression"},"parameters":[],"objectGroups":[]},{"description":"Return the last recast intersection position on Z axis.","fullName":"Last recast Z intersection","functionType":"Expression","name":"IntersectionZ","sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":"eventsFunctionContext.returnValue = gdjs.__raycaster3DExtension.raycaster.lastPositionZ;","parameterObjects":"","useStrict":true,"eventsSheetExpanded":false}],"expressionType":{"type":"expression"},"parameters":[],"objectGroups":[]},{"description":"Return the last recast intersection normal on X axis.","fullName":"Last recast X normal","functionType":"Expression","name":"NormalX","sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":"eventsFunctionContext.returnValue = gdjs.__raycaster3DExtension.raycaster.lastNormalX;","parameterObjects":"","useStrict":true,"eventsSheetExpanded":false}],"expressionType":{"type":"expression"},"parameters":[],"objectGroups":[]},{"description":"Return the last recast intersection normal on X axis.","fullName":"Last recast X normal","functionType":"Expression","name":"NormalY","sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":"eventsFunctionContext.returnValue = gdjs.__raycaster3DExtension.raycaster.lastNormalY;","parameterObjects":"","useStrict":true,"eventsSheetExpanded":false}],"expressionType":{"type":"expression"},"parameters":[],"objectGroups":[]},{"description":"Return the last recast intersection normal on Z axis.","fullName":"Last recast Z normal","functionType":"Expression","name":"NormalZ","sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":"eventsFunctionContext.returnValue = gdjs.__raycaster3DExtension.raycaster.lastNormalZ;","parameterObjects":"","useStrict":true,"eventsSheetExpanded":false}],"expressionType":{"type":"expression"},"parameters":[],"objectGroups":[]}],"eventsBasedBehaviors":[],"eventsBasedObjects":[]},{"author":"","category":"General","extensionNamespace":"","fullName":"3D collision","gdevelopVersion":">=5.5.222","helpPath":"","iconUrl":"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0ibWRpLXZlY3Rvci1pbnRlcnNlY3Rpb24iIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBkPSJNMy4xNCwxQTIuMTQsMi4xNCAwIDAsMCAxLDMuMTRWNUgzVjNINVYxSDMuMTRNNywxVjNIMTBWMUg3TTEyLDFWM0gxNFY1SDE2VjMuMTRDMTYsMS45NiAxNS4wNCwxIDEzLjg2LDFIMTJNMSw3VjEwSDNWN0gxTTksN0M3Ljg5LDcgNyw3Ljg5IDcsOUM3LDExLjMzIDcsMTYgNywxNkM3LDE2IDExLjU3LDE2IDEzLjg2LDE2QTIuMTQsMi4xNCAwIDAsMCAxNiwxMy44NkMxNiwxMS41NyAxNiw3IDE2LDdDMTYsNyAxMS4zMyw3IDksN00xOCw3VjlIMjBWMTFIMjJWOUMyMiw3Ljg5IDIxLjExLDcgMjAsN0gxOE05LDlIMTRWMTRIOVY5TTEsMTJWMTMuODZDMSwxNS4wNCAxLjk2LDE2IDMuMTQsMTZINVYxNEgzVjEySDFNMjAsMTNWMTZIMjJWMTNIMjBNNywxOFYyMEM3LDIxLjExIDcuODksMjIgOSwyMkgxMVYyMEg5VjE4SDdNMjAsMThWMjBIMThWMjJIMjBDMjEuMTEsMjIgMjIsMjEuMTEgMjIsMjBWMThIMjBNMTMsMjBWMjJIMTZWMjBIMTNaIiAvPjwvc3ZnPg==","name":"Collision3D","previewIconUrl":"https://asset-resources.gdevelop.io/public-resources/Icons/7a5696a515bf40813692e118147568392a854f65f5b50750c9b9aaa967aba7df_vector-intersection.svg","shortDescription":"Check collision and distance between 3D objects.","version":"0.2.0","description":"Check collision and distance between 3D objects and separate them from each other.","origin":{"identifier":"Collision3D","name":"gdevelop-extension-store"},"tags":["3d","collision"],"authorIds":["IWykYNRvhCZBN3vEgKEbBPOR3Oc2","PEzPAaWHgYgk5UwIPppsL6f2ugp2"],"dependencies":[],"globalVariables":[],"sceneVariables":[],"eventsFunctions":[{"description":"Define helper classes JavaScript code.","fullName":"Define helper classes","functionType":"Action","name":"DefineHelperClasses","private":true,"sentence":"Define helper classes JavaScript code","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (gdjs._collision3DExtension) {","    return;","}","","/**"," * @param {gdjs.RuntimeObject} object"," * @param {boolean} shouldUseCustomCenter"," * @return {number}"," */","const getCenterX = (object, shouldUseCustomCenter) =>","    shouldUseCustomCenter ?","        object.getCenterXInScene() :","        object.getDrawableX() + object.getWidth() / 2","","/**"," * @param {gdjs.RuntimeObject} object"," * @param {boolean} shouldUseCustomCenter"," * @return {number}"," */","const getCenterY = (object, shouldUseCustomCenter) =>","    shouldUseCustomCenter ?","        object.getCenterYInScene() :","        object.getDrawableY() + object.getHeight() / 2","","/**"," * @param {gdjs.RuntimeObject3D} object"," * @param {boolean} shouldUseCustomCenter"," * @return {number}"," */","const getCenterZ = (object, shouldUseCustomCenter) =>","    !object.getCenterZInScene ? 0 :","    shouldUseCustomCenter ?","        object.getCenterZInScene() :","        object.getDrawableZ() + object.getDepth() / 2","","/**"," * @param {gdjs.RuntimeObject} object"," * @param {float} x"," * @param {float} y"," * @param {float} z"," * @param {boolean} shouldUseCustomCenter"," * @return {number}"," */","const getSqDistanceToPosition = (object, x, y, z, shouldUseCustomCenter = true) => {","    const deltaX = getCenterX(object, shouldUseCustomCenter) - x;","    const deltaY = getCenterY(object, shouldUseCustomCenter) - y;","    const deltaZ = getCenterZ(object, shouldUseCustomCenter) - z;","    return deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ;","};","","/**"," * @param {gdjs.RuntimeObject} object"," * @param {float} x"," * @param {float} y"," * @param {float} z"," * @return {number}"," */","const getDistanceToPosition = (object, x, y, z) => Math.sqrt(getSqDistanceToPosition(object, x, y, z));","","/**"," * @param {gdjs.RuntimeObject} object"," * @param {gdjs.RuntimeObject} otherObject"," * @param {boolean} shouldUseCustomCenter"," * @return {number}"," */","const getSqDistanceToObject = (object, otherObject, shouldUseCustomCenter = true) => {","    return getSqDistanceToPosition(","        object,","        getCenterX(otherObject, shouldUseCustomCenter),","        getCenterY(otherObject, shouldUseCustomCenter),","        getCenterZ(otherObject, shouldUseCustomCenter)","    );","};","","/**"," * @param {gdjs.RuntimeObject} object"," * @param {gdjs.RuntimeObject} otherObject"," * @return {number}"," */","const getDistanceToObject = (object, otherObject) => Math.sqrt(getSqDistanceToObject(object, otherObject));","","/**"," * @param {gdjs.RuntimeObject} object"," * @param {gdjs.RuntimeObject} otherObject"," * @param {{distanceSq: number, shouldUseCustomCenter: boolean}} distanceSettings"," * @return {boolean}"," */","const areObjectsWithinDistance = (object, otherObject, distanceSettings) => {","    return getSqDistanceToObject(","        object, otherObject, distanceSettings.shouldUseCustomCenter) <= distanceSettings.distanceSq;","};","","const distanceSettings = {distanceSq: 0, shouldUseCustomCenter: true};","","/**"," * @param {Hashtable<gdjs.RuntimeObject[]>} objectsLists1"," * @param {Hashtable<gdjs.RuntimeObject[]>} objectsLists2"," * @param {number} distance"," * @param {boolean} shouldUseCustomCenter"," * @param {boolean} inverted"," * @return {boolean}"," */","const pickObjectsWithinDistance = (objectsLists1, objectsLists2, distance, shouldUseCustomCenter, inverted) => {","    distanceSettings.distanceSq = distance * distance;","    distanceSettings.shouldUseCustomCenter = shouldUseCustomCenter;","    return gdjs.evtTools.object.twoListsTest(","        areObjectsWithinDistance,","        objectsLists1,","        objectsLists2,","        inverted,","        distanceSettings","    );","}","","/**"," * @param {Hashtable<gdjs.RuntimeObject[]>} objectsLists"," * @param {number} x"," * @param {number} y"," * @param {number} z"," * @param {boolean} inverted"," * @return {boolean}"," */","const pickNearestObject = function (objectsLists, x, y, z, inverted) {","    let bestObject = null;","    let best = 0;","    let first = true;","    const lists = gdjs.staticArray(gdjs._collision3DExtension.pickNearestObject);","    objectsLists.values(lists);","    for (let i = 0, len = lists.length; i < len; ++i) {","        const list = lists[i];","        for (let j = 0; j < list.length; ++j) {","            const object = list[j];","            const distance = getSqDistanceToPosition(object, x, y, z);","            // @ts-ignore","            if (first || (distance < best) ^ inverted) {","                best = distance;","                bestObject = object;","            }","            first = false;","        }","    }","    if (bestObject) {","        gdjs.evtTools.object.pickOnly(objectsLists, bestObject);","    }","    return !!bestObject;","}","","/**"," * @param {gdjs.RuntimeObject} object"," * @return {float}"," */","const getObjectMinZ = (object) =>","    object.getDrawableZ ? object.getDrawableZ() : 0","","/**"," * @param {gdjs.RuntimeObject} object"," * @return {float}"," */","const getObjectMaxZ = (object) =>","    object.getDrawableZ ? object.getDrawableZ() + object.getDepth() : 0;","","/**"," * @param {gdjs.RuntimeObject} object1"," * @param {gdjs.RuntimeObject} object2"," * @param {boolean} ignoreTouchingEdges If true, then edges that are touching each other, without the hitbox polygons actually overlapping, won't be considered in collision."," * @return {boolean}"," */","const areObjectsInCollision = (","    object1,","    object2,","    ignoreTouchingEdges,",") => {","    const object1MinZ = getObjectMinZ(object1);","    const object1MaxZ = getObjectMaxZ(object1);","    const object2MinZ = getObjectMinZ(object2);","    const object2MaxZ = getObjectMaxZ(object2);","","    const canObjectsOverlapOnZ = ignoreTouchingEdges ?","        (object1MinZ < object2MaxZ && object1MaxZ > object2MinZ) :","        (object1MinZ <= object2MaxZ && object1MaxZ >= object2MinZ);","","    return canObjectsOverlapOnZ &&","        gdjs.RuntimeObject.collisionTest(","            object1,","            object2,","            ignoreTouchingEdges","        );","}","","/**"," * @param {Hashtable<gdjs.RuntimeObject[]>} objectsLists1"," * @param {Hashtable<gdjs.RuntimeObject[]>} objectsLists2"," * @param {boolean} inverted"," * @return {boolean}"," */","const pickObjectsInCollision = (","    objectsLists1,","    objectsLists2,","    inverted,",") => {","    return gdjs.evtTools.object.twoListsTest(","        areObjectsInCollision,","        objectsLists1,","        objectsLists2,","        inverted,","        false","    );","}","","/**"," * @param {gdjs.RuntimeObject} movingObject"," * @param {gdjs.RuntimeObject} object"," * @return {float}"," */","const getSeparationDeltaZ = (","    movingObject,","    object,",") => {","    const movingObjectMinZ = getObjectMinZ(movingObject);","    const movingObjectMaxZ = getObjectMaxZ(movingObject);","    const objectMinZ = getObjectMinZ(object);","    const objectMaxZ = getObjectMaxZ(object);","","    const downwardDeltaZ = Math.min(0, objectMinZ - movingObjectMaxZ);","    const upwardDeltaZ = Math.max(0, objectMaxZ - movingObjectMinZ);","","    return -downwardDeltaZ < upwardDeltaZ ? downwardDeltaZ : upwardDeltaZ","}","","// This function is an exact copy from GDJS/Runtime/runtimeobject.ts","/**"," * Move the object using the results from collisionTest call."," * This moves the object according to the direction of the longest vector,"," * and projects the others on the orthogonal vector."," *"," * See {@link RuntimeObject.separateFromObjects}"," *"," * @param {gdjs.RuntimeObject} object The object to move."," * @param {float[]} moveXArray The X coordinates of the vectors to move the object."," * @param {float[]} moveYArray The Y coordinates of the vectors to move the object."," * @return {boolean} true if the object was moved."," */","const moveFollowingSeparatingVectors = (","    object,","    moveXArray,","    moveYArray",") => {","    if (moveXArray.length === 0) {","        moveXArray.length = 0;","        moveYArray.length = 0;","        return false;","    }","    if (moveXArray.length === 1) {","        // Move according to the results returned by the collision algorithm.","        object.setPosition(","            object.getX() + moveXArray[0],","            object.getY() + moveYArray[0]","        );","        moveXArray.length = 0;","        moveYArray.length = 0;","        return true;","    }","","    // Find the longest vector","    let squaredDistanceMax = 0;","    let distanceMaxIndex = 0;","    for (let index = 0; index < moveXArray.length; index++) {","        const moveX = moveXArray[index];","        const moveY = moveYArray[index];","","        const squaredDistance = moveX * moveX + moveY * moveY;","        if (squaredDistance > squaredDistanceMax) {","            squaredDistanceMax = squaredDistance;","            distanceMaxIndex = index;","        }","    }","","    const distanceMax = Math.sqrt(squaredDistanceMax);","    // unit vector of the longest vector","    const uX = moveXArray[distanceMaxIndex] / distanceMax;","    const uY = moveYArray[distanceMaxIndex] / distanceMax;","","    // normal vector of the longest vector","    const vX = -uY;","    const vY = uX;","","    // Project other vectors on the normal","    let scalarProductMin = 0;","    let scalarProductMax = 0;","    for (let index = 0; index < moveXArray.length; index++) {","        const moveX = moveXArray[index];","        const moveY = moveYArray[index];","","        const scalarProduct = moveX * vX + moveY * vY;","        scalarProductMin = Math.min(scalarProductMin, scalarProduct);","        scalarProductMax = Math.max(scalarProductMax, scalarProduct);","    }","","    // Apply the longest vector","    let deltaX = moveXArray[distanceMaxIndex];","    let deltaY = moveYArray[distanceMaxIndex];","","    // Apply the longest projected vector if they all are in the same direction","    // Some projections could have rounding errors,","    // they are considered negligible under a 1 for 1,000,000 ratio.","    const scalarProductMinIsNegligible =","        -scalarProductMin < scalarProductMax / 1048576;","    const scalarProductMaxIsNegligible =","        scalarProductMax < -scalarProductMin / 1048576;","    if (scalarProductMinIsNegligible !== scalarProductMaxIsNegligible) {","        if (scalarProductMaxIsNegligible) {","            deltaX += scalarProductMin * vX;","            deltaY += scalarProductMin * vY;","        } else {","            deltaX += scalarProductMax * vX;","            deltaY += scalarProductMax * vY;","        }","    }","    object.setPosition(object.getX() + deltaX, object.getY() + deltaY);","    moveXArray.length = 0;","    moveYArray.length = 0;","    return true;","};","","/**"," * Arrays and data structure that are (re)used by"," * {@link separateFromObjects} to avoid any allocation."," * @type {{moveXArray: float[], moveYArray: float[], moveZArray: float[]}}"," */","const separateFromObjectsStatics = {","    moveXArray: [],","    moveYArray: [],","    moveZArray: [],","};","","/**"," * Separate the object from others objects, using their hitboxes."," * @param {gdjs.RuntimeObject} object The object that moves."," * @param {gdjs.RuntimeObject[]} objects The objects that stay still."," * @return {boolean} true if the object was moved"," */","const separateFromObjects = (","    object,","    objects",") => {","    const moveXArray = separateFromObjectsStatics.moveXArray;","    const moveYArray = separateFromObjectsStatics.moveYArray;","    moveXArray.length = 0;","    moveYArray.length = 0;","    let moveZMax = 0;","","    // We can assume that the moving object is not grid based,","    // so there is no need for optimization:","    // getHitBoxes can be called directly.","    const hitBoxes = object.getHitBoxes();","    /** @type {gdjs.AABB | null} */","    let aabb = null;","","    // Check if there is a collision with each object","    for (const otherObject of objects) {","        if (otherObject.id === object.id) {","            continue;","        }","        const moveZ = getSeparationDeltaZ(object, otherObject);","        if (moveZ === 0) {","            continue;","        }","        const moveZSq = moveZ * moveZ;","","        let otherHitBoxesArray = otherObject.getHitBoxes();","        /** @type {Iterable<gdjs.Polygon>} */","        let otherHitBoxes = otherHitBoxesArray;","        if (otherHitBoxesArray.length > 4) {","            // The other object has a lot of hit boxes.","            // Try to reduce the amount of hitboxes to check.","            if (!aabb) {","                aabb = object.getAABB();","            }","            otherHitBoxes = otherObject.getHitBoxesAround(","                aabb.min[0],","                aabb.min[1],","                aabb.max[0],","                aabb.max[1]","            );","        }","        for (const hitBox of hitBoxes) {","            for (const otherHitBox of otherHitBoxes) {","                const result = gdjs.Polygon.collisionTest(","                    hitBox,","                    otherHitBox,","                    true","                );","                if (result.collision) {","                    const moveX = result.move_axis[0];","                    const moveY = result.move_axis[1];","                    if (moveZSq < moveX * moveX + moveY * moveY) {","                        if (Math.abs(moveZ) > Math.abs(moveZMax)) {","                            moveZMax = moveZ;","                        }","                    }","                    else {","                        moveXArray.push(moveX);","                        moveYArray.push(moveY);","                    }","                }","            }","        }","    }","    const hasObjectMovedOnZ = moveZMax !== 0;","    if (hasObjectMovedOnZ) {","        object.setZ(object.getZ() + moveZMax);","    }","    const hasObjectMovedOnXY = moveFollowingSeparatingVectors(object, moveXArray, moveYArray);","    return hasObjectMovedOnXY || hasObjectMovedOnZ;","}","","gdjs._collision3DExtension = {","    getSqDistanceToPosition,","    getDistanceToPosition,","    getSqDistanceToObject,","    getDistanceToObject,","    pickObjectsWithinDistance,","    pickNearestObject,","    pickObjectsInCollision,","    separateFromObjects","}"],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[],"objectGroups":[]},{"fullName":"","functionType":"Action","name":"onFirstSceneLoaded","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"Collision3D::DefineHelperClasses"},"parameters":["",""]}]}],"parameters":[],"objectGroups":[]},{"description":"Compare the distance between two objects in 3D.","fullName":"Distance between two objects in 3D","functionType":"Condition","group":"Position","name":"AreWithinDistance","sentence":"_PARAM1_ distance to _PARAM2_ is below _PARAM3_ pixels","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["// TODO If condition is inverted, only objects that have a distance greater than specified to any other object will be picked.\r","const inverted = false;\r","\r","eventsFunctionContext.returnValue = gdjs._collision3DExtension.pickObjectsWithinDistance(\r","    eventsFunctionContext.getObjectsLists(\"Object\"),\r","    eventsFunctionContext.getObjectsLists(\"OtherObject\"),\r","    eventsFunctionContext.getArgument(\"Distance\"),\r","    eventsFunctionContext.getArgument(\"ShouldUseCustomCenter\"),\r","    inverted\r",");\r",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"Object","name":"Object","type":"objectList"},{"description":"Other object","name":"OtherObject","type":"objectList"},{"description":"Distance","name":"Distance","type":"expression"},{"defaultValue":"yes","description":"Use custom center","name":"ShouldUseCustomCenter","optional":true,"type":"yesorno"}],"objectGroups":[]},{"description":"Distance between two objects in 3D.","fullName":"Distance between two objects in 3D","functionType":"Expression","group":"Position","name":"Distance","sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["\r","const otherObjects = eventsFunctionContext.getObjectsLists(\"OtherObject\");\r","\r","if (objects.length > 0 && otherObjects.length > 0) {\r","    eventsFunctionContext.returnValue = gdjs._collision3DExtension.getDistanceToObject(\r","        objects[0],\r","        otherObjects[0]\r","    );\r","}\r",""],"parameterObjects":"Object","useStrict":true,"eventsSheetExpanded":true}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","type":"objectList"},{"description":"Other object","name":"OtherObject","type":"objectList"}],"objectGroups":[]},{"description":"Square distance between two objects in 3D.","fullName":"Square distance between two objects","functionType":"Expression","group":"Position","name":"SqDistance","sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["\r","const otherObjects = eventsFunctionContext.getObjectsLists(\"OtherObject\");\r","\r","if (objects.length > 0 && otherObjects.length > 0) {\r","    eventsFunctionContext.returnValue = gdjs._collision3DExtension.getSqDistanceToObject(\r","        objects[0],\r","        otherObjects[0]\r","    );\r","}\r",""],"parameterObjects":"Object","useStrict":true,"eventsSheetExpanded":true}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","type":"objectList"},{"description":"Other object","name":"OtherObject","type":"objectList"}],"objectGroups":[]},{"description":"Distance between an object and a position in 3D.","fullName":"Distance between an object and a position","functionType":"Expression","group":"Position","name":"DistanceToPosition","sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["\r","if (objects.length > 0) {\r","    eventsFunctionContext.returnValue = gdjs._collision3DExtension.getDistanceToPosition(\r","        objects[0],\r","        eventsFunctionContext.getArgument(\"PositionX\"),\r","        eventsFunctionContext.getArgument(\"PositionY\"),\r","        eventsFunctionContext.getArgument(\"PositionZ\"),\r","    );\r","}\r",""],"parameterObjects":"Object","useStrict":true,"eventsSheetExpanded":true}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","type":"objectList"},{"description":"X position","name":"PositionX","type":"expression"},{"description":"Y position","name":"PositionY","type":"expression"},{"description":"Z position","name":"PositionZ","type":"expression"}],"objectGroups":[]},{"description":"Square distance between an object and a position in 3D.","fullName":"Square distance between an object and a position","functionType":"Expression","group":"Position","name":"SqDistanceToPosition","sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["\r","if (objects.length > 0) {\r","    eventsFunctionContext.returnValue = gdjs._collision3DExtension.getSqDistanceToPosition(\r","        objects[0],\r","        eventsFunctionContext.getArgument(\"PositionX\"),\r","        eventsFunctionContext.getArgument(\"PositionY\"),\r","        eventsFunctionContext.getArgument(\"PositionZ\"),\r","    );\r","}\r",""],"parameterObjects":"Object","useStrict":true,"eventsSheetExpanded":true}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","type":"objectList"},{"description":"X position","name":"PositionX","type":"expression"},{"description":"Y position","name":"PositionY","type":"expression"},{"description":"Z position","name":"PositionZ","type":"expression"}],"objectGroups":[]},{"description":"Pick the object of this type that is nearest to the specified position in 3D.","fullName":"Pick nearest object in 3D","functionType":"Condition","group":"Objects","name":"PickNearest","sentence":"Pick the _PARAM1_ that is nearest to _PARAM2_ ; _PARAM3_ ; _PARAM4_","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["// TODO If the condition is inverted, the object farthest from the specified position is picked instead.\r","const inverted = false;\r","\r","eventsFunctionContext.returnValue = gdjs._collision3DExtension.pickNearestObject(\r","    eventsFunctionContext.getObjectsLists(\"Object\"),\r","    eventsFunctionContext.getArgument(\"PositionX\"),\r","    eventsFunctionContext.getArgument(\"PositionY\"),\r","    eventsFunctionContext.getArgument(\"PositionZ\"),\r","    inverted\r",");"],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"Object","name":"Object","type":"objectList"},{"description":"X position","name":"PositionX","type":"expression"},{"description":"Y position","name":"PositionY","type":"expression"},{"description":"Z position","name":"PositionZ","type":"expression"}],"objectGroups":[]},{"description":"Check the collision between two objects using their collision masks. Object rotation around X and Y axes are ignored.","fullName":"Collision in 3D","functionType":"Condition","group":"Collision","name":"AreInCollision","sentence":"_PARAM1_ is in collision with _PARAM3_","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["// TODO If the condition is inverted, the object farthest from the specified position is picked instead.\r","const inverted = false;\r","\r","eventsFunctionContext.returnValue = gdjs._collision3DExtension.pickObjectsInCollision(\r","    eventsFunctionContext.getObjectsLists(\"Object\"),\r","    eventsFunctionContext.getObjectsLists(\"OtherObject\"),\r","    eventsFunctionContext.getArgument(\"IgnoreEdges\"),\r","    inverted\r",");"],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"Object","name":"Object","type":"objectList"},{"description":"3D capability","name":"Object3D","supplementaryInformation":"Scene3D::Base3DBehavior","type":"behavior"},{"description":"Other object","name":"OtherObject","type":"objectList"},{"description":"3D capability","name":"OtherObjectCapability","supplementaryInformation":"Scene3D::Base3DBehavior","type":"behavior"},{"description":"Ignore objects that are touching each other on their edges, but are not overlapping (default: no)","name":"IgnoreEdges","type":"yesorno"}],"objectGroups":[]},{"description":"Move an object away from another using their collision masks. Object rotation around X and Y axes are ignored.\nBe sure to call this action on a reasonable number of objects to avoid slowing down the game.","fullName":"Separate objects in 3D","functionType":"Action","group":"Position","name":"SeparateFromObjects","sentence":"Move _PARAM1_ away from _PARAM3_ (only _PARAM1_ will move)","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["\r","const otherObjects = eventsFunctionContext.getObjects(\"OtherObject\");\r","\r","for (const object of objects) {\r","    gdjs._collision3DExtension.separateFromObjects(\r","        object,\r","        otherObjects,\r","    );\r","}"],"parameterObjects":"Object","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"Object","name":"Object","type":"objectList"},{"description":"3D capability","name":"Object3D","supplementaryInformation":"Scene3D::Base3DBehavior","type":"behavior"},{"description":"Objects (won't move)","name":"OtherObject","type":"objectList"},{"description":"3D capability","name":"OtherObject3D","supplementaryInformation":"Scene3D::Base3DBehavior","type":"behavior"}],"objectGroups":[]}],"eventsBasedBehaviors":[],"eventsBasedObjects":[]},{"author":"","category":"Camera","extensionNamespace":"","fullName":"3D camera shake","gdevelopVersion":">=5.5.222","helpPath":"","iconUrl":"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0ibWRpLXZlY3Rvci1kaWZmZXJlbmNlLWFiIiB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggZD0iTTMsMUMxLjg5LDEgMSwxLjg5IDEsM1Y1SDNWM0g1VjFIM003LDFWM0gxMFYxSDdNMTIsMVYzSDE0VjVIMTZWM0MxNiwxLjg5IDE1LjExLDEgMTQsMUgxMk0xLDdWMTBIM1Y3SDFNMTQsN0MxNCw3IDE0LDExLjY3IDE0LDE0QzExLjY3LDE0IDcsMTQgNywxNEM3LDE0IDcsMTggNywyMEM3LDIxLjExIDcuODksMjIgOSwyMkgyMEMyMS4xMSwyMiAyMiwyMS4xMSAyMiwyMFY5QzIyLDcuODkgMjEuMTEsNyAyMCw3QzE4LDcgMTQsNyAxNCw3TTE2LDlIMjBWMjBIOVYxNkgxNEMxNS4xMSwxNiAxNiwxNS4xMSAxNiwxNFY5TTEsMTJWMTRDMSwxNS4xMSAxLjg5LDE2IDMsMTZINVYxNEgzVjEySDFaIiAvPjwvc3ZnPg==","name":"CameraShake3D","previewIconUrl":"https://resources.gdevelop-app.com/assets/Icons/vector-difference-ab.svg","shortDescription":"Shake 3D layer cameras.","version":"0.3.0","description":["Shake layer cameras on 3 rotations.","","- Short shaking can be used to give impact (explosion, hit)","- Shaking can go indefinitely to set an ambiance (engine vibration, earthquake, pulsing)","- Low frequency shaking allows to simulate slow moving objects (ship rocking back and forth)",""],"origin":{"identifier":"CameraShake3D","name":"gdevelop-extension-store"},"tags":["shaking","camera","effect","screen","shake","3d"],"authorIds":["IWykYNRvhCZBN3vEgKEbBPOR3Oc2"],"dependencies":[],"globalVariables":[],"sceneVariables":[{"folded":true,"name":"DefaultFrequency","type":"number","value":24.0},{"folded":true,"name":"DefaultAmplitudeAngleX","type":"number","value":0.5},{"folded":true,"name":"DefaultAmplitudeAngleY","type":"number","value":0.5},{"folded":true,"name":"DefaultAmplitudeAngleZ","type":"number","value":0.5},{"folded":true,"name":"Duration","type":"number","value":0.0},{"name":"Layers","type":"structure","children":[]},{"name":"Layer","type":"structure","children":[{"name":"AmplitudeAngleX","type":"number","value":0.0},{"name":"AmplitudeAngleY","type":"number","value":0.0},{"folded":true,"name":"AmplitudeAngleZ","type":"number","value":0.0},{"folded":true,"name":"CameraDeltaAngleX","type":"number","value":0.0},{"name":"CameraDeltaAngleY","type":"number","value":0.0},{"name":"CameraDeltaAngleZ","type":"number","value":0.0},{"folded":true,"name":"Frequency","type":"number","value":0.0}]},{"folded":true,"name":"LayerName","type":"string","value":""},{"folded":true,"name":"Time","type":"number","value":0.0},{"folded":true,"name":"StartEaseDuration","type":"number","value":0.0},{"folded":true,"name":"StopEaseDuration","type":"number","value":0.0}],"eventsFunctions":[{"fullName":"","functionType":"Action","name":"onSceneLoaded","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetNumberVariable"},"parameters":["Index","=","0"]}],"events":[{"type":"BuiltinCommonInstructions::Repeat","repeatExpression":"CameraShake3D::LayerCount()","conditions":[],"actions":[{"type":{"value":"CameraShake3D::SetLayerShakable"},"parameters":["","","CameraShake3D::LayerName(Index)",""]},{"type":{"value":"SetNumberVariable"},"parameters":["Index","+","1"]}]}],"variables":[{"folded":true,"name":"Index","type":"number","value":0.0}]}],"parameters":[],"objectGroups":[]},{"description":"Return the number of layers the current scene has. ","fullName":"Layer count","functionType":"Expression","name":"LayerCount","private":true,"sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["gdjs._cameraShake3DExtension = gdjs._cameraShake3DExtension || {};\r","gdjs._cameraShake3DExtension.layerNames = gdjs._cameraShake3DExtension.layerNames || [];\r","const layerNames = gdjs._cameraShake3DExtension.layerNames;\r","runtimeScene.getAllLayerNames(layerNames);\r","\r","eventsFunctionContext.returnValue = layerNames.length;\r",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":false}],"expressionType":{"type":"expression"},"parameters":[],"objectGroups":[]},{"description":"Return the number of layers the current scene has. ","fullName":"Layer name","functionType":"StringExpression","name":"LayerName","private":true,"sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["const layerIndex = eventsFunctionContext.getArgument(\"LayerIndex\");\r","\r","gdjs._cameraShake3DExtension = gdjs._cameraShake3DExtension || {};\r","gdjs._cameraShake3DExtension.layerNames = gdjs._cameraShake3DExtension.layerNames || [];\r","const layerNames = gdjs._cameraShake3DExtension.layerNames;\r","runtimeScene.getAllLayerNames(layerNames);\r","\r","eventsFunctionContext.returnValue = layerNames[layerIndex];\r",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":false}],"expressionType":{"type":"string"},"parameters":[{"description":"Layer index","name":"LayerIndex","type":"expression"}],"objectGroups":[]},{"fullName":"","functionType":"Action","name":"onScenePostEvents","sentence":"","events":[{"type":"BuiltinCommonInstructions::Comment","color":{"b":109,"g":230,"r":255,"textB":0,"textG":0,"textR":0},"comment":"Step time counters."},{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetNumberVariable"},"parameters":["Time","+","TimeDelta()"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"CameraShake3D::IsShaking"},"parameters":["",""]}],"actions":[],"events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[],"events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"NumberVariable"},"parameters":["Time","<","StartEaseDuration"]},{"type":{"inverted":true,"value":"NumberVariable"},"parameters":["Time",">","Duration - StopEaseDuration"]}],"actions":[{"type":{"value":"SetNumberVariable"},"parameters":["EaseFactor","=","clamp(Time / StartEaseDuration, 0, 1)"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"NumberVariable"},"parameters":["Time",">","Duration - StopEaseDuration"]}],"actions":[{"type":{"value":"SetNumberVariable"},"parameters":["EaseFactor","=","clamp((Duration - Time) / StopEaseDuration, 0, 1)"]}]},{"type":"BuiltinCommonInstructions::ForEachChildVariable","iterableVariableName":"Layers","valueIteratorVariableName":"Layer","keyIteratorVariableName":"LayerName","conditions":[{"type":{"value":"BooleanVariable"},"parameters":["Layers[LayerName].Shakable","True",""]}],"actions":[],"events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetStringVariable"},"parameters":["ActualLayerName","=","LayerName"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"StringVariable"},"parameters":["LayerName","=","\"__BaseLayer\""]}],"actions":[{"type":{"value":"SetStringVariable"},"parameters":["ActualLayerName","=","\"\""]}]},{"type":"BuiltinCommonInstructions::Comment","color":{"b":109,"g":230,"r":255,"textB":0,"textG":0,"textR":0},"comment":"Default values when there is no layer specific value set."},{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"CameraShake3D::SetFrequency"},"parameters":["","DefaultFrequency","\"\"",""]},{"type":{"value":"SetNumberVariable"},"parameters":["AmplitudeAngleZ","=","DefaultAmplitudeAngleZ"]},{"type":{"value":"SetNumberVariable"},"parameters":["AmplitudeAngleY","=","DefaultAmplitudeAngleY"]},{"type":{"value":"SetNumberVariable"},"parameters":["AmplitudeAngleX","=","DefaultAmplitudeAngleX"]},{"type":{"value":"SetNumberVariable"},"parameters":["Layers[LayerName].CameraDeltaAngleZ","=","0"]},{"type":{"value":"SetNumberVariable"},"parameters":["Layers[LayerName].CameraDeltaAngleY","=","0"]},{"type":{"value":"SetNumberVariable"},"parameters":["Layers[LayerName].CameraDeltaAngleX","=","0"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"VariableChildExists2"},"parameters":["Layer","\"Frequency\""]}],"actions":[{"type":{"value":"CameraShake3D::SetFrequency"},"parameters":["","Layer.Frequency","\"\"",""]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"VariableChildExists2"},"parameters":["Layer","\"AmplitudeAngleZ\""]}],"actions":[{"type":{"value":"SetNumberVariable"},"parameters":["AmplitudeAngleZ","=","Layer.AmplitudeAngleZ"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"VariableChildExists2"},"parameters":["Layer","\"AmplitudeAngleY\""]}],"actions":[{"type":{"value":"SetNumberVariable"},"parameters":["AmplitudeAngleY","=","Layer.AmplitudeAngleY"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"VariableChildExists2"},"parameters":["Layer","\"AmplitudeAngleX\""]}],"actions":[{"type":{"value":"SetNumberVariable"},"parameters":["AmplitudeAngleX","=","Layer.AmplitudeAngleX"]}]},{"type":"BuiltinCommonInstructions::Comment","color":{"b":109,"g":230,"r":255,"textB":0,"textG":0,"textR":0},"comment":"Shake the layer camera.\nSave the camera displacement to revert it in onScenePostEvents."},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"NumberVariable"},"parameters":["AmplitudeAngleZ","!=","0"]}],"actions":[{"type":{"value":"SetNumberVariable"},"parameters":["Layers[LayerName].CameraDeltaAngleZ","=","CameraShake3D::Noise2d(\"\", TimeFromStart(), 1000) * AmplitudeAngleZ * EaseFactor"]},{"type":{"value":"CameraShake3D::SpinCamera"},"parameters":["","Layers[LayerName].CameraDeltaAngleZ","ActualLayerName","VariableString(__CameraShake.ActualLayerName)"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"NumberVariable"},"parameters":["AmplitudeAngleY","!=","0"]}],"actions":[{"type":{"value":"SetNumberVariable"},"parameters":["Layers[LayerName].CameraDeltaAngleY","=","CameraShake3D::Noise2d(\"\", TimeFromStart(), 2000) * AmplitudeAngleY * EaseFactor"]},{"type":{"value":"CameraShake3D::TurnCameraHorizontally"},"parameters":["","Layers[LayerName].CameraDeltaAngleY","ActualLayerName","VariableString(__CameraShake.ActualLayerName)"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"NumberVariable"},"parameters":["AmplitudeAngleX","!=","0"]}],"actions":[{"type":{"value":"SetNumberVariable"},"parameters":["Layers[LayerName].CameraDeltaAngleX","=","CameraShake3D::Noise2d(\"\", TimeFromStart(), 3000) * AmplitudeAngleX * EaseFactor"]},{"type":{"value":"CameraShake3D::TurnCameraVertically"},"parameters":["","Layers[LayerName].CameraDeltaAngleX","ActualLayerName","VariableString(__CameraShake.ActualLayerName)"]}]}]}],"variables":[{"folded":true,"name":"AmplitudeAngleZ","type":"number","value":0.0},{"folded":true,"name":"AmplitudeAngleY","type":"number","value":0.0},{"folded":true,"name":"AmplitudeAngleX","type":"number","value":0.0},{"folded":true,"name":"EaseFactor","type":"number","value":1.0},{"folded":true,"name":"ActualLayerName","type":"string","value":""}]}]}],"parameters":[],"objectGroups":[]},{"fullName":"","functionType":"Action","name":"onScenePreEvents","sentence":"","events":[{"type":"BuiltinCommonInstructions::Comment","color":{"b":109,"g":230,"r":255,"textB":0,"textG":0,"textR":0},"comment":"Revert the shaking."},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"CameraShake3D::IsShaking"},"parameters":["",""]}],"actions":[],"events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[],"events":[{"type":"BuiltinCommonInstructions::ForEachChildVariable","iterableVariableName":"__CameraShake.Layers","valueIteratorVariableName":"Layer","keyIteratorVariableName":"LayerName","conditions":[{"type":{"value":"BooleanVariable"},"parameters":["Layers[LayerName].Shakable","True",""]}],"actions":[],"events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetStringVariable"},"parameters":["ActualLayerName","=","LayerName"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"StringVariable"},"parameters":["LayerName","=","\"__BaseLayer\""]}],"actions":[{"type":{"value":"SetStringVariable"},"parameters":["ActualLayerName","=","\"\""]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"CameraShake3D::SpinCamera"},"parameters":["","0 - Layers[LayerName].CameraDeltaAngleZ","ActualLayerName","VariableString(__CameraShake.ActualLayerName)"]},{"type":{"value":"CameraShake3D::TurnCameraHorizontally"},"parameters":["","0 - Layers[LayerName].CameraDeltaAngleY","ActualLayerName","VariableString(__CameraShake.ActualLayerName)"]},{"type":{"value":"CameraShake3D::TurnCameraVertically"},"parameters":["","0 - Layers[LayerName].CameraDeltaAngleX","ActualLayerName","VariableString(__CameraShake.ActualLayerName)"]}]}]}],"variables":[{"folded":true,"name":"ActualLayerName","type":"string","value":""}]}]}],"parameters":[],"objectGroups":[]},{"description":"Shake the camera on layers chosen with configuration actions.","fullName":"Shake camera","functionType":"Action","name":"ShakeCamera","sentence":"Shake camera for _PARAM1_ seconds with _PARAM2_ seconds of easing to start and _PARAM3_ seconds to stop","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetNumberVariable"},"parameters":["Time","=","0"]},{"type":{"value":"SetNumberVariable"},"parameters":["Duration","=","NewDuration"]},{"type":{"value":"SetNumberVariable"},"parameters":["StartEaseDuration","=","NewStartEaseDuration"]},{"type":{"value":"SetNumberVariable"},"parameters":["StopEaseDuration","=","NewStopEaseDuration"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"NumberVariable"},"parameters":["Duration","<","StartEaseDuration + StopEaseDuration"]}],"actions":[{"type":{"value":"SetNumberVariable"},"parameters":["StartEaseDuration","=","StartEaseDuration * Duration / (StartEaseDuration + StopEaseDuration)"]},{"type":{"value":"SetNumberVariable"},"parameters":["StopEaseDuration","=","StopEaseDuration * Duration / (StartEaseDuration + StopEaseDuration)"]}]}],"parameters":[{"description":"Duration (in seconds)","name":"NewDuration","type":"expression"},{"description":"Ease duration to start (in seconds)","name":"NewStartEaseDuration","type":"expression"},{"description":"Ease duration to stop (in seconds)","name":"NewStopEaseDuration","type":"expression"}],"objectGroups":[]},{"description":"Start shaking the camera indefinitely.","fullName":"Start camera shaking","functionType":"Action","name":"StartShaking","sentence":"Start shaking the camera with _PARAM1_ seconds of easing","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetNumberVariable"},"parameters":["Time","=","0"]},{"type":{"value":"SetNumberVariable"},"parameters":["Duration","=","1234567890"]},{"type":{"value":"SetNumberVariable"},"parameters":["StartEaseDuration","=","EaseDuration"]}]}],"parameters":[{"description":"Ease duration (in seconds)","name":"EaseDuration","type":"expression"}],"objectGroups":[]},{"description":"Stop shaking the camera.","fullName":"Stop camera shaking","functionType":"Action","name":"StopShaking","sentence":"Stop shaking the camera with _PARAM1_ seconds of easing","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetNumberVariable"},"parameters":["Time","=","0"]},{"type":{"value":"SetNumberVariable"},"parameters":["Duration","=","EaseDuration"]},{"type":{"value":"SetNumberVariable"},"parameters":["StopEaseDuration","=","EaseDuration"]}]}],"parameters":[{"description":"Ease duration (in seconds)","name":"EaseDuration","type":"expression"}],"objectGroups":[]},{"description":"Mark a layer as shakable.","fullName":"Shakable layer","functionType":"Action","group":"Camera shake configuration","name":"SetLayerShakable","sentence":"Mark the layer: _PARAM2_ as shakable: _PARAM1_","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetStringVariable"},"parameters":["LayerName","=","NewLayerName"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"BuiltinCommonInstructions::CompareStrings"},"parameters":["NewLayerName","=","\"\""]}],"actions":[{"type":{"value":"SetStringVariable"},"parameters":["LayerName","=","\"__BaseLayer\""]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"inverted":true,"value":"BooleanVariable"},"parameters":["Shakable","True",""]}],"actions":[{"type":{"value":"SetBooleanVariable"},"parameters":["Layers[LayerName].Shakable","False",""]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"BooleanVariable"},"parameters":["Shakable","True",""]}],"actions":[{"type":{"value":"SetBooleanVariable"},"parameters":["Layers[LayerName].Shakable","True",""]}]}],"parameters":[{"defaultValue":"yes","description":"Shakable","name":"Shakable","optional":true,"type":"yesorno"},{"description":"Layer","name":"NewLayerName","type":"layer"}],"objectGroups":[]},{"description":"Check if the camera is shaking.","fullName":"Camera is shaking","functionType":"Condition","name":"IsShaking","sentence":"Camera is shaking","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"NumberVariable"},"parameters":["Time","<","Duration"]}],"actions":[{"type":{"value":"SetReturnBoolean"},"parameters":["True"]}]}],"parameters":[],"objectGroups":[]},{"description":"the spinning amplitude of the shaking (in degrees).","fullName":"Spinning shake amplitude","functionType":"ExpressionAndCondition","group":"Camera shake configuration","name":"SpineAmplitudeAngle","sentence":"the spinning shake amplitude of layer: _PARAM1_","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetStringVariable"},"parameters":["LayerName","=","NewLayerName"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"BuiltinCommonInstructions::CompareStrings"},"parameters":["NewLayerName","=","\"\""]}],"actions":[{"type":{"value":"SetStringVariable"},"parameters":["LayerName","=","\"__BaseLayer\""]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["Layers[LayerName].AmplitudeAngleZ"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Layer","name":"NewLayerName","type":"layer"}],"objectGroups":[]},{"fullName":"","functionType":"ActionWithOperator","getterName":"SpineAmplitudeAngle","group":"Camera shake configuration","name":"SetSpineAmplitudeAngle","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetStringVariable"},"parameters":["LayerName","=","NewLayerName"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"BuiltinCommonInstructions::CompareStrings"},"parameters":["NewLayerName","=","\"\""]}],"actions":[{"type":{"value":"SetStringVariable"},"parameters":["LayerName","=","\"__BaseLayer\""]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetNumberVariable"},"parameters":["Layers[LayerName].AmplitudeAngleZ","=","Value"]}]}],"parameters":[],"objectGroups":[]},{"description":"the horizontal rotation amplitude of the shaking (in degrees).","fullName":"Horizontal rotation amplitude","functionType":"ExpressionAndCondition","group":"Camera shake configuration","name":"HorizontalAmplitudeAngle","sentence":"the horizontal shaking amplitude of layer: _PARAM1_","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetStringVariable"},"parameters":["LayerName","=","NewLayerName"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"BuiltinCommonInstructions::CompareStrings"},"parameters":["NewLayerName","=","\"\""]}],"actions":[{"type":{"value":"SetStringVariable"},"parameters":["LayerName","=","\"__BaseLayer\""]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["Layers[LayerName].AmplitudeAngleY"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Layer","name":"NewLayerName","type":"layer"}],"objectGroups":[]},{"fullName":"","functionType":"ActionWithOperator","getterName":"HorizontalAmplitudeAngle","group":"Camera shake configuration","name":"SetHorizontalAmplitudeAngle","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetStringVariable"},"parameters":["LayerName","=","NewLayerName"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"BuiltinCommonInstructions::CompareStrings"},"parameters":["NewLayerName","=","\"\""]}],"actions":[{"type":{"value":"SetStringVariable"},"parameters":["LayerName","=","\"__BaseLayer\""]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetNumberVariable"},"parameters":["Layers[LayerName].AmplitudeAngleY","=","Value"]}]}],"parameters":[],"objectGroups":[]},{"description":"the vertical rotation amplitude of the shaking (in degrees).","fullName":"Vertical rotation amplitude","functionType":"ExpressionAndCondition","group":"Camera shake configuration","name":"VerticalAmplitudeAngle","sentence":"the vertical shaking amplitude of layer: _PARAM1_","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetStringVariable"},"parameters":["LayerName","=","NewLayerName"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"BuiltinCommonInstructions::CompareStrings"},"parameters":["NewLayerName","=","\"\""]}],"actions":[{"type":{"value":"SetStringVariable"},"parameters":["LayerName","=","\"__BaseLayer\""]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["Layers[LayerName].AmplitudeAngleX"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Layer","name":"NewLayerName","type":"layer"}],"objectGroups":[]},{"fullName":"","functionType":"ActionWithOperator","getterName":"VerticalAmplitudeAngle","group":"Camera shake configuration","name":"SetVerticalAmplitudeAngle","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetStringVariable"},"parameters":["LayerName","=","NewLayerName"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"BuiltinCommonInstructions::CompareStrings"},"parameters":["NewLayerName","=","\"\""]}],"actions":[{"type":{"value":"SetStringVariable"},"parameters":["LayerName","=","\"__BaseLayer\""]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetNumberVariable"},"parameters":["Layers[LayerName].AmplitudeAngleX","=","Value"]}]}],"parameters":[],"objectGroups":[]},{"description":"Change the number of back and forth per seconds.","fullName":"Layer shaking frequency","functionType":"Action","group":"Camera shake configuration","name":"SetLayerShakingFrequency","sentence":"Change the shaking frequency to _PARAM1_ (layer: _PARAM2_)","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetStringVariable"},"parameters":["LayerName","=","NewLayerName"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"BuiltinCommonInstructions::CompareStrings"},"parameters":["NewLayerName","=","\"\""]}],"actions":[{"type":{"value":"SetStringVariable"},"parameters":["LayerName","=","\"__BaseLayer\""]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetNumberVariable"},"parameters":["Layers[LayerName].Frequency","=","Frequency"]}]}],"parameters":[{"description":"Frequency","name":"Frequency","type":"expression"},{"description":"Layer","name":"NewLayerName","type":"layer"}],"objectGroups":[]},{"description":"Rotates the camera around its own direction.","fullName":"Spin camera","functionType":"Action","name":"SpinCamera","private":true,"sentence":"Spin the camera (layer: _PARAM2_) by _PARAM1_°","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["const angle = eventsFunctionContext.getArgument(\"Angle\");","const layerName = eventsFunctionContext.getArgument(\"NewLayer\");","","if (angle === 0) {","    return;","}","","const layer = runtimeScene.getLayer(layerName);","const camera = layer.getRenderer().getThreeCamera();","if (camera) {","    camera.rotation.z = gdjs.toRad(layer.getCameraRotation());","    ","    camera.rotateZ(gdjs.toRad(angle));","","    layer.setCameraRotation(gdjs.toDegrees(camera.rotation.z));","}",""],"parameterObjects":"Object","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"Angle (in degrees)","name":"Angle","type":"expression"},{"description":"Layer","name":"NewLayer","type":"layer"}],"objectGroups":[]},{"description":"Rotate the camera vertically according to its own direction.","fullName":"Rotate camera vertically","functionType":"Action","name":"TurnCameraVertically","private":true,"sentence":"Rotate the camera (layer: _PARAM2_) vertically by _PARAM1_°","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["const angle = eventsFunctionContext.getArgument(\"Angle\");","const layerName = eventsFunctionContext.getArgument(\"NewLayer\");","","if (angle === 0) {","    return;","}","","const layer = runtimeScene.getLayer(layerName);","const camera = layer.getRenderer().getThreeCamera();","if (camera) {","    camera.rotation.z = gdjs.toRad(layer.getCameraRotation());","    ","    camera.rotateX(gdjs.toRad(angle));","","    layer.setCameraRotation(gdjs.toDegrees(camera.rotation.z));","}"],"parameterObjects":"Object","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"Angle (in degrees)","name":"Angle","type":"expression"},{"description":"Layer","name":"NewLayer","type":"layer"}],"objectGroups":[]},{"description":"Rotate the camera horizontally according to its own direction.","fullName":"Rotate camera horizontally","functionType":"Action","name":"TurnCameraHorizontally","private":true,"sentence":"Rotate the camera (layer: _PARAM2_) horizontally by _PARAM1_°","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["const angle = eventsFunctionContext.getArgument(\"Angle\");","const layerName = eventsFunctionContext.getArgument(\"NewLayer\");","","if (angle === 0) {","    return;","}","","const layer = runtimeScene.getLayer(layerName);","const camera = layer.getRenderer().getThreeCamera();","if (camera) {","    camera.rotation.z = gdjs.toRad(layer.getCameraRotation());","    ","    camera.rotateY(gdjs.toRad(angle));","","    layer.setCameraRotation(gdjs.toDegrees(camera.rotation.z));","}"],"parameterObjects":"Object","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"Angle (in degrees)","name":"Angle","type":"expression"},{"description":"Layer","name":"NewLayer","type":"layer"}],"objectGroups":[]},{"fullName":"","functionType":"Action","name":"onFirstSceneLoaded","sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (gdjs._cameraShake3DExtension) {","    return;","}","","/** Noise generator manager. */","class NoiseManager {","    /**","     * Create the manager of noise generators.","     */","    constructor() {","        this.seed = gdjs.randomInRange(1, Number.MAX_SAFE_INTEGER);","        /** @type {Map<string, NoiseGenerator>} */","        this.generators = new Map();","    }","","    /**","     * @param name {string}","     * @return {NoiseGenerator}","     */","    getGenerator(name) {","        let generator = this.generators.get(name);","        if (!generator) {","            generator = new NoiseGenerator(name + this.seed);","            this.generators.set(name, generator);","        }","        return generator;","    }","","    /**","     * @param seed {number}","     */","    setSeed(seed) {","        this.seed = seed;","        this.generators.forEach(generator => generator.setSeed(name + this.seed));","    }","","    /**","     * @param name {string}","     */","    deleteGenerator(name) {","        this.generators.delete(name);","    }","","    /**","     */","    deleteAllGenerators() {","        this.generators.clear();","    }","}","","/** Noise generator with octaves. */","class NoiseGenerator {","    /**","     * Create a noise generator with a seed.","     * @param seed {string}","     */","    constructor(seed) {","        this.simplexNoise = new SimplexNoise(seed);","        this.frequency = 1;","        this.octaves = 1;","        this.persistence = 0.5;","        this.lacunarity = 2;","        this.xLoopPeriod = 0;","        this.yLoopPeriod = 0;","    }","","    /**","     * @param seed {string}","     */","    setSeed(seed) {","        this.simplexNoise = new SimplexNoise(seed);","    }","","    /**","     * @param x {float}","     * @param y {float}","     * @param z {float} optionnal","     * @param w {float} optionnal","     * @return {float}","     */","    noise(x, y, z, w) {","        if (this.xLoopPeriod && this.yLoopPeriod) {","            const circleRatioX = 2 * Math.PI / this.xLoopPeriod;","            const circleRatioY = 2 * Math.PI / this.yLoopPeriod;","            const angleX = circleRatioX * x;","            const angleY = circleRatioY * y;","            x = Math.cos(angleX) / circleRatioX;","            y = Math.sin(angleX) / circleRatioX;","            z = Math.cos(angleY) / circleRatioY;","            w = Math.sin(angleY) / circleRatioY;","        }","        else if (this.xLoopPeriod) {","            const circleRatio = 2 * Math.PI / this.xLoopPeriod;","            const angleX = circleRatio * x;","            w = z;","            z = y;","            x = Math.cos(angleX) / circleRatio;","            y = Math.sin(angleX) / circleRatio;","        }","        else if (this.yLoopPeriod) {","            const circleRatio = 2 * Math.PI / this.xLoopPeriod;","            const angleX = circleRatio * x;","            w = z;","            // Make the circle perimeter equals to the looping period","            // to keep the same perceived frequency with or without looping.","            y = Math.cos(angleX) / circleRatio;","            z = Math.sin(angleX) / circleRatio;","        }","        let noiseFunction = this.simplexNoise.noise4D.bind(this.simplexNoise);","        if (z === undefined) {","            noiseFunction = this.simplexNoise.noise2D.bind(this.simplexNoise);","        }","        else if (w === undefined) {","            noiseFunction = this.simplexNoise.noise3D.bind(this.simplexNoise);","        }","        let frequency = this.frequency;","        let noiseSum = 0;","        let amplitudeSum = 0;","        let amplitude = 1;","        for (let i = 0; i < this.octaves; i++) {","            noiseSum += noiseFunction(x * frequency, y * frequency, z * frequency, w * frequency) * amplitude;","            amplitudeSum += Math.abs(amplitude);","            amplitude *= this.persistence;","            frequency *= this.lacunarity;","        }","        return noiseSum / amplitudeSum;","    }","}","","/*","A fast javascript implementation of simplex noise by Jonas Wagner","https://github.com/jwagner/simplex-noise.js","","Based on a speed-improved simplex noise algorithm for 2D, 3D and 4D in Java.","Which is based on example code by Stefan Gustavson (stegu@itn.liu.se).","With Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).","Better rank ordering method by Stefan Gustavson in 2012.",""," Copyright (c) 2021 Jonas Wagner",""," Permission is hereby granted, free of charge, to any person obtaining a copy"," of this software and associated documentation files (the \"Software\"), to deal"," in the Software without restriction, including without limitation the rights"," to use, copy, modify, merge, publish, distribute, sublicense, and/or sell"," copies of the Software, and to permit persons to whom the Software is"," furnished to do so, subject to the following conditions:",""," The above copyright notice and this permission notice shall be included in all"," copies or substantial portions of the Software.",""," THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR"," IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,"," FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE"," AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER"," LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,"," OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE"," SOFTWARE."," */","","const F2 = 0.5 * (Math.sqrt(3.0) - 1.0);","const G2 = (3.0 - Math.sqrt(3.0)) / 6.0;","const F3 = 1.0 / 3.0;","const G3 = 1.0 / 6.0;","const F4 = (Math.sqrt(5.0) - 1.0) / 4.0;","const G4 = (5.0 - Math.sqrt(5.0)) / 20.0;","const grad3 = new Float32Array([1, 1, 0,","    -1, 1, 0,","    1, -1, 0,","    -1, -1, 0,","    1, 0, 1,","    -1, 0, 1,","    1, 0, -1,","    -1, 0, -1,","    0, 1, 1,","    0, -1, 1,","    0, 1, -1,","    0, -1, -1]);","const grad4 = new Float32Array([0, 1, 1, 1, 0, 1, 1, -1, 0, 1, -1, 1, 0, 1, -1, -1,","    0, -1, 1, 1, 0, -1, 1, -1, 0, -1, -1, 1, 0, -1, -1, -1,","    1, 0, 1, 1, 1, 0, 1, -1, 1, 0, -1, 1, 1, 0, -1, -1,","    -1, 0, 1, 1, -1, 0, 1, -1, -1, 0, -1, 1, -1, 0, -1, -1,","    1, 1, 0, 1, 1, 1, 0, -1, 1, -1, 0, 1, 1, -1, 0, -1,","    -1, 1, 0, 1, -1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, -1,","    1, 1, 1, 0, 1, 1, -1, 0, 1, -1, 1, 0, 1, -1, -1, 0,","    -1, 1, 1, 0, -1, 1, -1, 0, -1, -1, 1, 0, -1, -1, -1, 0]);","","","/**"," * Builds a random permutation table."," * This is exported only for (internal) testing purposes."," * Do not rely on this export."," * @param {() => number} random"," * @private"," */","function buildPermutationTable(random) {","    const p = new Uint8Array(256);","    for (let i = 0; i < 256; i++) {","        p[i] = i;","    }","    for (let i = 0; i < 255; i++) {","        const r = i + ~~(random() * (256 - i));","        const aux = p[i];","        p[i] = p[r];","        p[r] = aux;","    }","    return p;","}","","/*","The ALEA PRNG and masher code used by simplex-noise.js","is based on code by Johannes Baagøe, modified by Jonas Wagner.","See alea.md for the full license.","@param {string|number} seed","*/","function alea(seed) {","    let s0 = 0;","    let s1 = 0;","    let s2 = 0;","    let c = 1;","    const mash = masher();","    s0 = mash(' ');","    s1 = mash(' ');","    s2 = mash(' ');","    s0 -= mash(seed);","    if (s0 < 0) {","        s0 += 1;","    }","    s1 -= mash(seed);","    if (s1 < 0) {","        s1 += 1;","    }","    s2 -= mash(seed);","    if (s2 < 0) {","        s2 += 1;","    }","    return function () {","        const t = 2091639 * s0 + c * 2.3283064365386963e-10; // 2^-32","        s0 = s1;","        s1 = s2;","        return s2 = t - (c = t | 0);","    };","}","","function masher() {","    let n = 0xefc8249d;","    return function (data) {","        data = data.toString();","        for (let i = 0; i < data.length; i++) {","            n += data.charCodeAt(i);","            let h = 0.02519603282416938 * n;","            n = h >>> 0;","            h -= n;","            h *= n;","            n = h >>> 0;","            h -= n;","            n += h * 0x100000000; // 2^32","        }","        return (n >>> 0) * 2.3283064365386963e-10; // 2^-32","    };","}","","/** Deterministic simplex noise generator suitable for 2D, 3D and 4D spaces. */","class SimplexNoise {","    /**","     * Creates a new `SimplexNoise` instance.","     * This involves some setup. You can save a few cpu cycles by reusing the same instance.","     * @param {(() => number)|string|number} randomOrSeed A random number generator or a seed (string|number).","     * Defaults to Math.random (random irreproducible initialization).","     */","    constructor(randomOrSeed) {","        if (randomOrSeed === void 0) { randomOrSeed = Math.random; }","        const random = typeof randomOrSeed == 'function' ? randomOrSeed : alea(randomOrSeed);","        this.p = buildPermutationTable(random);","        this.perm = new Uint8Array(512);","        this.permMod12 = new Uint8Array(512);","        for (let i = 0; i < 512; i++) {","            this.perm[i] = this.p[i & 255];","            this.permMod12[i] = this.perm[i] % 12;","        }","    }","","    /**","     * Samples the noise field in 2 dimensions","     * @param {number} x","     * @param {number} y","     * @returns a number in the interval [-1, 1]","     */","    noise2D(x, y) {","        const permMod12 = this.permMod12;","        const perm = this.perm;","        let n0 = 0; // Noise contributions from the three corners","        let n1 = 0;","        let n2 = 0;","        // Skew the input space to determine which simplex cell we're in","        const s = (x + y) * F2; // Hairy factor for 2D","        const i = Math.floor(x + s);","        const j = Math.floor(y + s);","        const t = (i + j) * G2;","        const X0 = i - t; // Unskew the cell origin back to (x,y) space","        const Y0 = j - t;","        const x0 = x - X0; // The x,y distances from the cell origin","        const y0 = y - Y0;","        // For the 2D case, the simplex shape is an equilateral triangle.","        // Determine which simplex we are in.","        let i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords","        if (x0 > y0) {","            i1 = 1;","            j1 = 0;","        } // lower triangle, XY order: (0,0)->(1,0)->(1,1)","        else {","            i1 = 0;","            j1 = 1;","        } // upper triangle, YX order: (0,0)->(0,1)->(1,1)","        // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and","        // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where","        // c = (3-sqrt(3))/6","        const x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords","        const y1 = y0 - j1 + G2;","        const x2 = x0 - 1.0 + 2.0 * G2; // Offsets for last corner in (x,y) unskewed coords","        const y2 = y0 - 1.0 + 2.0 * G2;","        // Work out the hashed gradient indices of the three simplex corners","        const ii = i & 255;","        const jj = j & 255;","        // Calculate the contribution from the three corners","        let t0 = 0.5 - x0 * x0 - y0 * y0;","        if (t0 >= 0) {","            const gi0 = permMod12[ii + perm[jj]] * 3;","            t0 *= t0;","            n0 = t0 * t0 * (grad3[gi0] * x0 + grad3[gi0 + 1] * y0); // (x,y) of grad3 used for 2D gradient","        }","        let t1 = 0.5 - x1 * x1 - y1 * y1;","        if (t1 >= 0) {","            const gi1 = permMod12[ii + i1 + perm[jj + j1]] * 3;","            t1 *= t1;","            n1 = t1 * t1 * (grad3[gi1] * x1 + grad3[gi1 + 1] * y1);","        }","        let t2 = 0.5 - x2 * x2 - y2 * y2;","        if (t2 >= 0) {","            const gi2 = permMod12[ii + 1 + perm[jj + 1]] * 3;","            t2 *= t2;","            n2 = t2 * t2 * (grad3[gi2] * x2 + grad3[gi2 + 1] * y2);","        }","        // Add contributions from each corner to get the final noise value.","        // The result is scaled to return values in the interval [-1,1].","        return 70.0 * (n0 + n1 + n2);","    }","","    /**","     * Samples the noise field in 3 dimensions","     * @param {number} x","     * @param {number} y","     * @param {number} z","     * @returns a number in the interval [-1, 1]","     */","    noise3D(x, y, z) {","        const permMod12 = this.permMod12;","        const perm = this.perm;","        let n0, n1, n2, n3; // Noise contributions from the four corners","        // Skew the input space to determine which simplex cell we're in","        const s = (x + y + z) * F3; // Very nice and simple skew factor for 3D","        const i = Math.floor(x + s);","        const j = Math.floor(y + s);","        const k = Math.floor(z + s);","        const t = (i + j + k) * G3;","        const X0 = i - t; // Unskew the cell origin back to (x,y,z) space","        const Y0 = j - t;","        const Z0 = k - t;","        const x0 = x - X0; // The x,y,z distances from the cell origin","        const y0 = y - Y0;","        const z0 = z - Z0;","        // For the 3D case, the simplex shape is a slightly irregular tetrahedron.","        // Determine which simplex we are in.","        let i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords","        let i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords","        if (x0 >= y0) {","            if (y0 >= z0) {","                i1 = 1;","                j1 = 0;","                k1 = 0;","                i2 = 1;","                j2 = 1;","                k2 = 0;","            } // X Y Z order","            else if (x0 >= z0) {","                i1 = 1;","                j1 = 0;","                k1 = 0;","                i2 = 1;","                j2 = 0;","                k2 = 1;","            } // X Z Y order","            else {","                i1 = 0;","                j1 = 0;","                k1 = 1;","                i2 = 1;","                j2 = 0;","                k2 = 1;","            } // Z X Y order","        }","        else { // x0<y0","            if (y0 < z0) {","                i1 = 0;","                j1 = 0;","                k1 = 1;","                i2 = 0;","                j2 = 1;","                k2 = 1;","            } // Z Y X order","            else if (x0 < z0) {","                i1 = 0;","                j1 = 1;","                k1 = 0;","                i2 = 0;","                j2 = 1;","                k2 = 1;","            } // Y Z X order","            else {","                i1 = 0;","                j1 = 1;","                k1 = 0;","                i2 = 1;","                j2 = 1;","                k2 = 0;","            } // Y X Z order","        }","        // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),","        // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and","        // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where","        // c = 1/6.","        const x1 = x0 - i1 + G3; // Offsets for second corner in (x,y,z) coords","        const y1 = y0 - j1 + G3;","        const z1 = z0 - k1 + G3;","        const x2 = x0 - i2 + 2.0 * G3; // Offsets for third corner in (x,y,z) coords","        const y2 = y0 - j2 + 2.0 * G3;","        const z2 = z0 - k2 + 2.0 * G3;","        const x3 = x0 - 1.0 + 3.0 * G3; // Offsets for last corner in (x,y,z) coords","        const y3 = y0 - 1.0 + 3.0 * G3;","        const z3 = z0 - 1.0 + 3.0 * G3;","        // Work out the hashed gradient indices of the four simplex corners","        const ii = i & 255;","        const jj = j & 255;","        const kk = k & 255;","        // Calculate the contribution from the four corners","        let t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;","        if (t0 < 0)","            n0 = 0.0;","        else {","            const gi0 = permMod12[ii + perm[jj + perm[kk]]] * 3;","            t0 *= t0;","            n0 = t0 * t0 * (grad3[gi0] * x0 + grad3[gi0 + 1] * y0 + grad3[gi0 + 2] * z0);","        }","        let t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;","        if (t1 < 0)","            n1 = 0.0;","        else {","            const gi1 = permMod12[ii + i1 + perm[jj + j1 + perm[kk + k1]]] * 3;","            t1 *= t1;","            n1 = t1 * t1 * (grad3[gi1] * x1 + grad3[gi1 + 1] * y1 + grad3[gi1 + 2] * z1);","        }","        let t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;","        if (t2 < 0)","            n2 = 0.0;","        else {","            const gi2 = permMod12[ii + i2 + perm[jj + j2 + perm[kk + k2]]] * 3;","            t2 *= t2;","            n2 = t2 * t2 * (grad3[gi2] * x2 + grad3[gi2 + 1] * y2 + grad3[gi2 + 2] * z2);","        }","        let t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;","        if (t3 < 0)","            n3 = 0.0;","        else {","            const gi3 = permMod12[ii + 1 + perm[jj + 1 + perm[kk + 1]]] * 3;","            t3 *= t3;","            n3 = t3 * t3 * (grad3[gi3] * x3 + grad3[gi3 + 1] * y3 + grad3[gi3 + 2] * z3);","        }","        // Add contributions from each corner to get the final noise value.","        // The result is scaled to stay just inside [-1,1]","        return 32.0 * (n0 + n1 + n2 + n3);","    }","","    /**","     * Samples the noise field in 4 dimensions","     * @param {number} x","     * @param {number} y","     * @param {number} z","     * @returns a number in the interval [-1, 1]","     */","    noise4D(x, y, z, w) {","        const perm = this.perm;","        let n0, n1, n2, n3, n4; // Noise contributions from the five corners","        // Skew the (x,y,z,w) space to determine which cell of 24 simplices we're in","        const s = (x + y + z + w) * F4; // Factor for 4D skewing","        const i = Math.floor(x + s);","        const j = Math.floor(y + s);","        const k = Math.floor(z + s);","        const l = Math.floor(w + s);","        const t = (i + j + k + l) * G4; // Factor for 4D unskewing","        const X0 = i - t; // Unskew the cell origin back to (x,y,z,w) space","        const Y0 = j - t;","        const Z0 = k - t;","        const W0 = l - t;","        const x0 = x - X0; // The x,y,z,w distances from the cell origin","        const y0 = y - Y0;","        const z0 = z - Z0;","        const w0 = w - W0;","        // For the 4D case, the simplex is a 4D shape I won't even try to describe.","        // To find out which of the 24 possible simplices we're in, we need to","        // determine the magnitude ordering of x0, y0, z0 and w0.","        // Six pair-wise comparisons are performed between each possible pair","        // of the four coordinates, and the results are used to rank the numbers.","        let rankx = 0;","        let ranky = 0;","        let rankz = 0;","        let rankw = 0;","        if (x0 > y0)","            rankx++;","        else","            ranky++;","        if (x0 > z0)","            rankx++;","        else","            rankz++;","        if (x0 > w0)","            rankx++;","        else","            rankw++;","        if (y0 > z0)","            ranky++;","        else","            rankz++;","        if (y0 > w0)","            ranky++;","        else","            rankw++;","        if (z0 > w0)","            rankz++;","        else","            rankw++;","        // simplex[c] is a 4-vector with the numbers 0, 1, 2 and 3 in some order.","        // Many values of c will never occur, since e.g. x>y>z>w makes x<z, y<w and x<w","        // impossible. Only the 24 indices which have non-zero entries make any sense.","        // We use a thresholding to set the coordinates in turn from the largest magnitude.","        // Rank 3 denotes the largest coordinate.","        // Rank 2 denotes the second largest coordinate.","        // Rank 1 denotes the second smallest coordinate.","        // The integer offsets for the second simplex corner","        const i1 = rankx >= 3 ? 1 : 0;","        const j1 = ranky >= 3 ? 1 : 0;","        const k1 = rankz >= 3 ? 1 : 0;","        const l1 = rankw >= 3 ? 1 : 0;","        // The integer offsets for the third simplex corner","        const i2 = rankx >= 2 ? 1 : 0;","        const j2 = ranky >= 2 ? 1 : 0;","        const k2 = rankz >= 2 ? 1 : 0;","        const l2 = rankw >= 2 ? 1 : 0;","        // The integer offsets for the fourth simplex corner","        const i3 = rankx >= 1 ? 1 : 0;","        const j3 = ranky >= 1 ? 1 : 0;","        const k3 = rankz >= 1 ? 1 : 0;","        const l3 = rankw >= 1 ? 1 : 0;","        // The fifth corner has all coordinate offsets = 1, so no need to compute that.","        const x1 = x0 - i1 + G4; // Offsets for second corner in (x,y,z,w) coords","        const y1 = y0 - j1 + G4;","        const z1 = z0 - k1 + G4;","        const w1 = w0 - l1 + G4;","        const x2 = x0 - i2 + 2.0 * G4; // Offsets for third corner in (x,y,z,w) coords","        const y2 = y0 - j2 + 2.0 * G4;","        const z2 = z0 - k2 + 2.0 * G4;","        const w2 = w0 - l2 + 2.0 * G4;","        const x3 = x0 - i3 + 3.0 * G4; // Offsets for fourth corner in (x,y,z,w) coords","        const y3 = y0 - j3 + 3.0 * G4;","        const z3 = z0 - k3 + 3.0 * G4;","        const w3 = w0 - l3 + 3.0 * G4;","        const x4 = x0 - 1.0 + 4.0 * G4; // Offsets for last corner in (x,y,z,w) coords","        const y4 = y0 - 1.0 + 4.0 * G4;","        const z4 = z0 - 1.0 + 4.0 * G4;","        const w4 = w0 - 1.0 + 4.0 * G4;","        // Work out the hashed gradient indices of the five simplex corners","        const ii = i & 255;","        const jj = j & 255;","        const kk = k & 255;","        const ll = l & 255;","        // Calculate the contribution from the five corners","        let t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0 - w0 * w0;","        if (t0 < 0)","            n0 = 0.0;","        else {","            const gi0 = (perm[ii + perm[jj + perm[kk + perm[ll]]]] % 32) * 4;","            t0 *= t0;","            n0 = t0 * t0 * (grad4[gi0] * x0 + grad4[gi0 + 1] * y0 + grad4[gi0 + 2] * z0 + grad4[gi0 + 3] * w0);","        }","        let t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1 - w1 * w1;","        if (t1 < 0)","            n1 = 0.0;","        else {","            const gi1 = (perm[ii + i1 + perm[jj + j1 + perm[kk + k1 + perm[ll + l1]]]] % 32) * 4;","            t1 *= t1;","            n1 = t1 * t1 * (grad4[gi1] * x1 + grad4[gi1 + 1] * y1 + grad4[gi1 + 2] * z1 + grad4[gi1 + 3] * w1);","        }","        let t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2 - w2 * w2;","        if (t2 < 0)","            n2 = 0.0;","        else {","            const gi2 = (perm[ii + i2 + perm[jj + j2 + perm[kk + k2 + perm[ll + l2]]]] % 32) * 4;","            t2 *= t2;","            n2 = t2 * t2 * (grad4[gi2] * x2 + grad4[gi2 + 1] * y2 + grad4[gi2 + 2] * z2 + grad4[gi2 + 3] * w2);","        }","        let t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3 - w3 * w3;","        if (t3 < 0)","            n3 = 0.0;","        else {","            const gi3 = (perm[ii + i3 + perm[jj + j3 + perm[kk + k3 + perm[ll + l3]]]] % 32) * 4;","            t3 *= t3;","            n3 = t3 * t3 * (grad4[gi3] * x3 + grad4[gi3 + 1] * y3 + grad4[gi3 + 2] * z3 + grad4[gi3 + 3] * w3);","        }","        let t4 = 0.6 - x4 * x4 - y4 * y4 - z4 * z4 - w4 * w4;","        if (t4 < 0)","            n4 = 0.0;","        else {","            const gi4 = (perm[ii + 1 + perm[jj + 1 + perm[kk + 1 + perm[ll + 1]]]] % 32) * 4;","            t4 *= t4;","            n4 = t4 * t4 * (grad4[gi4] * x4 + grad4[gi4 + 1] * y4 + grad4[gi4 + 2] * z4 + grad4[gi4 + 3] * w4);","        }","        // Sum up and scale the result to cover the range [-1,1]","        return 27.0 * (n0 + n1 + n2 + n3 + n4);","    };","}","","gdjs._cameraShake3DExtension = {","    noiseManager: new NoiseManager(),","};",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[],"objectGroups":[]},{"description":"Generate a number from 2 dimensional simplex noise.","fullName":"2D noise","functionType":"Expression","name":"Noise2d","private":true,"sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["const name = eventsFunctionContext.getArgument(\"Name\");\r","const x = eventsFunctionContext.getArgument(\"X\");\r","const y = eventsFunctionContext.getArgument(\"Y\");\r","\r","eventsFunctionContext.returnValue = gdjs._cameraShake3DExtension.noiseManager.getGenerator(name).noise(x, y);"],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"expressionType":{"type":"expression"},"parameters":[{"description":"Generator name","name":"Name","type":"string"},{"description":"X coordinate","name":"X","type":"expression"},{"description":"Y coordinate","name":"Y","type":"expression"}],"objectGroups":[]},{"description":"Generate a number from 3 dimensional simplex noise.","fullName":"3D noise","functionType":"Expression","name":"Noise3d","private":true,"sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["const name = eventsFunctionContext.getArgument(\"Name\");\r","const x = eventsFunctionContext.getArgument(\"X\");\r","const y = eventsFunctionContext.getArgument(\"Y\");\r","const z = eventsFunctionContext.getArgument(\"Z\");\r","\r","eventsFunctionContext.returnValue = gdjs._cameraShake3DExtension.noiseManager.getGenerator(name).noise(x, y, z);"],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"expressionType":{"type":"expression"},"parameters":[{"description":"Generator name","name":"Name","type":"string"},{"description":"X coordinate","name":"X","type":"expression"},{"description":"Y coordinate","name":"Y","type":"expression"},{"description":"Z coordinate","name":"Z","type":"expression"}],"objectGroups":[]},{"description":"Generate a number from 4 dimensional simplex noise.","fullName":"4D noise","functionType":"Expression","name":"Noise4d","private":true,"sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["const name = eventsFunctionContext.getArgument(\"Name\");\r","const x = eventsFunctionContext.getArgument(\"X\");\r","const y = eventsFunctionContext.getArgument(\"Y\");\r","const z = eventsFunctionContext.getArgument(\"Z\");\r","const w = eventsFunctionContext.getArgument(\"W\");\r","\r","eventsFunctionContext.returnValue = gdjs._cameraShake3DExtension.noiseManager.getGenerator(name).noise(x, y, z, w);"],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"expressionType":{"type":"expression"},"parameters":[{"description":"Generator name","name":"Name","type":"string"},{"description":"X coordinate","name":"X","type":"expression"},{"description":"Y coordinate","name":"Y","type":"expression"},{"description":"Z coordinate","name":"Z","type":"expression"},{"description":"W coordinate","name":"W","type":"expression"}],"objectGroups":[]},{"description":"Create a noise generator with default settings (frequency = 1,  octaves = 1, persistence = 0.5, lacunarity = 2).","fullName":"Create a noise generator","functionType":"Action","name":"Create","private":true,"sentence":"Create a noise generator named _PARAM1_","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["const name = eventsFunctionContext.getArgument(\"Name\");\r","\r","gdjs._cameraShake3DExtension.noiseManager.getGenerator(name);"],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":false}],"parameters":[{"description":"Generator name","name":"Name","type":"string"}],"objectGroups":[]},{"description":"Delete a noise generator and loose its settings.","fullName":"Delete a noise generator","functionType":"Action","name":"Delete","private":true,"sentence":"Delete _PARAM1_ noise generator","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["const name = eventsFunctionContext.getArgument(\"Name\");\r","\r","gdjs._cameraShake3DExtension.noiseManager.deleteGenerator(name);"],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":false}],"parameters":[{"description":"Generator name","name":"Name","type":"string"}],"objectGroups":[]},{"description":"Delete all noise generators and loose their settings.","fullName":"Delete all noise generators","functionType":"Action","name":"DeleteAll","private":true,"sentence":"Delete all noise generators","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":"gdjs._cameraShake3DExtension.noiseManager.deleteAllGenerators();","parameterObjects":"","useStrict":true,"eventsSheetExpanded":false}],"parameters":[],"objectGroups":[]},{"description":"The seed is a number used to generate the random noise. Setting the same seed will result in the same random noise generation. It's for example useful to generate the same world, by saving this seed value and reusing it later to generate again a world.","fullName":"Noise seed","functionType":"Action","name":"SetSeed","private":true,"sentence":"Change the noise seed to _PARAM1_","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":"gdjs._cameraShake3DExtension.noiseManager.setSeed(eventsFunctionContext.getArgument(\"Seed\"));","parameterObjects":"","useStrict":true,"eventsSheetExpanded":false}],"parameters":[{"description":"Seed","longDescription":"15 digits numbers maximum","name":"Seed","type":"expression"}],"objectGroups":[]},{"description":"Change the looping period on X used for noise generation. The noise will wrap-around on X.","fullName":"Noise looping period on X","functionType":"Action","name":"SetLoopPeriodX","private":true,"sentence":"Change the looping period on X of _PARAM2_: _PARAM1_","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["const name = eventsFunctionContext.getArgument(\"Name\");\r","\r","gdjs._cameraShake3DExtension.noiseManager.getGenerator(name).xLoopPeriod = eventsFunctionContext.getArgument(\"LoopPeriod\");"],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":false}],"parameters":[{"description":"Looping period on X","name":"LoopPeriod","type":"expression"},{"description":"Generator name","name":"Name","type":"string"}],"objectGroups":[]},{"description":"Change the looping period on Y used for noise generation. The noise will wrap-around on Y.","fullName":"Noise looping period on Y","functionType":"Action","name":"SetLoopPeriodY","private":true,"sentence":"Change the looping period on Y of _PARAM2_: _PARAM1_","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["const name = eventsFunctionContext.getArgument(\"Name\");\r","\r","gdjs._cameraShake3DExtension.noiseManager.getGenerator(name).yLoopPeriod = eventsFunctionContext.getArgument(\"LoopPeriod\");"],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"Looping period on Y","name":"LoopPeriod","type":"expression"},{"description":"Generator name","name":"Name","type":"string"}],"objectGroups":[]},{"description":"Change the base frequency used for noise generation. A lower frequency will zoom in the noise.","fullName":"Noise base frequency","functionType":"Action","name":"SetFrequency","private":true,"sentence":"Change the noise frequency of _PARAM2_: _PARAM1_","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["const name = eventsFunctionContext.getArgument(\"Name\");\r","\r","gdjs._cameraShake3DExtension.noiseManager.getGenerator(name).frequency = eventsFunctionContext.getArgument(\"Frequency\");"],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":false}],"parameters":[{"description":"Frequency","name":"Frequency","type":"expression"},{"description":"Generator name","name":"Name","type":"string"}],"objectGroups":[]},{"description":"Change the number of octaves used for noise generation. It can be seen as layers of noise with different zoom.","fullName":"Noise octaves","functionType":"Action","name":"SetOctaves","private":true,"sentence":"Change the number of noise octaves of _PARAM2_: _PARAM1_","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["const name = eventsFunctionContext.getArgument(\"Name\");\r","\r","gdjs._cameraShake3DExtension.noiseManager.getGenerator(name).octaves = eventsFunctionContext.getArgument(\"Octaves\");"],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":false}],"parameters":[{"description":"Octaves","name":"Octaves","type":"expression"},{"description":"Generator name","name":"Name","type":"string"}],"objectGroups":[]},{"description":"Change the persistence used for noise generation. At its default value \"0.5\", it halves the noise amplitude at each octave.","fullName":"Noise persistence","functionType":"Action","name":"SetPersistence","private":true,"sentence":"Change the noise persistence of _PARAM2_: _PARAM1_","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["const name = eventsFunctionContext.getArgument(\"Name\");\r","\r","gdjs._cameraShake3DExtension.noiseManager.getGenerator(name).persistence = eventsFunctionContext.getArgument(\"Persistence\");"],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":false}],"parameters":[{"description":"Persistence","name":"Persistence","type":"expression"},{"description":"Generator name","name":"Name","type":"string"}],"objectGroups":[]},{"description":"Change the lacunarity used for noise generation. At its default value \"2\", it doubles the frequency at each octave.","fullName":"Noise lacunarity","functionType":"Action","name":"SetLacunarity","private":true,"sentence":"Change the noise lacunarity of _PARAM2_: _PARAM1_","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["const name = eventsFunctionContext.getArgument(\"Name\");\r","\r","gdjs._cameraShake3DExtension.noiseManager.getGenerator(name).lacunarity = eventsFunctionContext.getArgument(\"Lacunarity\");"],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":false}],"parameters":[{"description":"Lacunarity","name":"Lacunarity","type":"expression"},{"description":"Generator name","name":"Name","type":"string"}],"objectGroups":[]},{"description":"The seed used for noise generation.","fullName":"Noise seed","functionType":"Expression","name":"Seed","private":true,"sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":"eventsFunctionContext.returnValue = gdjs._cameraShake3DExtension.noiseManager.seed;","parameterObjects":"","useStrict":true,"eventsSheetExpanded":false}],"expressionType":{"type":"expression"},"parameters":[],"objectGroups":[]},{"description":"The base frequency used for noise generation.","fullName":"Noise base frequency","functionType":"Expression","name":"Frequency","private":true,"sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["const name = eventsFunctionContext.getArgument(\"Name\");\r","\r","eventsFunctionContext.returnValue = gdjs._cameraShake3DExtension.noiseManager.getGenerator(name).frequency;"],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":false}],"expressionType":{"type":"expression"},"parameters":[{"description":"Generator name","name":"Name","type":"string"}],"objectGroups":[]},{"description":"The number of octaves used for noise generation.","fullName":"Noise octaves number","functionType":"Expression","name":"Octaves","private":true,"sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["const name = eventsFunctionContext.getArgument(\"Name\");\r","\r","eventsFunctionContext.returnValue = gdjs._cameraShake3DExtension.noiseManager.getGenerator(name).octaves;"],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":false}],"expressionType":{"type":"expression"},"parameters":[{"description":"Generator name","name":"Name","type":"string"}],"objectGroups":[]},{"description":"The persistence used for noise generation.","fullName":"Noise persistence","functionType":"Expression","name":"Persistence","private":true,"sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["const name = eventsFunctionContext.getArgument(\"Name\");\r","\r","eventsFunctionContext.returnValue = gdjs._cameraShake3DExtension.noiseManager.getGenerator(name).persistence;"],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":false}],"expressionType":{"type":"expression"},"parameters":[{"description":"Generator name","name":"Name","type":"string"}],"objectGroups":[]},{"description":"The lacunarity used for noise generation.","fullName":"Noise lacunarity","functionType":"Expression","name":"Lacunarity","private":true,"sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["const name = eventsFunctionContext.getArgument(\"Name\");\r","\r","eventsFunctionContext.returnValue = gdjs._cameraShake3DExtension.noiseManager.getGenerator(name).lacunarity;"],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":false}],"expressionType":{"type":"expression"},"parameters":[{"description":"Generator name","name":"Name","type":"string"}],"objectGroups":[]}],"eventsBasedBehaviors":[],"eventsBasedObjects":[]},{"author":"","category":"Camera","extensionNamespace":"","fullName":"First person 3D camera","gdevelopVersion":">=5.5.222","helpPath":"","iconUrl":"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAyMy4wLjMsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT4NCjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iSWNvbnMiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4Ig0KCSB2aWV3Qm94PSIwIDAgMzIgMzIiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDMyIDMyOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+DQo8c3R5bGUgdHlwZT0idGV4dC9jc3MiPg0KCS5zdDB7ZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyO3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDoxMDt9DQoJLnN0MXtmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjI7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjEwO30NCjwvc3R5bGU+DQo8cGF0aCBjbGFzcz0ic3QwIiBkPSJNMjcsMTZjMCwwLTQuOSw3LTExLDdTNSwxNiw1LDE2czQuOS03LDExLTdTMjcsMTYsMjcsMTZ6Ii8+DQo8Y2lyY2xlIGNsYXNzPSJzdDAiIGN4PSIxNiIgY3k9IjE2IiByPSIzIi8+DQo8cG9seWxpbmUgY2xhc3M9InN0MCIgcG9pbnRzPSIzLDkgMywzIDksMyAiLz4NCjxwb2x5bGluZSBjbGFzcz0ic3QwIiBwb2ludHM9IjksMjkgMywyOSAzLDIzICIvPg0KPHBvbHlsaW5lIGNsYXNzPSJzdDAiIHBvaW50cz0iMjksMjMgMjksMjkgMjMsMjkgIi8+DQo8cG9seWxpbmUgY2xhc3M9InN0MCIgcG9pbnRzPSIyMywzIDI5LDMgMjksOSAiLz4NCjwvc3ZnPg0K","name":"FirstPersonCamera","previewIconUrl":"https://asset-resources.gdevelop.io/public-resources/Icons/Line Hero Pack/Master/SVG/Security and Protection/e8248ffd504c314e6a9d9d560c3a0fdad3398a5f125ae6a4c0654d4e68c86376_Security and Protection_security_protection_eye_scan_lock.svg","shortDescription":"Move the camera to look though objects eyes.","version":"1.0.4","description":["Move the camera to look though objects eyes.","","This extension can be used with the \"Mouse pointer lock\" or \"Gamepad\" extension to build a first person camera.","","The first person example uses this extension ([open the project online](https://editor.gdevelop.io/?project=example://3d-first-person))."],"origin":{"identifier":"FirstPersonCamera","name":"gdevelop-extension-store"},"tags":["3d","camera","fps"],"authorIds":["IWykYNRvhCZBN3vEgKEbBPOR3Oc2","m8kleQHonagHWsvILDhyJhgVhuF2"],"dependencies":[],"globalVariables":[],"sceneVariables":[],"eventsFunctions":[{"description":"Move the camera to look though the object eyes. The object must look to the right when all its angles are 0 and the top of its head be toward Z+.","fullName":"Look through object eyes","functionType":"Action","group":"Layers and cameras","name":"LookFromObjectEyes","private":true,"sentence":"Move the camera of _PARAM2_ to look though _PARAM1_ eyes","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"CentreCamera"},"parameters":["","Object","","Layer",""]},{"type":{"value":"Scene3D::SetCameraZ"},"parameters":["","=","Object.Z()","Layer",""]},{"type":{"value":"Scene3D::SetCameraRotationX"},"parameters":["","=","- Object.RotationY() + 90","Layer",""]},{"type":{"value":"Scene3D::SetCameraRotationY"},"parameters":["","=","Object.RotationX()","Layer",""]},{"type":{"value":"SetCameraAngle"},"parameters":["","=","Object.Angle() + 90","Layer",""]}]}],"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"Scene3D::Cube3DObject","type":"objectList"},{"description":"Layer","name":"Layer","type":"layer"}],"objectGroups":[]},{"description":"Move the camera to look though the object eyes. The object must look to the right when all its angles are 0 and the top of its head be toward Z+.","fullName":"Look through object eyes","functionType":"Action","group":"Layers and cameras","name":"LookFrom3DObjectEyes","sentence":"Move the camera of _PARAM3_ to look though _PARAM1_ eyes","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"CentreCamera"},"parameters":["","Object","","Layer",""]},{"type":{"value":"Scene3D::SetCameraZ"},"parameters":["","=","Object.Object3D::Z()","Layer",""]},{"type":{"value":"Scene3D::SetCameraRotationX"},"parameters":["","=","- Object.Object3D::RotationY() + 90","Layer",""]},{"type":{"value":"Scene3D::SetCameraRotationY"},"parameters":["","=","Object.Object3D::RotationX()","Layer",""]},{"type":{"value":"SetCameraAngle"},"parameters":["","=","Object.Angle() + 90","Layer",""]}]}],"parameters":[{"description":"3D Object","name":"Object","type":"objectList"},{"description":"3D capability","name":"Object3D","supplementaryInformation":"Scene3D::Base3DBehavior","type":"behavior"},{"description":"Layer","name":"Layer","type":"layer"}],"objectGroups":[]}],"eventsBasedBehaviors":[],"eventsBasedObjects":[]},{"author":"Bouh","category":"Input","extensionNamespace":"","fullName":"Gamepads (controllers)","gdevelopVersion":">=5.5.222","helpPath":"/all-features/gamepad","iconUrl":"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0ibWRpLWdhbWVwYWQtdmFyaWFudC1vdXRsaW5lIiB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggZD0iTTYsOUg4VjExSDEwVjEzSDhWMTVINlYxM0g0VjExSDZWOU0xOC41LDlBMS41LDEuNSAwIDAsMSAyMCwxMC41QTEuNSwxLjUgMCAwLDEgMTguNSwxMkExLjUsMS41IDAgMCwxIDE3LDEwLjVBMS41LDEuNSAwIDAsMSAxOC41LDlNMTUuNSwxMkExLjUsMS41IDAgMCwxIDE3LDEzLjVBMS41LDEuNSAwIDAsMSAxNS41LDE1QTEuNSwxLjUgMCAwLDEgMTQsMTMuNUExLjUsMS41IDAgMCwxIDE1LjUsMTJNMTcsNUE3LDcgMCAwLDEgMjQsMTJBNyw3IDAgMCwxIDE3LDE5QzE1LjA0LDE5IDEzLjI3LDE4LjIgMTIsMTYuOUMxMC43MywxOC4yIDguOTYsMTkgNywxOUE3LDcgMCAwLDEgMCwxMkE3LDcgMCAwLDEgNyw1SDE3TTcsN0E1LDUgMCAwLDAgMiwxMkE1LDUgMCAwLDAgNywxN0M4LjY0LDE3IDEwLjA5LDE2LjIxIDExLDE1SDEzQzEzLjkxLDE2LjIxIDE1LjM2LDE3IDE3LDE3QTUsNSAwIDAsMCAyMiwxMkE1LDUgMCAwLDAgMTcsN0g3WiIgLz48L3N2Zz4=","name":"Gamepads","previewIconUrl":"https://resources.gdevelop-app.com/assets/Icons/gamepad-variant-outline.svg","shortDescription":"Add support for gamepads (or other controllers) to your game, giving access to information such as button presses, axis positions, trigger pressure, etc...","version":"0.7.0","description":["Add support for gamepads (or other controllers).","","It gives access to:","- button presses","- axis positions and force","- trigger pressure","- configurable deadzone","- vibration","- automatic mappers for platformer characters and top-down movement","","The Bomberman-like example handles 4 players with gamepads ([open the project online](https://editor.gdevelop.io/?project=example://goose-bomberman))."],"origin":{"identifier":"Gamepads","name":"gdevelop-extension-store"},"tags":["controllers","gamepads","joysticks","axis","xbox","ps4","platformer","platform","top-down"],"authorIds":["2OwwM8ToR9dx9RJ2sAKTcrLmCB92","taRwmWxwAFYFL9yyBwB3cwBw0BO2","mnImQKdn8nQxwzkS5D6a1JB27V23"],"dependencies":[],"globalVariables":[],"sceneVariables":[],"eventsFunctions":[{"fullName":"","functionType":"Action","name":"onFirstSceneLoaded","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[]},{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["//Define an new private object javascript for the gamepad extension\r","gdjs._extensionController = {\r","    players: {\r","        0: { mapping: 'DEFAULT', lastButtonUsed: -1, deadzone: 0.2, previousFrameStateButtons: {}, rumble: {} },\r","        1: { mapping: 'DEFAULT', lastButtonUsed: -1, deadzone: 0.2, previousFrameStateButtons: {}, rumble: {} },\r","        2: { mapping: 'DEFAULT', lastButtonUsed: -1, deadzone: 0.2, previousFrameStateButtons: {}, rumble: {} },\r","        3: { mapping: 'DEFAULT', lastButtonUsed: -1, deadzone: 0.2, previousFrameStateButtons: {}, rumble: {} },\r","    },\r","    lastActiveController: -1, // Last active controller\r","    controllerButtonNames: { //Map associating controller button ids to button names\r","        \"XBOX\": {\r","            0: \"A\",\r","            1: \"B\",\r","            2: \"X\",\r","            3: \"Y\",\r","            4: \"LB\",\r","            5: \"RB\",\r","            6: \"LT\",\r","            7: \"RT\",\r","            8: \"BACK\",\r","            9: \"START\",\r","            10: \"CLICK_STICK_LEFT\",\r","            11: \"CLICK_STICK_RIGHT\",\r","            12: \"UP\",\r","            13: \"DOWN\",\r","            14: \"LEFT\",\r","            15: \"RIGHT\",\r","            16: \"NONE\",\r","            17: \"NONE\"\r","        },\r","        \"PS4\": {\r","            0: \"CROSS\",\r","            1: \"CIRCLE\",\r","            2: \"SQUARE\",\r","            3: \"TRIANGLE\",\r","            4: \"L1\",\r","            5: \"R1\",\r","            6: \"L2\",\r","            7: \"R2\",\r","            8: \"SHARE\",\r","            9: \"OPTIONS\",\r","            10: \"CLICK_STICK_LEFT\",\r","            11: \"CLICK_STICK_RIGHT\",\r","            12: \"UP\",\r","            13: \"DOWN\",\r","            14: \"LEFT\",\r","            15: \"RIGHT\",\r","            16: \"PS_BUTTON\",\r","            17: \"CLICK_TOUCHPAD\"\r","        }\r","    }\r","};\r","\r","gdjs._extensionController.getInputString = function (type, buttonId) {\r","    const controllerButtonNames = gdjs._extensionController.controllerButtonNames;\r","    if (controllerButtonNames[type] !== undefined) {\r","        return controllerButtonNames[type][buttonId];\r","    }\r","\r","    return \"UNKNOWN_BUTTON\";\r","}\r","\r","gdjs._extensionController.axisToAngle = function (deltaX, deltaY) {\r","    const rad = Math.atan2(deltaY, deltaX);\r","    const deg = rad * (180 / Math.PI);\r","    return deg;\r","}\r","\r","gdjs._extensionController.isXbox = function (gamepad) {\r","    return (gamepad ? (\r","        gamepad.id.toUpperCase().indexOf(\"XBOX\") !== -1\r","        // \"XINPUT\" cannot be used to check if it is a xbox controller is just a generic\r","        // name reported in Firefox corresponding to the driver being used by the controller\r","        // https://gamefaqs.gamespot.com/boards/916373-pc/73341312?page=1\r","    ) : false);\r","}\r","\r","//Returns the new value taking into account the dead zone for the player_ID given\r","gdjs._extensionController.getNormalizedAxisValue = function (v, player_ID) {\r","    //    gdjs._extensionController = gdjs._extensionController || { deadzone: 0.2 };\r","\r","    // Anything smaller than this is assumed to be 0,0\r","    const DEADZONE = gdjs._extensionController.players[player_ID].deadzone;\r","\r","    if (Math.abs(v) < DEADZONE) {\r","        // In the dead zone, set to 0\r","        v = 0;\r","\r","        if (v == null) {\r","            return 0;\r","        } else {\r","            return v;\r","        }\r","\r","    } else {\r","        // We're outside the dead zone, but we'd like to smooth\r","        // this value out so it still runs nicely between 0..1.\r","        // That is, we don't want it to jump suddenly from 0 to\r","        // DEADZONE.\r","\r","        // Remap v from\r","        //    DEADZONE..1 to 0..(1-DEADZONE)\r","        // or from\r","        //    -1..-DEADZONE to -(1-DEADZONE)..0\r","\r","        v = v - Math.sign(v) * DEADZONE;\r","\r","        // Remap v from\r","        //    0..(1-DEADZONE) to 0..1\r","        // or from\r","        //    -(1-DEADZONE)..0 to -1..0\r","\r","        return v / (1 - DEADZONE);\r","    }\r","};"],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[],"objectGroups":[]},{"fullName":"","functionType":"Action","name":"onScenePostEvents","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[]},{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["//Each time a player press a button i save the last button pressed for the next frame","/** @type {Gamepad[]} */","const gamepads = navigator.getGamepads ? navigator.getGamepads() : (navigator.webkitGetGamepads ? navigator.webkitGetGamepads() : []);","","//Get function parameter","let countPlayers = Object.keys(gdjs._extensionController.players).length;","","//Repeat for each players","for (let i = 0; i < countPlayers; i++) {","    let gamepad = gamepads[i]; // Get the gamepad of the player","","    //We have to keep this condition because if the user hasn't plugged in his controller yet, we can't get the controller in the gamepad variable.","    if (gamepad == null) {","        continue;","    }","","    for (let b = 0; b < Object.keys(gamepad.buttons).length; b++) { //For each buttons","        if (gamepad.buttons[b].pressed) { //One of them is pressed","            gdjs._extensionController.players[i].lastButtonUsed = b; //Save the button pressed","","            //Save the state of the button for the next frame.","            gdjs._extensionController.players[i].previousFrameStateButtons[b] = { pressed: true };","","            // Update Last Active Controller","            gdjs._extensionController.lastActiveController = i;","        } else {","            gdjs._extensionController.players[i].previousFrameStateButtons[b] = { pressed: false };","        }","    }","","","    gdjs._extensionController.players[i].rumble.elapsedTime += runtimeScene.getElapsedTime(runtimeScene) / 1000;","    if (","        gdjs._extensionController.players[i].rumble.duration - gdjs._extensionController.players[i].rumble.elapsedTime <= 0 &&","        (gdjs._extensionController.players[i].rumble.weakMagnitude || gdjs._extensionController.players[i].rumble.strongMagnitude)","    ) {","        gdjs._extensionController.players[i].rumble.weakMagnitude = 0;","        gdjs._extensionController.players[i].rumble.strongMagnitude = 0;","    }","","","}",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[],"objectGroups":[]},{"fullName":"Accelerated speed","functionType":"Expression","name":"AcceleratedSpeed","private":true,"sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetNumberVariable"},"parameters":["AcceleratedSpeed","=","CurrentSpeed"]}],"events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"NumberVariable"},"parameters":["TargetedSpeed","<","0"]}],"actions":[],"events":[{"type":"BuiltinCommonInstructions::Comment","color":{"b":109,"g":230,"r":255,"textB":0,"textG":0,"textR":0},"comment":"Reduce the speed to match the stick force."},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"NumberVariable"},"parameters":["CurrentSpeed","<","TargetedSpeed"]}],"actions":[{"type":{"value":"SetNumberVariable"},"parameters":["AcceleratedSpeed","=","min(TargetedSpeed, CurrentSpeed + Acceleration * TimeDelta())"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"NumberVariable"},"parameters":["CurrentSpeed",">","TargetedSpeed"]},{"type":{"value":"NumberVariable"},"parameters":["CurrentSpeed","<","0"]}],"actions":[{"type":{"value":"SetNumberVariable"},"parameters":["AcceleratedSpeed","-","Acceleration * TimeDelta()"]}]},{"type":"BuiltinCommonInstructions::Comment","color":{"b":109,"g":230,"r":255,"textB":0,"textG":0,"textR":0},"comment":"Turn back at least as fast as it would stop."},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"NumberVariable"},"parameters":["CurrentSpeed",">=","0"]}],"actions":[{"type":{"value":"SetNumberVariable"},"parameters":["AcceleratedSpeed","=","max(TargetedSpeed, CurrentSpeed - max(Acceleration , Deceleration) * TimeDelta())"]}]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"NumberVariable"},"parameters":["TargetedSpeed",">","0"]}],"actions":[],"events":[{"type":"BuiltinCommonInstructions::Comment","color":{"b":109,"g":230,"r":255,"textB":0,"textG":0,"textR":0},"comment":"Reduce the speed to match the stick force."},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"NumberVariable"},"parameters":["CurrentSpeed",">","TargetedSpeed"]}],"actions":[{"type":{"value":"SetNumberVariable"},"parameters":["AcceleratedSpeed","=","max(TargetedSpeed, CurrentSpeed - Acceleration * TimeDelta())"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"NumberVariable"},"parameters":["CurrentSpeed","<","TargetedSpeed"]},{"type":{"value":"NumberVariable"},"parameters":["CurrentSpeed",">","0"]}],"actions":[{"type":{"value":"SetNumberVariable"},"parameters":["AcceleratedSpeed","+","Acceleration * TimeDelta()"]}]},{"type":"BuiltinCommonInstructions::Comment","color":{"b":109,"g":230,"r":255,"textB":0,"textG":0,"textR":0},"comment":"Turn back at least as fast as it would stop."},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"NumberVariable"},"parameters":["CurrentSpeed","<=","0"]}],"actions":[{"type":{"value":"SetNumberVariable"},"parameters":["AcceleratedSpeed","=","min(TargetedSpeed, CurrentSpeed + max(Acceleration , Deceleration) * TimeDelta())"]}]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"NumberVariable"},"parameters":["TargetedSpeed","=","0"]}],"actions":[],"events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"NumberVariable"},"parameters":["CurrentSpeed","<","0"]}],"actions":[{"type":{"value":"SetNumberVariable"},"parameters":["AcceleratedSpeed","=","min(0, CurrentSpeed + Acceleration * TimeDelta())"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"NumberVariable"},"parameters":["CurrentSpeed",">","0"]}],"actions":[{"type":{"value":"SetNumberVariable"},"parameters":["AcceleratedSpeed","=","max(0, CurrentSpeed - Acceleration * TimeDelta())"]}]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["clamp(AcceleratedSpeed, -SpeedMax, SpeedMax)"]}]}],"variables":[{"name":"AcceleratedSpeed","type":"number","value":0.0}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Current speed","name":"CurrentSpeed","type":"expression"},{"description":"Targeted speed","name":"TargetedSpeed","type":"expression"},{"description":"Max speed","name":"SpeedMax","type":"expression"},{"description":"Acceleration","name":"Acceleration","type":"expression"},{"description":"Deceleration","name":"Deceleration","type":"expression"}],"objectGroups":[]},{"description":"Get the value of the pressure on a gamepad trigger.","fullName":"Pressure on a gamepad trigger","functionType":"Expression","name":"TriggerPressure","sentence":"Player _PARAM1_ push axis _PARAM2_ to _PARAM3_","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["/** @type {Gamepad[]} */\r","const gamepads = navigator.getGamepads ? navigator.getGamepads() : (navigator.webkitGetGamepads ? navigator.webkitGetGamepads() : []);\r","\r","//Get function parameters\r","const playerId = eventsFunctionContext.getArgument(\"player_ID\") - 1;\r","const trigger = eventsFunctionContext.getArgument(\"trigger\").toUpperCase();\r","\r","if (playerId < 0 || playerId > 4) {\r","    console.error('Parameter gamepad identifier in expression: \"Pressure on a gamepad trigger\", is not valid number, must be between 0 and 4.');\r","    return;\r","}\r","if (trigger != \"LT\" && trigger != \"RT\" && trigger != \"L2\" && trigger != \"R2\") {\r","    console.error('Parameter trigger is not valid in expression: \"Pressure on a gamepad trigger\"');\r","    return;\r","}\r","\r","const gamepad = gamepads[playerId];\r","\r","//we need keep this condition because when use have not yet plug her controller we can't get the controller in the gamepad variable.\r","if (gamepad == null) return;\r","\r","switch (trigger) {\r","    case 'LT':\r","    case 'L2':\r","        eventsFunctionContext.returnValue = gamepad.buttons[6].value;\r","        break;\r","\r","    case 'RT':\r","    case 'R2':\r","        eventsFunctionContext.returnValue = gamepad.buttons[7].value;\r","        break;\r","\r","    default:\r","        eventsFunctionContext.returnValue = -1;\r","        break;\r","}"],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"expressionType":{"type":"expression"},"parameters":[{"description":"The gamepad identifier: 1, 2, 3 or 4","name":"player_ID","type":"expression"},{"description":"Trigger button","name":"trigger","supplementaryInformation":"[\"LT\",\"RT\",\"L2\",\"R2\"]","type":"stringWithSelector"}],"objectGroups":[]},{"description":"the force of gamepad stick (from 0 to 1).","fullName":"Stick force","functionType":"ExpressionAndCondition","name":"StickForce","sentence":"the gamepad _PARAM1_ _PARAM2_ stick force","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["/** @type {Gamepad[]} */\r","const gamepads = navigator.getGamepads ? navigator.getGamepads() : (navigator.webkitGetGamepads ? navigator.webkitGetGamepads() : []);\r","\r","//Get function parameters\r","const playerId = eventsFunctionContext.getArgument(\"player_ID\") - 1;\r","const stick = eventsFunctionContext.getArgument(\"stick\").toUpperCase();\r","\r","\r","if (playerId < 0 || playerId > 4) {\r","    console.error('Parameter gamepad identifier is not valid in expression: \"Value of a stick force\"');\r","    return;\r","}\r","\r","if (stick !== \"LEFT\" && stick !== \"RIGHT\") {\r","    console.error('Parameter stick is not valid in expression: \"Value of a stick force\"');\r","    return;\r","}\r","\r","const gamepad = gamepads[playerId];\r","\r","//we need keep this condition because when use have not yet plug her controller we can't get the controller in the gamepad variable.\r","if (gamepad == null) return;\r","\r","\r","switch (stick) {\r","    case 'LEFT':\r","        eventsFunctionContext.returnValue = gdjs.evtTools.common.clamp(Math.abs(gdjs._extensionController.getNormalizedAxisValue(gamepad.axes[0], playerId)) + Math.abs(gdjs._extensionController.getNormalizedAxisValue(gamepad.axes[1], playerId)), 0, 1);\r","        break;\r","\r","    case 'RIGHT':\r","        eventsFunctionContext.returnValue = gdjs.evtTools.common.clamp(Math.abs(gdjs._extensionController.getNormalizedAxisValue(gamepad.axes[2], playerId)) + Math.abs(gdjs._extensionController.getNormalizedAxisValue(gamepad.axes[3], playerId)), 0, 1);\r","        break;\r","\r","    default:\r","        eventsFunctionContext.returnValue = -1;\r","        break;\r","}"],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"expressionType":{"type":"expression"},"parameters":[{"description":"The gamepad identifier: 1, 2, 3 or 4","name":"player_ID","type":"expression"},{"description":"Stick: \"Left\" or \"Right\"","name":"stick","supplementaryInformation":"[\"Left\",\"Right\"]","type":"stringWithSelector"}],"objectGroups":[]},{"description":"Get the rotation value of a gamepad stick.\nIf the deadzone value is high, the angle value is rounded to main axes, left, left, up, down.\nAn zero deadzone value give a total freedom on the angle value.","fullName":"Value of a stick rotation (deprecated)","functionType":"Expression","name":"StickRotationValue","private":true,"sentence":"Player _PARAM1_ push axis _PARAM2_ to _PARAM3_","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["Gamepads::StickAngle(player_ID, stick)"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"The gamepad identifier: 1, 2, 3 or 4","name":"player_ID","type":"expression"},{"description":"Stick: \"Left\" or \"Right\"","name":"stick","supplementaryInformation":"[\"Left\",\"Right\"]","type":"stringWithSelector"}],"objectGroups":[]},{"description":"Return the angle of a gamepad stick.\nIf the deadzone value is high, the angle value is rounded to main axes, left, left, up, down.\nAn zero deadzone value give a total freedom on the angle value.","fullName":"Stick angle","functionType":"Expression","name":"StickAngle","sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["/** @type {Gamepad[]} */\r","const gamepads = navigator.getGamepads ? navigator.getGamepads() : (navigator.webkitGetGamepads ? navigator.webkitGetGamepads() : []);\r","\r","//Get function parameters\r","const playerId = eventsFunctionContext.getArgument(\"player_ID\") - 1;\r","const stick = eventsFunctionContext.getArgument(\"stick\").toUpperCase();\r","\r","\r","if (playerId < 0 || playerId > 4) {\r","    console.error('Parameter gamepad identifier is not valid in expression: \"Value of a stick rotation\"');\r","    return;\r","}\r","if (stick !== \"LEFT\" && stick !== \"RIGHT\") {\r","    console.error('Parameter stick is not valid in expression: \"Value of a stick rotation\"');\r","    return;\r","}\r","const gamepad = gamepads[playerId];\r","\r","//we need keep this condition because when use have not yet plug her controller we can't get the controller in the gamepad variable.\r","if (gamepad == null) return;\r","\r","switch (stick) {\r","    case 'LEFT':\r","        eventsFunctionContext.returnValue = gdjs._extensionController.axisToAngle(gdjs._extensionController.getNormalizedAxisValue(gamepad.axes[0], playerId), gdjs._extensionController.getNormalizedAxisValue(gamepad.axes[1], playerId));\r","        break;\r","\r","    case 'RIGHT':\r","        eventsFunctionContext.returnValue = gdjs._extensionController.axisToAngle(gdjs._extensionController.getNormalizedAxisValue(gamepad.axes[2], playerId), gdjs._extensionController.getNormalizedAxisValue(gamepad.axes[3], playerId));\r","        break;\r","\r","    default:\r","        eventsFunctionContext.returnValue = -1;\r","        break;\r","}"],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"expressionType":{"type":"expression"},"parameters":[{"description":"The gamepad identifier: 1, 2, 3 or 4","name":"player_ID","type":"expression"},{"description":"Stick: \"Left\" or \"Right\"","name":"stick","supplementaryInformation":"[\"Left\",\"Right\"]","type":"stringWithSelector"}],"objectGroups":[]},{"description":"Get the value of axis of a gamepad stick.","fullName":"Value of a gamepad axis (deprecated)","functionType":"Expression","name":"AxisValue","private":true,"sentence":"Player _PARAM1_ push axis _PARAM2_ to _PARAM3_","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["/** @type {Gamepad[]} */\r","const gamepads = navigator.getGamepads ? navigator.getGamepads() : (navigator.webkitGetGamepads ? navigator.webkitGetGamepads() : []);\r","\r","//Get function parameters\r","const playerId = eventsFunctionContext.getArgument(\"player_ID\") - 1;\r","const stick = eventsFunctionContext.getArgument(\"stick\").toUpperCase();\r","const direction = eventsFunctionContext.getArgument(\"direction\").toUpperCase();\r","\r","if (playerId < 0 || playerId > 4) {\r","    console.error('Parameter gamepad identifier is not valid in expression: \"Value of a gamepad axis\"');\r","    return;\r","}\r","if (stick != \"LEFT\" && stick != \"RIGHT\") {\r","    console.error('Parameter stick is not valid in expression: \"Value of a gamepad axis\"');\r","    return;\r","}\r","if (direction != \"UP\" && direction != \"DOWN\" && direction != \"LEFT\" && direction != \"RIGHT\" && direction != \"HORIZONTAL\" && direction != \"VERTICAL\") {\r","    console.error('Parameter direction is not valid in expression: \"Value of a gamepad axis\"');\r","    return;\r","}\r","const gamepad = gamepads[playerId];\r","\r","//we need keep this condition because when use have not yet plug her controller we can't get the controller in the gamepad variable.\r","if (gamepad == null) return;\r","\r","let parameterError = false;\r","switch (stick) {\r","    case 'LEFT':\r","        switch (direction) {\r","            case 'LEFT':\r","                if (gdjs._extensionController.getNormalizedAxisValue(gamepad.axes[0], playerId) < 0) {\r","                    eventsFunctionContext.returnValue = -gdjs._extensionController.getNormalizedAxisValue(gamepad.axes[0], playerId);\r","                }\r","                break;\r","\r","            case 'RIGHT':\r","                if (gdjs._extensionController.getNormalizedAxisValue(gamepad.axes[0], playerId) > 0) {\r","                    eventsFunctionContext.returnValue = gdjs._extensionController.getNormalizedAxisValue(gamepad.axes[0], playerId);\r","                }\r","                break;\r","\r","            case 'UP':\r","                if (gdjs._extensionController.getNormalizedAxisValue(gamepad.axes[1], playerId) < 0) {\r","                    eventsFunctionContext.returnValue = -gdjs._extensionController.getNormalizedAxisValue(gamepad.axes[1], playerId);\r","                }\r","                break;\r","\r","            case 'DOWN':\r","                if (gdjs._extensionController.getNormalizedAxisValue(gamepad.axes[1], playerId) > 0) {\r","                    eventsFunctionContext.returnValue = gdjs._extensionController.getNormalizedAxisValue(gamepad.axes[1], playerId);\r","                }\r","                break;\r","\r","            case \"HORIZONTAL\":\r","                eventsFunctionContext.returnValue = gdjs._extensionController.getNormalizedAxisValue(gamepad.axes[0], playerId);\r","                break;\r","\r","            case \"VERTICAL\":\r","                eventsFunctionContext.returnValue = gdjs._extensionController.getNormalizedAxisValue(gamepad.axes[1], playerId);\r","                break;\r","\r","            default:\r","                break;\r","        }\r","        break;\r","\r","    case 'RIGHT':\r","        switch (direction) {\r","            case 'LEFT':\r","                if (gdjs._extensionController.getNormalizedAxisValue(gamepad.axes[2], playerId) < 0) {\r","                    eventsFunctionContext.returnValue = -gdjs._extensionController.getNormalizedAxisValue(gamepad.axes[2], playerId);\r","                }\r","                break;\r","\r","            case 'RIGHT':\r","                if (gdjs._extensionController.getNormalizedAxisValue(gamepad.axes[2], playerId) > 0) {\r","                    eventsFunctionContext.returnValue = gdjs._extensionController.getNormalizedAxisValue(gamepad.axes[2], playerId);\r","                }\r","                break;\r","\r","            case 'UP':\r","                if (gdjs._extensionController.getNormalizedAxisValue(gamepad.axes[3], playerId) < 0) {\r","                    eventsFunctionContext.returnValue = -gdjs._extensionController.getNormalizedAxisValue(gamepad.axes[3], playerId);\r","                }\r","                break;\r","\r","            case 'DOWN':\r","                if (gdjs._extensionController.getNormalizedAxisValue(gamepad.axes[3], playerId) > 0) {\r","                    eventsFunctionContext.returnValue = gdjs._extensionController.getNormalizedAxisValue(gamepad.axes[3], playerId);\r","                }\r","                break;\r","\r","            case \"HORIZONTAL\":\r","                eventsFunctionContext.returnValue = gdjs._extensionController.getNormalizedAxisValue(gamepad.axes[2], playerId);\r","                break;\r","\r","            case \"VERTICAL\":\r","                eventsFunctionContext.returnValue = gdjs._extensionController.getNormalizedAxisValue(gamepad.axes[3], playerId);\r","                break;\r","\r","            default:\r","                break;\r","        }\r","        break;\r","\r","    default:\r","        break;\r","}\r",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"expressionType":{"type":"expression"},"parameters":[{"description":"The gamepad identifier: 1, 2, 3 or 4","name":"player_ID","type":"expression"},{"description":"Stick: \"Left\" or \"Right\"","name":"stick","supplementaryInformation":"[\"Left\",\"Right\"]","type":"stringWithSelector"},{"description":"Direction","name":"direction","supplementaryInformation":"[\"Up\",\"Down\",\"Left\",\"Right\",\"Horizontal\",\"Vertical\"]","type":"stringWithSelector"}],"objectGroups":[]},{"description":"Return the gamepad stick force on X axis (from -1 at the left to 1 at the right).","fullName":"Stick X force","functionType":"Expression","name":"StickForceX","sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["/** @type {Gamepad[]} */\r","const gamepads = navigator.getGamepads ? navigator.getGamepads() : (navigator.webkitGetGamepads ? navigator.webkitGetGamepads() : []);\r","\r","//Get function parameters\r","const playerId = eventsFunctionContext.getArgument(\"Gamepad\") - 1;\r","const stick = eventsFunctionContext.getArgument(\"Stick\").toLowerCase();\r","\r","if (playerId < 0 || playerId > 4) {\r","    console.error('Parameter gamepad identifier is not valid in expression: \"Value of a gamepad axis\"');\r","    return;\r","}\r","if (stick != \"left\" && stick != \"right\") {\r","    console.error('Parameter stick is not valid in expression: \"Value of a gamepad axis\"');\r","    return;\r","}\r","const gamepad = gamepads[playerId];\r","\r","//we need keep this condition because when use have not yet plug her controller we can't get the controller in the gamepad variable.\r","if (gamepad == null) return;\r","\r","const axisIndex = stick === 'right' ? 2 : 0;\r","eventsFunctionContext.returnValue = gdjs._extensionController.getNormalizedAxisValue(gamepad.axes[axisIndex], playerId);\r",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"expressionType":{"type":"expression"},"parameters":[{"description":"The gamepad identifier: 1, 2, 3 or 4","name":"Gamepad","type":"expression"},{"description":"Stick: \"Left\" or \"Right\"","name":"Stick","supplementaryInformation":"[\"Left\",\"Right\"]","type":"stringWithSelector"}],"objectGroups":[]},{"description":"Return the gamepad stick force on Y axis (from -1 at the top to 1 at the bottom).","fullName":"Stick Y force","functionType":"Expression","name":"StickForceY","sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["/** @type {Gamepad[]} */\r","const gamepads = navigator.getGamepads ? navigator.getGamepads() : (navigator.webkitGetGamepads ? navigator.webkitGetGamepads() : []);\r","\r","//Get function parameters\r","const playerId = eventsFunctionContext.getArgument(\"Gamepad\") - 1;\r","const stick = eventsFunctionContext.getArgument(\"Stick\").toLowerCase();\r","\r","if (playerId < 0 || playerId > 4) {\r","    console.error('Parameter gamepad identifier is not valid in expression: \"Value of a gamepad axis\"');\r","    return;\r","}\r","if (stick != \"left\" && stick != \"right\") {\r","    console.error('Parameter stick is not valid in expression: \"Value of a gamepad axis\"');\r","    return;\r","}\r","const gamepad = gamepads[playerId];\r","\r","//we need keep this condition because when use have not yet plug her controller we can't get the controller in the gamepad variable.\r","if (gamepad == null) return;\r","\r","const axisIndex = stick === 'right' ? 3 : 1;\r","eventsFunctionContext.returnValue = gdjs._extensionController.getNormalizedAxisValue(gamepad.axes[axisIndex], playerId);\r",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"expressionType":{"type":"expression"},"parameters":[{"description":"The gamepad identifier: 1, 2, 3 or 4","name":"Gamepad","type":"expression"},{"description":"Stick: \"Left\" or \"Right\"","name":"Stick","supplementaryInformation":"[\"Left\",\"Right\"]","type":"stringWithSelector"}],"objectGroups":[]},{"description":"Test if a button is released on a gamepad. Buttons can be:\n* Xbox: \"A\", \"B\", \"X\", \"Y\", \"LB\", \"RB\", \"LT\", \"RT\", \"BACK\", \"START\",\n* PS4: \"CROSS\", \"SQUARE\", \"CIRCLE\", \"TRIANGLE\", \"L1\", \"L2\", \"R1\", \"R2\", \"SHARE\", \"OPTIONS\", \"PS_BUTTON\", \"CLICK_TOUCHPAD\",\n* Other: \"UP\", \"DOWN\", \"LEFT\", \"RIGHT\", \"CLICK_STICK_LEFT\", \"CLICK_STICK_RIGHT\".","fullName":"Gamepad button released","functionType":"Condition","name":"C_Button_released","sentence":"Button _PARAM2_ of gamepad _PARAM1_ is released","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["/** @type {Gamepad[]} */\r","const gamepads = navigator.getGamepads ? navigator.getGamepads() : (navigator.webkitGetGamepads ? navigator.webkitGetGamepads() : []);\r","\r","//Get function parameters\r","const playerId = eventsFunctionContext.getArgument(\"player_ID\") - 1;\r","const button = eventsFunctionContext.getArgument(\"button\").toUpperCase();\r","\r","if (playerId < 0 || playerId > 4) {\r","    console.error('Parameter gamepad identifier in condition: \"Gamepad button released\", is not valid number, must be between 0 and 4.');\r","    return;\r","}\r","if (button === \"\") {\r","    console.error('Parameter button is not valid in condition: \"Gamepad button released\"');\r","    return;\r","}\r","\r","const gamepad = gamepads[playerId];\r","\r","//we need keep this condition because when use have not yet plug her controller we can't get the controller in the gamepad variable.\r","if (gamepad == null) return;\r","\r","let buttonId;\r","\r","switch (button) {\r","    case 'A':\r","    case 'CROSS':\r","        buttonId = 0;\r","        break;\r","    case 'B':\r","    case 'CIRCLE':\r","        buttonId = 1;\r","        break;\r","    case 'X':\r","    case 'SQUARE':\r","        buttonId = 2;\r","        break;\r","    case 'Y':\r","    case 'TRIANGLE':\r","        buttonId = 3;\r","        break;\r","    case 'LB':\r","    case 'L1':\r","        buttonId = 4;\r","        break;\r","    case 'RB':\r","    case 'R1':\r","        buttonId = 5;\r","        break;\r","    case 'LT':\r","    case 'L2':\r","        buttonId = 6;\r","        break;\r","    case 'RT':\r","    case 'R2':\r","        buttonId = 7;\r","        break;\r","\r","    case 'UP':\r","        buttonId = 12;\r","        break;\r","    case 'DOWN':\r","        buttonId = 13;\r","        break;\r","    case 'LEFT':\r","        buttonId = 14;\r","        break;\r","    case 'RIGHT':\r","        buttonId = 15;\r","        break;\r","\r","    case 'BACK':\r","    case 'SHARE':\r","        buttonId = 8;\r","        break;\r","    case 'START':\r","    case 'OPTIONS':\r","        buttonId = 9;\r","        break;\r","\r","    case 'CLICK_STICK_LEFT':\r","        buttonId = 10;\r","        break;\r","    case 'CLICK_STICK_RIGHT':\r","        buttonId = 11;\r","        break;\r","\r","    //PS4\r","    case 'PS_BUTTON':\r","        buttonId = 16;\r","        break;\r","    case 'CLICK_TOUCHPAD':\r","        buttonId = 17;\r","        break;\r","\r","    default:\r","        console.error('The button: ' + button + ' in condition: \"Gamepad button released\" is not valid.');\r","        break;\r","}\r","\r","if (buttonId === undefined) {\r","    console.error('There is no buttons valid in condition: \"Gamepad button released\"');\r","    eventsFunctionContext.returnValue = false;\r","    return;\r","}\r","\r","if (gamepad.buttons == null || gamepad.buttons[buttonId] == null) {\r","    console.error('Buttons on the gamepad are not accessible in condition: \"Gamepad button released\"');\r","    eventsFunctionContext.returnValue = false;\r","    return;\r","}\r","\r","//Define default value on pressed button or use previous value\r","gdjs._extensionController.players[playerId].previousFrameStateButtons[buttonId] = gdjs._extensionController.players[playerId].previousFrameStateButtons[buttonId] || { pressed: false };\r","\r","//Get state of button at previous frame\r","const previousStateButton = gdjs._extensionController.players[playerId].previousFrameStateButtons[buttonId].pressed;\r","\r","//When previousStateButton is true and actual button state is not pressed\r","//Player have release the button\r","if (previousStateButton === true && gamepad.buttons[buttonId].pressed === false) {\r","    // Save the last button used for the player    \r","    gdjs._extensionController.players[playerId].lastButtonUsed = buttonId;\r","    gdjs._extensionController.players[playerId].previousFrameStateButtons[buttonId].pressed = true;\r","    eventsFunctionContext.returnValue = true;\r","\r","} else {\r","    gdjs._extensionController.players[playerId].previousFrameStateButtons[buttonId].pressed = false;\r","    eventsFunctionContext.returnValue = false;\r","}\r",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"The gamepad identifier: 1, 2, 3 or 4","name":"player_ID","type":"expression"},{"description":"Name of the button","name":"button","supplementaryInformation":"[\"A\",\"Cross\",\"B\",\"Circle\",\"X\",\"Square\",\"Y\",\"Triangle\",\"LB\",\"L1\",\"RB\",\"R1\",\"LT\",\"L2\",\"RT\",\"R2\",\"Up\",\"Down\",\"Left\",\"Right\",\"Back\",\"Share\",\"Start\",\"Options\",\"Click_Stick_Left\",\"Click_Stick_Right\",\"PS_Button\",\"Click_Touchpad\"]","type":"stringWithSelector"}],"objectGroups":[]},{"description":"Return the index of the last pressed button of a gamepad.","fullName":"Last pressed button (id)","functionType":"Expression","name":"LastButtonID","sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["//Get function parameter\r","const playerId = eventsFunctionContext.getArgument(\"player_ID\") - 1;\r","\r","//Player id is not valid\r","if (playerId < 0 || playerId > 4) {\r","    console.error('Parameter gamepad identifier in expression: \"Last pressed button (id)\", is not valid number, must be between 0 and 4.');\r","    return;\r","}\r","\r","//Return the last button used by the player\r","eventsFunctionContext.returnValue = gdjs._extensionController.players[playerId].lastButtonUsed;"],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"expressionType":{"type":"expression"},"parameters":[{"description":"The gamepad identifier: 1, 2, 3 or 4","name":"player_ID","type":"expression"}],"objectGroups":[]},{"description":"Check if any button is pressed on a gamepad.","fullName":"Any gamepad button pressed","functionType":"Condition","name":"C_Any_Button_pressed","sentence":"Any button of gamepad _PARAM1_ is pressed","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["/** @type {Gamepad[]} */\r","const gamepads = navigator.getGamepads ? navigator.getGamepads() : (navigator.webkitGetGamepads ? navigator.webkitGetGamepads() : []);\r","\r","//Get function parameter\r","const playerId = eventsFunctionContext.getArgument(\"player_ID\") - 1;\r","\r","if (playerId < 0 || playerId > 4) {\r","    console.error('Parameter gamepad identifier in condition: \"Any gamepad button pressed\", is not valid number, must be between 0 and 4.');\r","    return;\r","}\r","const gamepad = gamepads[playerId];\r","\r","//we need keep this condition because when use have not yet plug her controller we can't get the controller in the gamepad variable.\r","if (gamepad == null) return;\r","\r","let buttonId;\r","for (let i = 0; i < gamepad.buttons.length; i++) { //For each buttons\r","    if (gamepad.buttons[i].pressed) { //One of them is pressed\r","        buttonId = i; //Save the button pressed\r","        break;\r","    }\r","}\r","\r","if (buttonId === undefined) {\r","    // No buttons are pressed.\r","    eventsFunctionContext.returnValue = false;\r","    return;\r","}\r","\r","if (gamepad.buttons == null || gamepad.buttons[buttonId] == null) {\r","    console.error('Buttons on the gamepad are not accessible in condition: \"Any gamepad button pressed\"');\r","    eventsFunctionContext.returnValue = false;\r","    return;\r","}\r","\r","//When a button is pressed, save the button in lastButtonUsed for each players\r","if (gamepad.buttons[buttonId].pressed) gdjs._extensionController.players[playerId].lastButtonUsed = buttonId;\r","eventsFunctionContext.returnValue = gamepad.buttons[buttonId].pressed;\r","\r","\r",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"The gamepad identifier: 1, 2, 3 or 4","name":"player_ID","type":"expression"}],"objectGroups":[]},{"description":"Return the last button pressed. \nButtons for Xbox and PS4 can be:\n* Xbox: \"A\", \"B\", \"X\", \"Y\", \"LB\", \"RB\", \"LT\", \"RT\", \"BACK\", \"START\",\n* PS4: \"CROSS\", \"SQUARE\", \"CIRCLE\", \"TRIANGLE\", \"L1\", \"L2\", \"R1\", \"R2\", \"SHARE\", \"OPTIONS\", \"PS_BUTTON\", \"CLICK_TOUCHPAD\",\n* Both: \"UP\", \"DOWN\", \"LEFT\", \"RIGHT\", \"CLICK_STICK_LEFT\", \"CLICK_STICK_RIGHT\".","fullName":"Last pressed button (string)","functionType":"StringExpression","name":"LastButtonString","sentence":"Button _PARAM2_ of gamepad _PARAM1_ is pressed","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["/** @type {Gamepad[]} */\r","const gamepads = navigator.getGamepads ? navigator.getGamepads() : (navigator.webkitGetGamepads ? navigator.webkitGetGamepads() : []);\r","\r","//Get function parameters\r","const playerId = eventsFunctionContext.getArgument(\"player_ID\") - 1;\r","const controllerType = eventsFunctionContext.getArgument(\"controller_type\").toUpperCase();\r","\r","if (playerId < 0 || playerId > 4) {\r","    console.error('Parameter gamepad identifier in string expression: \"Last pressed button (LastButtonString)\", is not valid number, must be between 0 and 4.');\r","    return;\r","}\r","if (controllerType === \"\") {\r","    console.error('Parameter controller type is not valid in string expression: \"Last pressed button (LastButtonString)\"');\r","    return;\r","}\r","\r","const gamepad = gamepads[playerId];\r","\r","if (gamepad !== null) { //Gamepad exist\r","    //Get last btn id\r","    const lastButtonUsedID = gdjs._extensionController.players[playerId].lastButtonUsed;\r","\r","    //Return last button as string    \r","    eventsFunctionContext.returnValue = gdjs._extensionController.getInputString(controllerType, lastButtonUsedID);\r","\r","} else { //Gamepad dosen't exist\r","    console.error('Your controller is not supported or the gamepad wasn\\'t detected in string expression: \"Last pressed button (LastButtonString)\"');\r","    eventsFunctionContext.returnValue = \"Gamepad not connected\";\r","}"],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"expressionType":{"type":"string"},"parameters":[{"description":"The gamepad identifier: 1, 2, 3 or 4","name":"player_ID","type":"expression"},{"description":"Controller type","name":"controller_type","supplementaryInformation":"[\"Xbox\",\"PS4\"]","type":"stringWithSelector"}],"objectGroups":[]},{"description":"Return the number of gamepads.","fullName":"Gamepad count","functionType":"Expression","name":"GamepadCount","sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["const gamepads = navigator.getGamepads ? navigator.getGamepads() : (navigator.webkitGetGamepads ? navigator.webkitGetGamepads() : []);\r","\r","//Get the last activated controller\r","const controllerId = gdjs._extensionController.lastActiveController;\r","\r","// Check if controller is active\r","const gamepad = gamepads[controllerId];\r","if (gamepad == null) {\r","    eventsFunctionContext.returnValue = 0;\r","} else {\r","    // Return active controller id\r","    eventsFunctionContext.returnValue = controllerId + 1;\r","}\r",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"expressionType":{"type":"expression"},"parameters":[],"objectGroups":[]},{"description":"Check if a button is pressed on a gamepad. \nButtons can be:\n* Xbox: \"A\", \"B\", \"X\", \"Y\", \"LB\", \"RB\", \"LT\", \"RT\", \"BACK\", \"START\",\n* PS4: \"CROSS\", \"SQUARE\", \"CIRCLE\", \"TRIANGLE\", \"L1\", \"L2\", \"R1\", \"R2\", \"SHARE\", \"OPTIONS\", \"PS_BUTTON\", \"CLICK_TOUCHPAD\",\n* Other: \"UP\", \"DOWN\", \"LEFT\", \"RIGHT\", \"CLICK_STICK_LEFT\", \"CLICK_STICK_RIGHT\".","fullName":"Gamepad button pressed","functionType":"Condition","name":"C_Button_pressed","sentence":"Button _PARAM2_ of gamepad _PARAM1_ is pressed","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["/** @type {Gamepad[]} */\r","const gamepads = navigator.getGamepads ? navigator.getGamepads() : (navigator.webkitGetGamepads ? navigator.webkitGetGamepads() : []);\r","\r","//Get function parameters\r","const playerId = eventsFunctionContext.getArgument(\"player_ID\") - 1;\r","const button = eventsFunctionContext.getArgument(\"button\").toUpperCase();\r","\r","if (playerId < 0 || playerId > 4) {\r","    console.error('Parameter gamepad identifier in condition: \"Gamepad button pressed\", is not valid number, must be between 0 and 4.');\r","    return;\r","}\r","if (button === \"\") {\r","    console.error('Parameter button is not valid in condition: \"Gamepad button pressed\"');\r","    eventsFunctionContext.returnValue = false;\r","    return;\r","}\r","\r","const gamepad = gamepads[playerId];\r","\r","//we need keep this condition because when use have not yet plug her controller we can't get the controller in the gamepad variable.\r","if (gamepad == null) return;\r","\r","let buttonId;\r","\r","switch (button) {\r","    case 'A':\r","    case 'CROSS':\r","        buttonId = 0;\r","        break;\r","    case 'B':\r","    case 'CIRCLE':\r","        buttonId = 1;\r","        break;\r","    case 'X':\r","    case 'SQUARE':\r","        buttonId = 2;\r","        break;\r","    case 'Y':\r","    case 'TRIANGLE':\r","        buttonId = 3;\r","        break;\r","    case 'LB':\r","    case 'L1':\r","        buttonId = 4;\r","        break;\r","    case 'RB':\r","    case 'R1':\r","        buttonId = 5;\r","        break;\r","    case 'LT':\r","    case 'L2':\r","        buttonId = 6;\r","        break;\r","    case 'RT':\r","    case 'R2':\r","        buttonId = 7;\r","        break;\r","\r","    case 'UP':\r","        buttonId = 12;\r","        break;\r","    case 'DOWN':\r","        buttonId = 13;\r","        break;\r","    case 'LEFT':\r","        buttonId = 14;\r","        break;\r","    case 'RIGHT':\r","        buttonId = 15;\r","        break;\r","\r","    case 'BACK':\r","    case 'SHARE':\r","        buttonId = 8;\r","        break;\r","    case 'START':\r","    case 'OPTIONS':\r","        buttonId = 9;\r","        break;\r","\r","    case 'CLICK_STICK_LEFT':\r","        buttonId = 10;\r","        break;\r","    case 'CLICK_STICK_RIGHT':\r","        buttonId = 11;\r","        break;\r","\r","    //PS4\r","    case 'PS_BUTTON':\r","        buttonId = 16;\r","        break;\r","    case 'CLICK_TOUCHPAD':\r","        buttonId = 17;\r","        break;\r","\r","    default:\r","        console.error('The button: ' + button + ' in condition: \"Gamepad button pressed\" is not valid.');\r","        eventsFunctionContext.returnValue = false;\r","        break;\r","}\r","\r","\r","\r","if (buttonId === undefined) {\r","    console.error('There is no buttons valid in condition: \"Gamepad button pressed\"');\r","    eventsFunctionContext.returnValue = false;\r","    return;\r","}\r","\r","if (gamepad.buttons == null || gamepad.buttons[buttonId] == null) {\r","    console.error('Buttons on the gamepad are not accessible in condition: \"Gamepad button pressed\"');\r","    eventsFunctionContext.returnValue = false;\r","    return;\r","}\r","\r","//When a button is pressed, save the button in lastButtonUsed for each players\r","if (gamepad.buttons[buttonId].pressed) gdjs._extensionController.players[playerId].lastButtonUsed = buttonId;\r","eventsFunctionContext.returnValue = gamepad.buttons[buttonId].pressed;\r","\r","\r","\r",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"The gamepad identifier: 1, 2, 3 or 4","name":"player_ID","type":"expression"},{"description":"Name of the button","name":"button","supplementaryInformation":"[\"A\",\"Cross\",\"B\",\"Circle\",\"X\",\"Square\",\"Y\",\"Triangle\",\"LB\",\"L1\",\"RB\",\"R1\",\"LT\",\"L2\",\"RT\",\"R2\",\"Up\",\"Down\",\"Left\",\"Right\",\"Back\",\"Share\",\"Start\",\"Options\",\"Click_Stick_Left\",\"Click_Stick_Right\",\"PS_Button\",\"Click_Touchpad\"]","type":"stringWithSelector"}],"objectGroups":[]},{"description":"Return the value of the deadzone applied to a gamepad sticks, between 0 and 1.","fullName":"Gamepad deadzone for sticks","functionType":"Expression","name":"Deadzone","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[]},{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["//Get function parameter\r","const playerId = eventsFunctionContext.getArgument(\"player_ID\") - 1;\r","\r","if (playerId < 0 || playerId > 4) {\r","    console.error('Parameter gamepad identifier in expression: \"Gamepad deadzone for sticks\", is not valid number, must be between 0 and 4.');\r","    return;\r","}\r","///Return the deadzone value for a given player\r","eventsFunctionContext.returnValue = gdjs._extensionController.players[playerId].deadzone;"],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"expressionType":{"type":"expression"},"parameters":[{"description":"The gamepad identifier: 1, 2, 3 or 4","name":"player_ID","type":"expression"}],"objectGroups":[]},{"description":"Set the deadzone for sticks of the gamepad. The deadzone is an area for which movement on sticks won't be taken into account (instead, the stick will be considered as not moved). Deadzone is between 0 and 1, and is by default 0.2.","fullName":"Set gamepad deadzone for sticks","functionType":"Action","name":"A_Set_deadzone","sentence":"Set deadzone for sticks on gamepad: _PARAM1_ to _PARAM2_","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["//Get function parameter\r","const playerId = eventsFunctionContext.getArgument(\"player_ID\") - 1;\r","const newDeadzone = eventsFunctionContext.getArgument(\"deadzone\");\r","\r","if (playerId < 0 || playerId > 4) {\r","    console.error('Parameter gamepad identifier in action: \"Set gamepad deadzone for sticks\", is not valid, must be between 0 and 4.');\r","    return;\r","}\r","\r","// clamp the newDeadzone in range [0, 1].\r","// https://github.com/4ian/GDevelop-extensions/pull/33#issuecomment-618224857\r","gdjs._extensionController.players[playerId].deadzone = gdjs.evtTools.common.clamp(newDeadzone, 0, 1);\r",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"The gamepad identifier: 1, 2, 3 or 4","name":"player_ID","type":"expression"},{"description":"Deadzone for sticks, 0.2 by default (0 to 1)","name":"deadzone","type":"expression"}],"objectGroups":[]},{"description":"Check if a stick of a gamepad is pushed in a given direction.","fullName":"Gamepad stick pushed (axis)","functionType":"Condition","name":"C_Axis_pushed","sentence":"_PARAM2_ stick of gamepad _PARAM1_ is pushed in direction _PARAM3_","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["/** @type {Gamepad[]} */\r","const gamepads = navigator.getGamepads ? navigator.getGamepads() : (navigator.webkitGetGamepads ? navigator.webkitGetGamepads() : []);\r","\r","//Get function parameters\r","const playerId = eventsFunctionContext.getArgument(\"player_ID\") - 1;\r","const stick = eventsFunctionContext.getArgument(\"stick\").toUpperCase();\r","const direction = eventsFunctionContext.getArgument(\"direction\").toUpperCase();\r","\r","if (playerId < 0 || playerId > 4) {\r","    console.error('Parameter gamepad identifier in condition: \"Gamepad stick pushed (axis)\", is not valid number, must be between 0 and 4.');\r","    return;\r","}\r","if (stick != \"LEFT\" && stick != \"RIGHT\") {\r","    console.error('Parameter stick in condition: \"Gamepad stick pushed (axis)\", is not valid, must be LEFT or RIGHT');\r","    return;\r","}\r","if (direction != \"UP\" && direction != \"DOWN\" && direction != \"LEFT\" && direction != \"RIGHT\" && direction != \"ANY\") {\r","    console.error('Parameter deadzone in condition: \"Gamepad stick pushed (axis)\", is not valid, must be UP, DOWN, LEFT or RIGHT');\r","    return;\r","}\r","\r","const gamepad = gamepads[playerId];\r","\r","//we need keep this condition because when use have not yet plug her controller we can't get the controller in the gamepad variable.\r","if (gamepad == null) {\r","    eventsFunctionContext.returnValue = false;\r","    return;\r","}\r","\r","\r","//Define in onFirstSceneLoaded function\r","const getNormalizedAxisValue = gdjs._extensionController.getNormalizedAxisValue;\r","\r","switch (stick) {\r","    case 'LEFT':\r","        switch (direction) {\r","            case 'LEFT':\r","                if (getNormalizedAxisValue(gamepad.axes[0], playerId) < 0) {\r","                    eventsFunctionContext.returnValue = true;\r","                    return;\r","                }\r","                break;\r","\r","            case 'RIGHT':\r","                if (getNormalizedAxisValue(gamepad.axes[0], playerId) > 0) {\r","                    eventsFunctionContext.returnValue = true;\r","                    return;\r","                }\r","                break;\r","\r","            case 'UP':\r","                if (getNormalizedAxisValue(gamepad.axes[1], playerId) < 0) {\r","                    eventsFunctionContext.returnValue = true;\r","                    return;\r","                }\r","                break;\r","\r","            case 'DOWN':\r","                if (getNormalizedAxisValue(gamepad.axes[1], playerId) > 0) {\r","                    eventsFunctionContext.returnValue = true;\r","                    return;\r","                }\r","                break;\r","\r","            case 'ANY':\r","                if (   getNormalizedAxisValue(gamepad.axes[0], playerId) < 0\r","                    || getNormalizedAxisValue(gamepad.axes[0], playerId) > 0\r","                    || getNormalizedAxisValue(gamepad.axes[1], playerId) < 0 \r","                    || getNormalizedAxisValue(gamepad.axes[1], playerId) > 0) {\r","                    eventsFunctionContext.returnValue = true;\r","                    return;\r","                }\r","                break;\r","\r","            default:\r","                console.error('The value Direction on stick Left on the condition: \"Gamepad stick pushed (axis)\" is not valid.');\r","                eventsFunctionContext.returnValue = false;\r","                break;\r","        }\r","        break;\r","\r","    case 'RIGHT':\r","        switch (direction) {\r","            case 'LEFT':\r","                if (getNormalizedAxisValue(gamepad.axes[2], playerId) < 0) {\r","                    eventsFunctionContext.returnValue = true;\r","                    return;\r","                }\r","                break;\r","\r","            case 'RIGHT':\r","                if (getNormalizedAxisValue(gamepad.axes[2], playerId) > 0) {\r","                    eventsFunctionContext.returnValue = true;\r","                    return;\r","                }\r","                break;\r","\r","            case 'UP':\r","                if (getNormalizedAxisValue(gamepad.axes[3], playerId) < 0) {\r","                    eventsFunctionContext.returnValue = true;\r","                    return;\r","                }\r","                break;\r","\r","            case 'DOWN':\r","                if (getNormalizedAxisValue(gamepad.axes[3], playerId) > 0) {\r","                    eventsFunctionContext.returnValue = true;\r","                    return;\r","                }\r","                break;\r","\r","            case 'ANY':\r","                if (   getNormalizedAxisValue(gamepad.axes[2], playerId) < 0\r","                    || getNormalizedAxisValue(gamepad.axes[2], playerId) > 0\r","                    || getNormalizedAxisValue(gamepad.axes[3], playerId) < 0 \r","                    || getNormalizedAxisValue(gamepad.axes[3], playerId) > 0) {\r","                    eventsFunctionContext.returnValue = true;\r","                    return;\r","                }\r","                break;\r","\r","            default:\r","                console.error('The value Direction on stick Right on the condition: \"Gamepad stick pushed (axis)\" is not valid.');\r","                eventsFunctionContext.returnValue = false;\r","                break;\r","        }\r","        break;\r","\r","    default:\r","        console.error('The value Stick on the condition: \"Gamepad stick pushed (axis)\" is not valid.');\r","        eventsFunctionContext.returnValue = false;\r","        break;\r","}\r","\r","eventsFunctionContext.returnValue = false;\r",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"The gamepad identifier: 1, 2, 3 or 4","name":"player_ID","type":"expression"},{"description":"Stick: \"Left\" or \"Right\"","name":"stick","supplementaryInformation":"[\"Left\",\"Right\"]","type":"stringWithSelector"},{"description":"Direction","name":"direction","supplementaryInformation":"[\"Up\",\"Down\",\"Left\",\"Right\",\"Any\"]","type":"stringWithSelector"}],"objectGroups":[]},{"description":"Return the number of connected gamepads.","fullName":"Connected gamepads number","functionType":"Expression","name":"ConnectedGamepadsCount","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[]},{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["/** @type {Gamepad[]} */\r","const gamepads = navigator.getGamepads ? navigator.getGamepads() : (navigator.webkitGetGamepads ? navigator.webkitGetGamepads() : []);\r","\r","// Gamepads can be disconnected and become null, so we have to filter them.\r","eventsFunctionContext.returnValue = Object.keys(gamepads).filter(key => !!gamepads[key]).length;\r",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"expressionType":{"type":"expression"},"parameters":[],"objectGroups":[]},{"description":"Return a string containing informations about the specified gamepad.","fullName":"Gamepad type","functionType":"StringExpression","name":"GamepadType","sentence":"Player _PARAM1_ use _PARAM2_ controller","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["/** @type {Gamepad[]} */","const gamepads = navigator.getGamepads ? navigator.getGamepads() : (navigator.webkitGetGamepads ? navigator.webkitGetGamepads() : []);","","//Get function parameter","const playerId = eventsFunctionContext.getArgument(\"player_ID\") - 1;","","if (playerId < 0 || playerId > 4) {","    console.error('Parameter gamepad identifier in string expression: \"Gamepad type\", is not valid number, must be between 0 and 4');","    return;","}","","const gamepad = gamepads[playerId];","","//we need keep this condition because when use have not yet plug her controller we can't get the controller in the gamepad variable.","if (gamepad == null) return;","","eventsFunctionContext.returnValue = (gamepad && gamepad.id) ? gamepad.id : \"No information for player \" + (playerId + 1)",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"expressionType":{"type":"string"},"parameters":[{"description":"The gamepad identifier: 1, 2, 3 or 4","name":"player_ID","type":"expression"}],"objectGroups":[]},{"description":"Check if the specified gamepad has the specified information in its description. Useful to know if the gamepad is a Xbox or PS4 controller.","fullName":"Gamepad type","functionType":"Condition","name":"C_Controller_type","sentence":"Gamepad _PARAM1_ is a _PARAM2_ controller","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["/** @type {Gamepad[]} */","const gamepads = navigator.getGamepads ? navigator.getGamepads() : (navigator.webkitGetGamepads ? navigator.webkitGetGamepads() : []);","","//Get function parameters","const playerId = eventsFunctionContext.getArgument(\"player_ID\") - 1;","const controllerType = eventsFunctionContext.getArgument(\"controller_type\").toUpperCase();","","if (playerId < 0 || playerId > 4) {","    console.error('Parameter gamepad identifier in condition: \"Gamepad type\", is not valid number, must be between 0 and 4.');","    return;","}","if (controllerType === \"\") {","    console.error('Parameter type in condition: \"Gamepad type\", is not a string.');","    return;","}","","const gamepad = gamepads[playerId];","","//we need keep this condition because when use have not yet plug her controller we can't get the controller in the gamepad variable.","if (gamepad == null) return;","","","if (controllerType == \"XBOX\") {","    eventsFunctionContext.returnValue = gdjs._extensionController.isXbox(gamepad);","} else {","    eventsFunctionContext.returnValue = gamepad ? gamepad.id.toUpperCase().indexOf(controllerType) !== -1 : false;","}"],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"The gamepad identifier: 1, 2, 3 or 4","name":"player_ID","type":"expression"},{"description":"Type: \"Xbox\", \"PS4\", \"Steam\" or \"PS3\" (among other)","name":"controller_type","type":"string"}],"objectGroups":[]},{"description":"Check if a gamepad is connected.","fullName":"Gamepad connected","functionType":"Condition","name":"C_Controller_X_is_connected","sentence":"Gamepad _PARAM1_ is plugged and connected","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["/** @type {Gamepad[]} */","const gamepads = navigator.getGamepads ? navigator.getGamepads() : (navigator.webkitGetGamepads ? navigator.webkitGetGamepads() : []);","","//Get function parameter","const playerId = eventsFunctionContext.getArgument(\"player_ID\") - 1;","","if (playerId < 0 || playerId > 4) {","    console.error('Parameter gamepad identifier in condition: \"Gamepad connected\", is not valid number, must be between 0 and 4.');","    return;","}","","// If gamepad was disconnected it will be null (so this will return false)","// If gamepad was never connected it will be undefined (so this will return false)","eventsFunctionContext.returnValue = !!gamepads[playerId];"],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"The gamepad identifier: 1, 2, 3 or 4","name":"player_ID","type":"expression"}],"objectGroups":[]},{"description":"Generate a vibration on the specified controller. Might only work if the game is running in a recent web browser.","fullName":"Gamepad vibration","functionType":"Action","name":"A_Vibrate_controller","sentence":"Make gamepad _PARAM1_ vibrate for _PARAM2_ seconds","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["/** @type {Gamepad[]} */","//Vibration work only on game in browser.","const gamepads = navigator.getGamepads ? navigator.getGamepads() : (navigator.webkitGetGamepads ? navigator.webkitGetGamepads() : []);","","//Get function parameters","const playerId = eventsFunctionContext.getArgument(\"Player_ID\") - 1;","const duration = eventsFunctionContext.getArgument(\"Duration\") || 1;","","if (playerId < 0 || playerId > 4) {","  console.error('Parameter gamepad identifier in action: \"Gamepad connected\", is not valid number, must be between 0 and 4.');","  return;","}","","const gamepad = gamepads[playerId];","","//we need keep this condition because when use have not yet plug her controller we can't get the controller in the gamepad variable.","if (gamepad == null) return;","","if (gamepad && gamepad.vibrationActuator) {","  gamepad.vibrationActuator.playEffect(\"dual-rumble\", {","    startDelay: 0,","    duration: duration * 1000,","    weakMagnitude: 1.0,","    strongMagnitude: 1.0","  });","}"],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"The gamepad identifier: 1, 2, 3 or 4","name":"Player_ID","type":"expression"},{"description":"Time of the vibration, in seconds (optional, default value is 1)","name":"Duration","type":"expression"}],"objectGroups":[]},{"description":"Generate an advanced vibration on the specified controller. Incompatible with Firefox.","fullName":"Advanced gamepad vibration","functionType":"Action","name":"A_Advanced_Vibration_Controller","sentence":"Make gamepad _PARAM1_ vibrate for _PARAM2_ seconds with the vibration magnitude of _PARAM3_ and _PARAM4_","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["/** @type {Gamepad[]} */","//Vibration work only on game in browser.","const gamepads = navigator.getGamepads ? navigator.getGamepads() : (navigator.webkitGetGamepads ? navigator.webkitGetGamepads() : []);","","//Get function parameters","const playerId = eventsFunctionContext.getArgument(\"Player_ID\") - 1;","const duration = eventsFunctionContext.getArgument(\"Duration\") || 1;","const strongRumbleMagnitude = eventsFunctionContext.getArgument(\"StrongMagnitude\");","const weakRumbleMagnitude = eventsFunctionContext.getArgument(\"WeakMagnitude\");","","if (playerId < 0 || playerId > 4) {","  console.error('Parameter gamepad identifier in action: \"Advanced gamepad vibration\", is not valid number, must be between 0 and 4.');","  return;","}","if (weakRumbleMagnitude < 0 || weakRumbleMagnitude > 1) {","  console.error('Parameter weakRumble identifier in action: \"Advanced gamepad vibration\", is not valid number, must be between 0 and 1.');","  return;","}","if (strongRumbleMagnitude < 0 || strongRumbleMagnitude > 1) {","  console.error('Parameter strongRumble identifier in action: \"Advanced gamepad vibration\", is not valid number, must be between 0 and 1.');","  return;","}","","const gamepad = gamepads[playerId];","","//we need keep this condition because when use have not yet plug the controller we can't get the controller in the gamepad variable.","if (gamepad == null) return;","","if (gamepad && gamepad.vibrationActuator) {","  gamepad.vibrationActuator.playEffect(\"dual-rumble\", {","    startDelay: 0,","    duration: duration * 1000,","    weakMagnitude: weakRumbleMagnitude,","    strongMagnitude: strongRumbleMagnitude","  });","}","","gdjs._extensionController.players[playerId].rumble.duration = duration;","gdjs._extensionController.players[playerId].rumble.elapsedTime = 0;","gdjs._extensionController.players[playerId].rumble.weakMagnitude = weakRumbleMagnitude;","gdjs._extensionController.players[playerId].rumble.strongMagnitude = strongRumbleMagnitude;"],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"The gamepad identifier: 1, 2, 3 or 4","name":"Player_ID","type":"expression"},{"description":"Time of the vibration, in seconds (optional, default value is 1)","name":"Duration","type":"expression"},{"description":"Strong rumble magnitude (from 0 to 1)","name":"StrongMagnitude","type":"expression"},{"description":"Weak rumble magnitude (from 0 to 1)","name":"WeakMagnitude","type":"expression"}],"objectGroups":[]},{"description":"Change a vibration on the specified controller. Incompatible with Firefox.","fullName":"Change gamepad active vibration","functionType":"Action","name":"A_Change_Vibration_Magnitude","sentence":"Change the vibration magnitude of _PARAM2_ & _PARAM3_ on gamepad _PARAM1_","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["/** @type {Gamepad[]} */","//Vibration work only on game in browser.","const gamepads = navigator.getGamepads ? navigator.getGamepads() : (navigator.webkitGetGamepads ? navigator.webkitGetGamepads() : []);","","//Get function parameters","const playerId = eventsFunctionContext.getArgument(\"Player_ID\") - 1;","const elapsedTime = gdjs._extensionController.players[playerId].rumble.elapsedTime || 0;","const originalDuration = gdjs._extensionController.players[playerId].rumble.duration || 1;","const strongRumbleMagnitude = eventsFunctionContext.getArgument(\"StrongMagnitude\");","const weakRumbleMagnitude = eventsFunctionContext.getArgument(\"WeakMagnitude\");","","","if (playerId < 0 || playerId > 4) {","  console.error('Parameter gamepad identifier in action: \"Change gamepad active vibration\", is not valid number, must be between 0 and 4.');","  return;","}","if (weakRumbleMagnitude < 0 || weakRumbleMagnitude > 1) {","  console.error('Parameter weakRumble identifier in action: \"Change gamepad active vibration\", is not valid number, must be between 0 and 1.');","  return;","}","if (strongRumbleMagnitude < 0 || strongRumbleMagnitude > 1) {","  console.error('Parameter strongRumble identifier in action: \"Change gamepad active vibration\", is not valid number, must be between 0 and 1.');","  return;","}","","const gamepad = gamepads[playerId];","","//we need keep this condition because when use have not yet plug the controller we can't get the controller in the gamepad variable.","if (gamepad == null) return;","","if (originalDuration - elapsedTime <= 0) return;","","if (gamepad && gamepad.vibrationActuator) {","  gamepad.vibrationActuator.playEffect(\"dual-rumble\", {","    startDelay: 0,","    duration: 1000 * (originalDuration - elapsedTime),","    weakMagnitude: weakRumbleMagnitude,","    strongMagnitude: strongRumbleMagnitude","  });","}","","gdjs._extensionController.players[playerId].rumble.weakMagnitude = weakRumbleMagnitude;","gdjs._extensionController.players[playerId].rumble.strongMagnitude = strongRumbleMagnitude;"],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"The gamepad identifier: 1, 2, 3 or 4","name":"Player_ID","type":"expression"},{"description":"Strong rumble magnitude (from 0 to 1)","name":"StrongMagnitude","type":"expression"},{"description":"Weak rumble magnitude (from 0 to 1)","name":"WeakMagnitude","type":"expression"}],"objectGroups":[]},{"description":"Check if any button is released on a gamepad.","fullName":"Any gamepad button released","functionType":"Condition","name":"C_any_button_released","sentence":"Any button of gamepad _PARAM1_ is released","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[]},{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["/** @type {Gamepad[]} */\r","const gamepads = navigator.getGamepads ? navigator.getGamepads() : (navigator.webkitGetGamepads ? navigator.webkitGetGamepads() : []);\r","\r","//Get function parameters\r","const playerId = eventsFunctionContext.getArgument(\"player_ID\") - 1;\r","\r","if (playerId < 0 || playerId > 4) {\r","\tconsole.error('Parameter gamepad identifier in condition: \"Any gamepad button released\", is not valid number, must be between 0 and 4.');\r","\treturn;\r","}\r","\r","const gamepad = gamepads[playerId];\r","\r","//we need keep this condition because when use have not yet plug her controller we can't get the controller in the gamepad variable.\r","if (gamepad == null) return;\r","\r","for (let buttonId = 0; buttonId < gamepad.buttons.length; buttonId++) { //For each buttons on current frame.\r","\r","\tif (buttonId === undefined) {\r","\t\teventsFunctionContext.returnValue = false;\r","\t\treturn;\r","\t}\r","\r","\t//Get previous value or define value by default for the current button\r","\tgdjs._extensionController.players[playerId].previousFrameStateButtons[buttonId] = gdjs._extensionController.players[playerId].previousFrameStateButtons[buttonId] || { pressed: false };\r","\r","\t//Get state of the button at previous frame\r","\tconst previousStateButtonIsPressed = gdjs._extensionController.players[playerId].previousFrameStateButtons[buttonId].pressed;\r","\r","\t//Get the state of the button on the current frame.\r","\tconst currentFrameStateButtonIsPressed = gamepad.buttons[buttonId].pressed;\r","\r","\t//When previousStateButtonIsPressed is true and actual button state is not pressed\r","\t//Player have release the button\r","\tif (previousStateButtonIsPressed === true && currentFrameStateButtonIsPressed === false) {\r","\t\tgdjs._extensionController.players[playerId].previousFrameStateButtons[buttonId].pressed = true;\r","\t\teventsFunctionContext.returnValue = true;\r","\t\t//break;\r","\t\treturn;\r","\t} else {\r","\t\t//The player didn't released the button yet, the previous frame state is still true\r","\t\tgdjs._extensionController.players[playerId].previousFrameStateButtons[buttonId].pressed = false;\r","\t\teventsFunctionContext.returnValue = false;\r","\t}\r","\r","\tif (currentFrameStateButtonIsPressed) gdjs._extensionController.players[playerId].lastButtonUsed = buttonId;\r","}\r",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"The gamepad identifier: 1, 2, 3 or 4","name":"player_ID","type":"expression"}],"objectGroups":[]},{"description":"Return the strength of the weak vibration motor on the gamepad of a player.","fullName":"Weak rumble magnitude","functionType":"Expression","name":"WeakVibrationMagnitude","sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["const playerId = eventsFunctionContext.getArgument(\"Player_ID\") - 1;\r","eventsFunctionContext.returnValue = gdjs._extensionController.players[playerId].rumble.weakMagnitude;"],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":false}],"expressionType":{"type":"expression"},"parameters":[{"description":"The gamepad identifier: 1, 2, 3 or 4","name":"Player_ID","type":"expression"}],"objectGroups":[]},{"description":"Return the strength of the strong vibration motor on the gamepad of a player.","fullName":"Strong rumble magnitude","functionType":"Expression","name":"StrongVibrationMagnitude","sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["const playerId = eventsFunctionContext.getArgument(\"Player_ID\") - 1;\r","eventsFunctionContext.returnValue = gdjs._extensionController.players[playerId].rumble.strongMagnitude;"],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":false}],"expressionType":{"type":"expression"},"parameters":[{"description":"The gamepad identifier: 1, 2, 3 or 4","name":"Player_ID","type":"expression"}],"objectGroups":[]}],"eventsBasedBehaviors":[{"description":"Control a platformer character with a gamepad.","fullName":"Platformer gamepad mapper","name":"PlatformerGamepadMapper","objectType":"","eventsFunctions":[{"fullName":"","functionType":"Action","name":"doStepPreEvents","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"Gamepads::C_Controller_X_is_connected"},"parameters":["","GamepadIdentifier",""]}],"actions":[],"events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"BooleanVariable"},"parameters":["UseArrows","True",""]}],"actions":[],"events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"Gamepads::C_Button_pressed"},"parameters":["","GamepadIdentifier","\"Left\"","\"Left\""]}],"actions":[{"type":{"value":"PlatformBehavior::SimulateLeftKey"},"parameters":["Object","PlatformerCharacter"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"Gamepads::C_Button_pressed"},"parameters":["","GamepadIdentifier","\"Right\"","\"Left\""]}],"actions":[{"type":{"value":"PlatformBehavior::SimulateRightKey"},"parameters":["Object","PlatformerCharacter"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"Gamepads::C_Button_pressed"},"parameters":["","GamepadIdentifier","\"Up\"","\"Left\""]}],"actions":[{"type":{"value":"PlatformBehavior::SimulateUpKey"},"parameters":["Object","PlatformerCharacter"]},{"type":{"value":"PlatformBehavior::SimulateLadderKey"},"parameters":["Object","PlatformerCharacter"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"Gamepads::C_Button_pressed"},"parameters":["","GamepadIdentifier","\"Down\"","\"Left\""]}],"actions":[{"type":{"value":"PlatformBehavior::SimulateDownKey"},"parameters":["Object","PlatformerCharacter"]}]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"BooleanVariable"},"parameters":["UseLeftStick","True",""]}],"actions":[],"events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"Gamepads::C_Axis_pushed"},"parameters":["","GamepadIdentifier","\"Left\"","\"Left\"",""]}],"actions":[{"type":{"value":"PlatformBehavior::SimulateLeftKey"},"parameters":["Object","PlatformerCharacter"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"Gamepads::C_Axis_pushed"},"parameters":["","GamepadIdentifier","\"Left\"","\"Right\"",""]}],"actions":[{"type":{"value":"PlatformBehavior::SimulateRightKey"},"parameters":["Object","PlatformerCharacter"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"Gamepads::C_Axis_pushed"},"parameters":["","GamepadIdentifier","\"Left\"","\"Up\"",""]}],"actions":[{"type":{"value":"PlatformBehavior::SimulateUpKey"},"parameters":["Object","PlatformerCharacter"]},{"type":{"value":"PlatformBehavior::SimulateLadderKey"},"parameters":["Object","PlatformerCharacter"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"Gamepads::C_Axis_pushed"},"parameters":["","GamepadIdentifier","\"Left\"","\"Down\"",""]}],"actions":[{"type":{"value":"PlatformBehavior::SimulateDownKey"},"parameters":["Object","PlatformerCharacter"]}]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"BooleanVariable"},"parameters":["UseRightStick","True",""]}],"actions":[],"events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"Gamepads::C_Axis_pushed"},"parameters":["","GamepadIdentifier","\"Right\"","\"Left\"",""]}],"actions":[{"type":{"value":"PlatformBehavior::SimulateLeftKey"},"parameters":["Object","PlatformerCharacter"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"Gamepads::C_Axis_pushed"},"parameters":["","GamepadIdentifier","\"Right\"","\"Right\"",""]}],"actions":[{"type":{"value":"PlatformBehavior::SimulateRightKey"},"parameters":["Object","PlatformerCharacter"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"Gamepads::C_Axis_pushed"},"parameters":["","GamepadIdentifier","\"Right\"","\"Up\"",""]}],"actions":[{"type":{"value":"PlatformBehavior::SimulateUpKey"},"parameters":["Object","PlatformerCharacter"]},{"type":{"value":"PlatformBehavior::SimulateLadderKey"},"parameters":["Object","PlatformerCharacter"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"Gamepads::C_Axis_pushed"},"parameters":["","GamepadIdentifier","\"Right\"","\"Down\"",""]}],"actions":[{"type":{"value":"PlatformBehavior::SimulateDownKey"},"parameters":["Object","PlatformerCharacter"]}]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"StringVariable"},"parameters":["JumpButton","=","\"A or Cross\""]},{"type":{"value":"Gamepads::C_Button_pressed"},"parameters":["","GamepadIdentifier","\"A\"","\"Left\""]}],"actions":[{"type":{"value":"PlatformBehavior::SimulateJumpKey"},"parameters":["Object","PlatformerCharacter"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"StringVariable"},"parameters":["JumpButton","=","\"B or Circle\""]},{"type":{"value":"Gamepads::C_Button_pressed"},"parameters":["","GamepadIdentifier","\"B\"","\"Left\""]}],"actions":[{"type":{"value":"PlatformBehavior::SimulateJumpKey"},"parameters":["Object","PlatformerCharacter"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"StringVariable"},"parameters":["JumpButton","=","\"X or Square\""]},{"type":{"value":"Gamepads::C_Button_pressed"},"parameters":["","GamepadIdentifier","\"X\"","\"Left\""]}],"actions":[{"type":{"value":"PlatformBehavior::SimulateJumpKey"},"parameters":["Object","PlatformerCharacter"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"StringVariable"},"parameters":["JumpButton","=","\"Y or Triangle\""]},{"type":{"value":"Gamepads::C_Button_pressed"},"parameters":["","GamepadIdentifier","\"Y\"","\"Left\""]}],"actions":[{"type":{"value":"PlatformBehavior::SimulateJumpKey"},"parameters":["Object","PlatformerCharacter"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"StringVariable"},"parameters":["JumpButton","=","\"LB or L1\""]},{"type":{"value":"Gamepads::C_Button_pressed"},"parameters":["","GamepadIdentifier","\"LB\"","\"Left\""]}],"actions":[{"type":{"value":"PlatformBehavior::SimulateJumpKey"},"parameters":["Object","PlatformerCharacter"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"StringVariable"},"parameters":["JumpButton","=","\"RB or R1\""]},{"type":{"value":"Gamepads::C_Button_pressed"},"parameters":["","GamepadIdentifier","\"RB\"","\"Left\""]}],"actions":[{"type":{"value":"PlatformBehavior::SimulateJumpKey"},"parameters":["Object","PlatformerCharacter"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"StringVariable"},"parameters":["JumpButton","=","\"LT or L2\""]},{"type":{"value":"Gamepads::C_Button_pressed"},"parameters":["","GamepadIdentifier","\"LT\"","\"Left\""]}],"actions":[{"type":{"value":"PlatformBehavior::SimulateJumpKey"},"parameters":["Object","PlatformerCharacter"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"StringVariable"},"parameters":["JumpButton","=","\"RT or R2\""]},{"type":{"value":"Gamepads::C_Button_pressed"},"parameters":["","GamepadIdentifier","\"RT\"","\"Left\""]}],"actions":[{"type":{"value":"PlatformBehavior::SimulateJumpKey"},"parameters":["Object","PlatformerCharacter"]}]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"Gamepads::PlatformerGamepadMapper","type":"behavior"}],"objectGroups":[]}],"propertyDescriptors":[{"value":"","type":"Behavior","label":"Platformer character behavior","description":"","group":"","extraInformation":["PlatformBehavior::PlatformerObjectBehavior"],"name":"PlatformerCharacter"},{"value":"1","type":"Number","label":"Gamepad identifier (1, 2, 3 or 4)","description":"","group":"","extraInformation":[],"name":"GamepadIdentifier"},{"value":"true","type":"Boolean","label":"Use directional pad","description":"","group":"Controls","extraInformation":[],"name":"UseArrows"},{"value":"true","type":"Boolean","label":"Use left stick","description":"","group":"Controls","extraInformation":[],"name":"UseLeftStick"},{"value":"","type":"Boolean","label":"Use right stick","description":"","group":"Controls","extraInformation":[],"name":"UseRightStick"},{"value":"A or Cross","type":"Choice","label":"Jump button","description":"","group":"Controls","extraInformation":["A or Cross","B or Circle","X or Square","Y or Triangle","LB or L1","RB or R1","LT or L2","RT or R2"],"name":"JumpButton"}],"sharedPropertyDescriptors":[]},{"description":"Control a 3D physics character with a gamepad.","fullName":"3D platformer gamepad mapper","name":"Platformer3DGamepadMapper","objectType":"","eventsFunctions":[{"fullName":"","functionType":"Action","name":"doStepPreEvents","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"Gamepads::C_Controller_X_is_connected"},"parameters":["","GamepadIdentifier",""]}],"actions":[],"events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"Gamepads::StickForce"},"parameters":["",">","0","GamepadIdentifier","JoystickIdentifier",""]}],"actions":[{"type":{"value":"Physics3D::PhysicsCharacter3D::SetForwardAngle"},"parameters":["Object","PhysicsCharacter3D","=","Gamepads::StickAngle(GamepadIdentifier, JoystickIdentifier) + CameraAngle(Object.Layer())"]},{"type":{"value":"Physics3D::PhysicsCharacter3D::SimulateStick"},"parameters":["Object","PhysicsCharacter3D","-90","Gamepads::StickForce(GamepadIdentifier, JoystickIdentifier)"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"StringVariable"},"parameters":["JumpButton","=","\"A or Cross\""]},{"type":{"value":"Gamepads::C_Button_pressed"},"parameters":["","GamepadIdentifier","\"A\"","\"Left\""]}],"actions":[{"type":{"value":"Physics3D::PhysicsCharacter3D::SimulateJumpKey"},"parameters":["Object","PhysicsCharacter3D"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"StringVariable"},"parameters":["JumpButton","=","\"B or Circle\""]},{"type":{"value":"Gamepads::C_Button_pressed"},"parameters":["","GamepadIdentifier","\"B\"","\"Left\""]}],"actions":[{"type":{"value":"Physics3D::PhysicsCharacter3D::SimulateJumpKey"},"parameters":["Object","PhysicsCharacter3D"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"StringVariable"},"parameters":["JumpButton","=","\"X or Square\""]},{"type":{"value":"Gamepads::C_Button_pressed"},"parameters":["","GamepadIdentifier","\"X\"","\"Left\""]}],"actions":[{"type":{"value":"Physics3D::PhysicsCharacter3D::SimulateJumpKey"},"parameters":["Object","PhysicsCharacter3D"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"StringVariable"},"parameters":["JumpButton","=","\"Y or Triangle\""]},{"type":{"value":"Gamepads::C_Button_pressed"},"parameters":["","GamepadIdentifier","\"Y\"","\"Left\""]}],"actions":[{"type":{"value":"Physics3D::PhysicsCharacter3D::SimulateJumpKey"},"parameters":["Object","PhysicsCharacter3D"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"StringVariable"},"parameters":["JumpButton","=","\"LB or L1\""]},{"type":{"value":"Gamepads::C_Button_pressed"},"parameters":["","GamepadIdentifier","\"LB\"","\"Left\""]}],"actions":[{"type":{"value":"Physics3D::PhysicsCharacter3D::SimulateJumpKey"},"parameters":["Object","PhysicsCharacter3D"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"StringVariable"},"parameters":["JumpButton","=","\"RB or R1\""]},{"type":{"value":"Gamepads::C_Button_pressed"},"parameters":["","GamepadIdentifier","\"RB\"","\"Left\""]}],"actions":[{"type":{"value":"Physics3D::PhysicsCharacter3D::SimulateJumpKey"},"parameters":["Object","PhysicsCharacter3D"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"StringVariable"},"parameters":["JumpButton","=","\"LT or L2\""]},{"type":{"value":"Gamepads::C_Button_pressed"},"parameters":["","GamepadIdentifier","\"LT\"","\"Left\""]}],"actions":[{"type":{"value":"Physics3D::PhysicsCharacter3D::SimulateJumpKey"},"parameters":["Object","PhysicsCharacter3D"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"StringVariable"},"parameters":["JumpButton","=","\"RT or R2\""]},{"type":{"value":"Gamepads::C_Button_pressed"},"parameters":["","GamepadIdentifier","\"RT\"","\"Left\""]}],"actions":[{"type":{"value":"Physics3D::PhysicsCharacter3D::SimulateJumpKey"},"parameters":["Object","PhysicsCharacter3D"]}]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"Gamepads::Platformer3DGamepadMapper","type":"behavior"}],"objectGroups":[]}],"propertyDescriptors":[{"value":"","type":"Behavior","label":"3D physics character","description":"","group":"","extraInformation":["Physics3D::PhysicsCharacter3D"],"name":"PhysicsCharacter3D"},{"value":"1","type":"Number","label":"Gamepad identifier (1, 2, 3 or 4)","description":"","group":"","extraInformation":[],"name":"GamepadIdentifier"},{"value":"Left","type":"Choice","label":"Walk joystick","description":"","group":"Controls","extraInformation":["Left","Right"],"name":"JoystickIdentifier"},{"value":"A or Cross","type":"Choice","label":"Jump button","description":"","group":"Controls","extraInformation":["A or Cross","B or Circle","X or Square","Y or Triangle","LB or L1","RB or R1","LT or L2","RT or R2"],"name":"JumpButton"}],"sharedPropertyDescriptors":[]},{"description":"Control a 3D physics character with a gamepad.","fullName":"3D shooter gamepad mapper","name":"Shooter3DGamepadMapper","objectType":"","eventsFunctions":[{"fullName":"","functionType":"Action","name":"doStepPreEvents","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"Gamepads::C_Controller_X_is_connected"},"parameters":["","GamepadIdentifier",""]}],"actions":[],"events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"Gamepads::StickForce"},"parameters":["",">","0","GamepadIdentifier","WalkStick",""]}],"actions":[{"type":{"value":"Physics3D::PhysicsCharacter3D::SimulateStick"},"parameters":["Object","PhysicsCharacter3D","Gamepads::StickAngle(GamepadIdentifier, WalkStick)","Gamepads::StickForce(GamepadIdentifier, WalkStick)"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"StringVariable"},"parameters":["JumpButton","=","\"A or Cross\""]},{"type":{"value":"Gamepads::C_Button_pressed"},"parameters":["","GamepadIdentifier","\"A\"","\"Left\""]}],"actions":[{"type":{"value":"Physics3D::PhysicsCharacter3D::SimulateJumpKey"},"parameters":["Object","PhysicsCharacter3D"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"StringVariable"},"parameters":["JumpButton","=","\"B or Circle\""]},{"type":{"value":"Gamepads::C_Button_pressed"},"parameters":["","GamepadIdentifier","\"B\"","\"Left\""]}],"actions":[{"type":{"value":"Physics3D::PhysicsCharacter3D::SimulateJumpKey"},"parameters":["Object","PhysicsCharacter3D"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"StringVariable"},"parameters":["JumpButton","=","\"X or Square\""]},{"type":{"value":"Gamepads::C_Button_pressed"},"parameters":["","GamepadIdentifier","\"X\"","\"Left\""]}],"actions":[{"type":{"value":"Physics3D::PhysicsCharacter3D::SimulateJumpKey"},"parameters":["Object","PhysicsCharacter3D"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"StringVariable"},"parameters":["JumpButton","=","\"Y or Triangle\""]},{"type":{"value":"Gamepads::C_Button_pressed"},"parameters":["","GamepadIdentifier","\"Y\"","\"Left\""]}],"actions":[{"type":{"value":"Physics3D::PhysicsCharacter3D::SimulateJumpKey"},"parameters":["Object","PhysicsCharacter3D"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"StringVariable"},"parameters":["JumpButton","=","\"LB or L1\""]},{"type":{"value":"Gamepads::C_Button_pressed"},"parameters":["","GamepadIdentifier","\"LB\"","\"Left\""]}],"actions":[{"type":{"value":"Physics3D::PhysicsCharacter3D::SimulateJumpKey"},"parameters":["Object","PhysicsCharacter3D"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"StringVariable"},"parameters":["JumpButton","=","\"RB or R1\""]},{"type":{"value":"Gamepads::C_Button_pressed"},"parameters":["","GamepadIdentifier","\"RB\"","\"Left\""]}],"actions":[{"type":{"value":"Physics3D::PhysicsCharacter3D::SimulateJumpKey"},"parameters":["Object","PhysicsCharacter3D"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"StringVariable"},"parameters":["JumpButton","=","\"LT or L2\""]},{"type":{"value":"Gamepads::C_Button_pressed"},"parameters":["","GamepadIdentifier","\"LT\"","\"Left\""]}],"actions":[{"type":{"value":"Physics3D::PhysicsCharacter3D::SimulateJumpKey"},"parameters":["Object","PhysicsCharacter3D"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"StringVariable"},"parameters":["JumpButton","=","\"RT or R2\""]},{"type":{"value":"Gamepads::C_Button_pressed"},"parameters":["","GamepadIdentifier","\"RT\"","\"Left\""]}],"actions":[{"type":{"value":"Physics3D::PhysicsCharacter3D::SimulateJumpKey"},"parameters":["Object","PhysicsCharacter3D"]}]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"Gamepads::Shooter3DGamepadMapper","type":"behavior"}],"objectGroups":[]}],"propertyDescriptors":[{"value":"","type":"Behavior","label":"3D physics character","description":"","group":"","extraInformation":["Physics3D::PhysicsCharacter3D"],"name":"PhysicsCharacter3D"},{"value":"1","type":"Number","label":"Gamepad identifier (1, 2, 3 or 4)","description":"","group":"","extraInformation":[],"name":"GamepadIdentifier"},{"value":"Left","type":"Choice","label":"Walk joystick","description":"","group":"Controls","extraInformation":["Left","Right"],"name":"WalkStick"},{"value":"Right","type":"Choice","label":"Camera joystick","description":"","group":"Controls","extraInformation":["Left","Right"],"name":"CameraStick"},{"value":"A or Cross","type":"Choice","label":"Jump button","description":"","group":"Controls","extraInformation":["A or Cross","B or Circle","X or Square","Y or Triangle","LB or L1","RB or R1","LT or L2","RT or R2"],"name":"JumpButton"}],"sharedPropertyDescriptors":[]},{"description":"Control camera rotations with a gamepad.","fullName":"First person camera gamepad mapper","name":"FirstPersonGamepadMapper","objectType":"","eventsFunctions":[{"fullName":"","functionType":"Action","name":"doStepPreEvents","sentence":"","events":[{"type":"BuiltinCommonInstructions::Comment","color":{"b":109,"g":230,"r":255,"textB":0,"textG":0,"textR":0},"comment":"TODO It's probably a bad idea to rotate the object around Y."},{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetNumberVariable"},"parameters":["CurrentRotationSpeedZ","=","Gamepads::AcceleratedSpeed(CurrentRotationSpeedZ, Gamepads::StickForceX(GamepadIdentifier, CameraStick) * HorizontalRotationSpeedMax, HorizontalRotationSpeedMax, HorizontalRotationAcceleration, HorizontalRotationDeceleration)"]},{"type":{"value":"SetAngle"},"parameters":["Object","+","CurrentRotationSpeedZ * TimeDelta()"]},{"type":{"value":"SetNumberVariable"},"parameters":["CurrentRotationSpeedY","=","Gamepads::AcceleratedSpeed(CurrentRotationSpeedY, Gamepads::StickForceY(GamepadIdentifier, CameraStick) * VerticalRotationSpeedMax, VerticalRotationSpeedMax, VerticalRotationAcceleration, VerticalRotationDeceleration)"]},{"type":{"value":"Scene3D::Base3DBehavior::SetRotationY"},"parameters":["Object","Object3D","+","CurrentRotationSpeedY * TimeDelta()"]},{"type":{"value":"Scene3D::Base3DBehavior::SetRotationY"},"parameters":["Object","Object3D","=","clamp(Object.Object3D::RotationY(), VerticalAngleMin, VerticalAngleMax)"]},{"type":{"value":"Gamepads::FirstPersonGamepadMapper::LookFromObjectEyes"},"parameters":["Object","Behavior",""]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"Gamepads::FirstPersonGamepadMapper","type":"behavior"}],"objectGroups":[]},{"description":"Move the camera to look though _PARAM1_ eyes. The object must look to the right when all its angles are 0 and the top of its head be toward Z+.","fullName":"Look through object eyes","functionType":"Action","group":"Layers and cameras","name":"LookFromObjectEyes","private":true,"sentence":"Move the camera to look though _PARAM0_ eyes","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"CentreCamera"},"parameters":["","Object","","Object.Layer()",""]},{"type":{"value":"Scene3D::SetCameraZ"},"parameters":["","=","Object.Object3D::Z() + Object.Object3D::Depth() + OffsetZ","",""]},{"type":{"value":"Scene3D::SetCameraRotationX"},"parameters":["","=","- Object.Object3D::RotationY() + 90","GetArgumentAsString(\"Layer\")",""]},{"type":{"value":"Scene3D::SetCameraRotationY"},"parameters":["","=","Object.Object3D::RotationX()","GetArgumentAsString(\"Layer\")",""]},{"type":{"value":"SetCameraAngle"},"parameters":["","=","Object.Angle() + 90","Object.Layer()",""]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"Gamepads::FirstPersonGamepadMapper","type":"behavior"}],"objectGroups":[]},{"description":"the maximum horizontal rotation speed of the object.","fullName":"Maximum horizontal rotation speed","functionType":"ExpressionAndCondition","group":"First person camera gamepad mapper horizontal rotation configuration","name":"HorizontalRotationSpeedMax","sentence":"the maximum horizontal rotation speed","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["HorizontalRotationSpeedMax"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"Gamepads::FirstPersonGamepadMapper","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"ActionWithOperator","getterName":"HorizontalRotationSpeedMax","name":"SetHorizontalRotationSpeedMax","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetNumberVariable"},"parameters":["HorizontalRotationSpeedMax","=","Value"]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"Gamepads::FirstPersonGamepadMapper","type":"behavior"}],"objectGroups":[]},{"description":"the horizontal rotation acceleration of the object.","fullName":"Horizontal rotation acceleration","functionType":"ExpressionAndCondition","group":"First person camera gamepad mapper horizontal rotation configuration","name":"HorizontalRotationAcceleration","sentence":"the horizontal rotation acceleration","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["HorizontalRotationAcceleration"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"Gamepads::FirstPersonGamepadMapper","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"ActionWithOperator","getterName":"HorizontalRotationAcceleration","name":"SetHorizontalRotationAcceleration","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetNumberVariable"},"parameters":["HorizontalRotationAcceleration","=","Value"]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"Gamepads::FirstPersonGamepadMapper","type":"behavior"}],"objectGroups":[]},{"description":"the horizontal rotation deceleration of the object.","fullName":"Horizontal rotation deceleration","functionType":"ExpressionAndCondition","group":"First person camera gamepad mapper horizontal rotation configuration","name":"HorizontalRotationDeceleration","sentence":"the horizontal rotation deceleration","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["HorizontalRotationDeceleration"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"Gamepads::FirstPersonGamepadMapper","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"ActionWithOperator","getterName":"HorizontalRotationDeceleration","name":"SetHorizontalRotationDeceleration","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetNumberVariable"},"parameters":["HorizontalRotationDeceleration","=","Value"]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"Gamepads::FirstPersonGamepadMapper","type":"behavior"}],"objectGroups":[]},{"description":"the maximum vertical rotation speed of the object.","fullName":"Maximum vertical rotation speed","functionType":"ExpressionAndCondition","group":"First person camera gamepad mapper vertical rotation configuration","name":"VerticalRotationSpeedMax","sentence":"the maximum vertical rotation speed","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["VerticalRotationSpeedMax"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"Gamepads::FirstPersonGamepadMapper","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"ActionWithOperator","getterName":"VerticalRotationSpeedMax","name":"SetVerticalRotationSpeedMax","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetNumberVariable"},"parameters":["VerticalRotationSpeedMax","=","Value"]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"Gamepads::FirstPersonGamepadMapper","type":"behavior"}],"objectGroups":[]},{"description":"the vertical rotation acceleration of the object.","fullName":"Vertical rotation acceleration","functionType":"ExpressionAndCondition","group":"First person camera gamepad mapper vertical rotation configuration","name":"VerticalRotationAcceleration","sentence":"the vertical rotation acceleration","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["VerticalRotationAcceleration"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"Gamepads::FirstPersonGamepadMapper","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"ActionWithOperator","getterName":"VerticalRotationAcceleration","name":"SetVerticalRotationAcceleration","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetNumberVariable"},"parameters":["VerticalRotationAcceleration","=","Value"]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"Gamepads::FirstPersonGamepadMapper","type":"behavior"}],"objectGroups":[]},{"description":"the vertical rotation deceleration of the object.","fullName":"Vertical rotation deceleration","functionType":"ExpressionAndCondition","group":"First person camera gamepad mapper vertical rotation configuration","name":"VerticalRotationDeceleration","sentence":"the vertical rotation deceleration","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["VerticalRotationDeceleration"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"Gamepads::FirstPersonGamepadMapper","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"ActionWithOperator","getterName":"VerticalRotationDeceleration","name":"SetVerticalRotationDeceleration","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetNumberVariable"},"parameters":["VerticalRotationDeceleration","=","Value"]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"Gamepads::FirstPersonGamepadMapper","type":"behavior"}],"objectGroups":[]},{"description":"the minimum vertical camera angle of the object.","fullName":"Minimum vertical camera angle","functionType":"ExpressionAndCondition","group":"First person camera gamepad mapper vertical rotation configuration","name":"VerticalAngleMin","sentence":"the minimum vertical camera angle","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["VerticalAngleMin"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"Gamepads::FirstPersonGamepadMapper","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"ActionWithOperator","getterName":"VerticalAngleMin","name":"SetVerticalAngleMin","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetNumberVariable"},"parameters":["VerticalAngleMin","=","Value"]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"Gamepads::FirstPersonGamepadMapper","type":"behavior"}],"objectGroups":[]},{"description":"the maximum vertical camera angle of the object.","fullName":"Maximum vertical camera angle","functionType":"ExpressionAndCondition","group":"First person camera gamepad mapper vertical rotation configuration","name":"VerticalAngleMax","sentence":"the maximum vertical camera angle","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["VerticalAngleMax"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"Gamepads::FirstPersonGamepadMapper","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"ActionWithOperator","getterName":"VerticalAngleMax","name":"SetVerticalAngleMax","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetNumberVariable"},"parameters":["VerticalAngleMax","=","Value"]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"Gamepads::FirstPersonGamepadMapper","type":"behavior"}],"objectGroups":[]},{"description":"the z position offset of the object.","fullName":"Z position offset","functionType":"ExpressionAndCondition","group":"First person camera gamepad mapper position configuration","name":"OffsetZ","sentence":"the z position offset","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["OffsetZ"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"Gamepads::FirstPersonGamepadMapper","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"ActionWithOperator","getterName":"OffsetZ","name":"SetOffsetZ","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetNumberVariable"},"parameters":["OffsetZ","=","Value"]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"Gamepads::FirstPersonGamepadMapper","type":"behavior"}],"objectGroups":[]}],"propertyDescriptors":[{"value":"","type":"Behavior","label":"3D capability","description":"","group":"","extraInformation":["Scene3D::Base3DBehavior"],"name":"Object3D"},{"value":"1","type":"Number","label":"Gamepad identifier (1, 2, 3 or 4)","description":"","group":"","extraInformation":[],"name":"GamepadIdentifier"},{"value":"Right","type":"Choice","label":"Camera joystick","description":"","group":"","extraInformation":["Left","Right"],"name":"CameraStick"},{"value":"180","type":"Number","unit":"AngularSpeed","label":"Maximum rotation speed","description":"","group":"Horizontal rotation","extraInformation":[],"name":"HorizontalRotationSpeedMax"},{"value":"360","type":"Number","label":"Rotation acceleration","description":"","group":"Horizontal rotation","extraInformation":[],"name":"HorizontalRotationAcceleration"},{"value":"720","type":"Number","label":"Rotation deceleration","description":"","group":"Horizontal rotation","extraInformation":[],"name":"HorizontalRotationDeceleration"},{"value":"120","type":"Number","unit":"AngularSpeed","label":"Maximum rotation speed","description":"","group":"Vertical rotation","extraInformation":[],"name":"VerticalRotationSpeedMax"},{"value":"240","type":"Number","label":"Rotation acceleration","description":"","group":"Vertical rotation","extraInformation":[],"name":"VerticalRotationAcceleration"},{"value":"480","type":"Number","label":"Rotation deceleration","description":"","group":"Vertical rotation","extraInformation":[],"name":"VerticalRotationDeceleration"},{"value":"-90","type":"Number","unit":"DegreeAngle","label":"Minimum angle","description":"","group":"Vertical rotation","extraInformation":[],"name":"VerticalAngleMin"},{"value":"90","type":"Number","unit":"DegreeAngle","label":"Maximum angle","description":"","group":"Vertical rotation","extraInformation":[],"name":"VerticalAngleMax"},{"value":"0","type":"Number","unit":"Pixel","label":"Z position offset","description":"","group":"Position","extraInformation":[],"name":"OffsetZ"},{"value":"0","type":"Number","unit":"AngularSpeed","label":"Current rotation speed Z","description":"","group":"","extraInformation":[],"hidden":true,"name":"CurrentRotationSpeedZ"},{"value":"0","type":"Number","unit":"AngularSpeed","label":"Current rotation speed Y","description":"","group":"","extraInformation":[],"hidden":true,"name":"CurrentRotationSpeedY"}],"sharedPropertyDescriptors":[]},{"description":"Control a top-down character with a gamepad.","fullName":"Top-down gamepad mapper","name":"TopDownGamepadMapper","objectType":"","eventsFunctions":[{"fullName":"","functionType":"Action","name":"doStepPreEvents","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"Gamepads::C_Controller_X_is_connected"},"parameters":["","GamepadIdentifier",""]}],"actions":[],"events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"BooleanVariable"},"parameters":["UseArrows","True",""]}],"actions":[],"events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"Gamepads::C_Button_pressed"},"parameters":["","GamepadIdentifier","\"Left\"","\"Left\""]}],"actions":[{"type":{"value":"TopDownMovementBehavior::SimulateLeftKey"},"parameters":["Object","TopDownMovement"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"Gamepads::C_Button_pressed"},"parameters":["","GamepadIdentifier","\"Right\"","\"Left\""]}],"actions":[{"type":{"value":"TopDownMovementBehavior::SimulateRightKey"},"parameters":["Object","TopDownMovement"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"Gamepads::C_Button_pressed"},"parameters":["","GamepadIdentifier","\"Up\"","\"Left\""]}],"actions":[{"type":{"value":"TopDownMovementBehavior::SimulateUpKey"},"parameters":["Object","TopDownMovement"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"Gamepads::C_Button_pressed"},"parameters":["","GamepadIdentifier","\"Down\"","\"Left\""]}],"actions":[{"type":{"value":"TopDownMovementBehavior::SimulateDownKey"},"parameters":["Object","TopDownMovement"]}]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"BooleanVariable"},"parameters":["UseLeftStick","True",""]}],"actions":[],"events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"StringVariable"},"parameters":["StickMode","=","\"Analog\""]}],"actions":[{"type":{"value":"TopDownMovementBehavior::SimulateStick"},"parameters":["Object","TopDownMovement","Gamepads::StickRotationValue(GamepadIdentifier, \"Left\")","Gamepads::StickForce(GamepadIdentifier, \"Left\")"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"StringVariable"},"parameters":["StickMode","=","\"360°\""]}],"actions":[{"type":{"value":"TopDownMovementBehavior::SimulateStick"},"parameters":["Object","TopDownMovement","Gamepads::StickRotationValue(GamepadIdentifier, \"Left\")","sign(Gamepads::StickForce(GamepadIdentifier, \"Left\"))"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"StringVariable"},"parameters":["StickMode","=","\"8 Directions\""]}],"actions":[],"events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"Gamepads::C_Axis_pushed"},"parameters":["","GamepadIdentifier","\"Left\"","\"Left\"",""]}],"actions":[{"type":{"value":"TopDownMovementBehavior::SimulateLeftKey"},"parameters":["Object","TopDownMovement"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"Gamepads::C_Axis_pushed"},"parameters":["","GamepadIdentifier","\"Left\"","\"Right\"",""]}],"actions":[{"type":{"value":"TopDownMovementBehavior::SimulateRightKey"},"parameters":["Object","TopDownMovement"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"Gamepads::C_Axis_pushed"},"parameters":["","GamepadIdentifier","\"Left\"","\"Up\"",""]}],"actions":[{"type":{"value":"TopDownMovementBehavior::SimulateUpKey"},"parameters":["Object","TopDownMovement"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"Gamepads::C_Axis_pushed"},"parameters":["","GamepadIdentifier","\"Left\"","\"Down\"",""]}],"actions":[{"type":{"value":"TopDownMovementBehavior::SimulateDownKey"},"parameters":["Object","TopDownMovement"]}]}]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"BooleanVariable"},"parameters":["UseRightStick","True",""]}],"actions":[],"events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"StringVariable"},"parameters":["StickMode","=","\"Analog\""]}],"actions":[{"type":{"value":"TopDownMovementBehavior::SimulateStick"},"parameters":["Object","TopDownMovement","Gamepads::StickRotationValue(GamepadIdentifier, \"Right\")","Gamepads::StickForce(GamepadIdentifier, \"Right\")"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"StringVariable"},"parameters":["StickMode","=","\"360°\""]}],"actions":[{"type":{"value":"TopDownMovementBehavior::SimulateStick"},"parameters":["Object","TopDownMovement","sign(Gamepads::StickForce(GamepadIdentifier, \"Right\"))","1"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"StringVariable"},"parameters":["StickMode","=","\"8 Directions\""]}],"actions":[],"events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"Gamepads::C_Axis_pushed"},"parameters":["","GamepadIdentifier","\"Right\"","\"Left\"",""]}],"actions":[{"type":{"value":"TopDownMovementBehavior::SimulateLeftKey"},"parameters":["Object","TopDownMovement"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"Gamepads::C_Axis_pushed"},"parameters":["","GamepadIdentifier","\"Right\"","\"Right\"",""]}],"actions":[{"type":{"value":"TopDownMovementBehavior::SimulateRightKey"},"parameters":["Object","TopDownMovement"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"Gamepads::C_Axis_pushed"},"parameters":["","GamepadIdentifier","\"Right\"","\"Up\"",""]}],"actions":[{"type":{"value":"TopDownMovementBehavior::SimulateUpKey"},"parameters":["Object","TopDownMovement"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"Gamepads::C_Axis_pushed"},"parameters":["","GamepadIdentifier","\"Right\"","\"Down\"",""]}],"actions":[{"type":{"value":"TopDownMovementBehavior::SimulateDownKey"},"parameters":["Object","TopDownMovement"]}]}]}]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"Gamepads::TopDownGamepadMapper","type":"behavior"}],"objectGroups":[]}],"propertyDescriptors":[{"value":"","type":"Behavior","label":"Top-down movement behavior","description":"","group":"","extraInformation":["TopDownMovementBehavior::TopDownMovementBehavior"],"name":"TopDownMovement"},{"value":"1","type":"Number","label":"Gamepad identifier (1, 2, 3 or 4)","description":"","group":"","extraInformation":[],"name":"GamepadIdentifier"},{"value":"true","type":"Boolean","label":"Use directional pad","description":"","group":"Controls","extraInformation":[],"name":"UseArrows"},{"value":"true","type":"Boolean","label":"Use left stick","description":"","group":"Controls","extraInformation":[],"name":"UseLeftStick"},{"value":"","type":"Boolean","label":"Use right stick","description":"","group":"Controls","extraInformation":[],"name":"UseRightStick"},{"value":"Analog","type":"Choice","label":"Stick mode","description":"","group":"Controls","extraInformation":["Analog","360°","8 Directions"],"name":"StickMode"}],"sharedPropertyDescriptors":[]}],"eventsBasedObjects":[]},{"author":"@Bouh, @arthuro555","category":"User interface","extensionNamespace":"","fullName":"Cursor type","gdevelopVersion":">=5.5.222","helpPath":"","iconUrl":"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0ibWRpLWN1cnNvci1kZWZhdWx0LW91dGxpbmUiIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBkPSJNMTAuMDcsMTQuMjdDMTAuNTcsMTQuMDMgMTEuMTYsMTQuMjUgMTEuNCwxNC43NUwxMy43LDE5Ljc0TDE1LjUsMTguODlMMTMuMTksMTMuOTFDMTIuOTUsMTMuNDEgMTMuMTcsMTIuODEgMTMuNjcsMTIuNThMMTMuOTUsMTIuNUwxNi4yNSwxMi4wNUw4LDUuMTJWMTUuOUw5LjgyLDE0LjQzTDEwLjA3LDE0LjI3TTEzLjY0LDIxLjk3QzEzLjE0LDIyLjIxIDEyLjU0LDIyIDEyLjMxLDIxLjVMMTAuMTMsMTYuNzZMNy42MiwxOC43OEM3LjQ1LDE4LjkyIDcuMjQsMTkgNywxOUExLDEgMCAwLDEgNiwxOFYzQTEsMSAwIDAsMSA3LDJDNy4yNCwyIDcuNDcsMi4wOSA3LjY0LDIuMjNMNy42NSwyLjIyTDE5LjE0LDExLjg2QzE5LjU3LDEyLjIyIDE5LjYyLDEyLjg1IDE5LjI3LDEzLjI3QzE5LjEyLDEzLjQ1IDE4LjkxLDEzLjU3IDE4LjcsMTMuNjFMMTUuNTQsMTQuMjNMMTcuNzQsMTguOTZDMTgsMTkuNDYgMTcuNzYsMjAuMDUgMTcuMjYsMjAuMjhMMTMuNjQsMjEuOTdaIiAvPjwvc3ZnPg==","name":"CursorType","previewIconUrl":"https://resources.gdevelop-app.com/assets/Icons/cursor-default-outline.svg","shortDescription":"Provides an action to change the type of the cursor, and a behavior to change the cursor when an object is hovered.","version":"0.0.8","description":["Provides an action to change the type of the cursor, and a behavior to change the cursor when an object is hovered.","","Find the list of cursors here: https://developer.mozilla.org/en-US/docs/Web/CSS/cursor"],"origin":{"identifier":"CursorType","name":"gdevelop-extension-store"},"tags":["mouse","cursor","pointer","javascript","desktop"],"authorIds":["ZgrsWuRTAkXgeuPV9bo0zuEcA2w1","2OwwM8ToR9dx9RJ2sAKTcrLmCB92"],"dependencies":[],"globalVariables":[{"name":"ZOrderSorting","type":"number","value":0.0}],"sceneVariables":[{"name":"DefaultCursor","type":"string","value":"default"}],"eventsFunctions":[{"description":"Change the type of the cursor.","fullName":"Cursor type","functionType":"Action","name":"ChangeCursorType","sentence":"Change the cursor to _PARAM1_","events":[{"type":"BuiltinCommonInstructions::Comment","color":{"b":109,"g":230,"r":255,"textB":0,"textG":0,"textR":0},"comment":"Set as variable instead of directly setting as a CursorHover behavior can override it.\nBy using a variable, we ensure to be able to change it back to that \"default\" after the override is over."},{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetStringVariable"},"parameters":["DefaultCursor","=","CursorType"]},{"type":{"value":"CursorType::DoChangeCursorType"},"parameters":["","CursorType",""]}]}],"parameters":[{"defaultValue":"default","description":"The new cursor type","longDescription":"List of available cursors on https://developer.mozilla.org/en-US/docs/Web/CSS/cursor","name":"CursorType","supplementaryInformation":"[\"auto\",\"default\",\"none\",\"context-menu\",\"help\",\"pointer\",\"progress\",\"wait\",\"cell\",\"crosshair\",\"text\",\"vertical-text\",\"alias\",\"copy\",\"move\",\"no-drop\",\"not-allowed\",\"grab\",\"grabbing\",\"all-scroll\",\"col-resize\",\"row-resize\",\"n-resize\",\"e-resize\",\"s-resize\",\"w-resize\",\"ne-resize\",\"nw-resize\",\"se-resize\",\"sw-resize\",\"ew-resize\",\"ns-resize\",\"nwse-resize\",\"zoom-in\",\"zoom-out\"]","type":"stringWithSelector"}],"objectGroups":[]},{"description":"Do change the type of the cursor.","fullName":"Do change cursor type","functionType":"Action","name":"DoChangeCursorType","private":true,"sentence":"Do change the cursor to _PARAM1_","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["const cursorType = eventsFunctionContext.getArgument(\"CursorType\");","","runtimeScene.getGame().getRenderer().getCanvas().style.cursor = cursorType;",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":false}],"parameters":[{"description":"The new cursor type","name":"CursorType","supplementaryInformation":"[]","type":"string"}],"objectGroups":[]},{"fullName":"","functionType":"Action","name":"onScenePreEvents","sentence":"","events":[{"type":"BuiltinCommonInstructions::Comment","color":{"b":109,"g":230,"r":255,"textB":0,"textG":0,"textR":0},"comment":"Reset ordering as the object with highest Z-Order might not exist anymore or be not be hovered anymore."},{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetNumberVariable"},"parameters":["ZOrderSorting","=","0"]},{"type":{"value":"CursorType::DoChangeCursorType"},"parameters":["","DefaultCursor",""]}]}],"parameters":[],"objectGroups":[]}],"eventsBasedBehaviors":[{"description":"Change the cursor appearence when the object is hovered (on Windows, macOS or Linux).","fullName":"Custom cursor when hovered","name":"CursorHover","objectType":"","eventsFunctions":[{"fullName":"","functionType":"Action","name":"doStepPostEvents","sentence":"","events":[{"type":"BuiltinCommonInstructions::Comment","color":{"b":109,"g":230,"r":255,"textB":0,"textG":0,"textR":0},"comment":"Check the z Order to ensure the cursor shown is the one from the foremost object "},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"Plan"},"parameters":["Object",">","ZOrderSorting"]},{"type":{"value":"SourisSurObjet"},"parameters":["Object","","",""]}],"actions":[{"type":{"value":"SetNumberVariable"},"parameters":["ZOrderSorting","=","Object.ZOrder()"]},{"type":{"value":"CursorType::DoChangeCursorType"},"parameters":["","CursorType",""]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"CursorType::CursorHover","type":"behavior"}],"objectGroups":[]}],"propertyDescriptors":[{"value":"default","type":"Choice","label":"The cursor type","description":"See https://developer.mozilla.org/en-US/docs/Web/CSS/cursor for a list of possible cursors.","group":"","extraInformation":["auto","default","none","context-menu","help","pointer","progress","wait","cell","crosshair","text","vertical-text","alias","copy","move","no-drop","not-allowed","grab","grabbing","all-scroll","col-resize","row-resize","n-resize","e-resize","s-resize","w-resize","ne-resize","nw-resize","se-resize","sw-resize","ew-resize","ns-resize","nwse-resize","zoom-in","zoom-out"],"name":"CursorType"}],"sharedPropertyDescriptors":[]}],"eventsBasedObjects":[]},{"author":"PANDAKO-GitHub","category":"Input","extensionNamespace":"","fullName":"Mouse Pointer Lock","gdevelopVersion":">=5.5.222","helpPath":"","iconUrl":"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAyMy4wLjMsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT4NCjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iSWNvbnMiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4Ig0KCSB2aWV3Qm94PSIwIDAgMzIgMzIiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDMyIDMyOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+DQo8c3R5bGUgdHlwZT0idGV4dC9jc3MiPg0KCS5zdDB7ZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyO3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDoxMDt9DQo8L3N0eWxlPg0KPHBvbHlsaW5lIGNsYXNzPSJzdDAiIHBvaW50cz0iMTksMTkgMjQsMTkgMjQsMjQgIi8+DQo8cG9seWxpbmUgY2xhc3M9InN0MCIgcG9pbnRzPSI2LDIzIDExLDIzIDExLDE4ICIvPg0KPHBhdGggY2xhc3M9InN0MCIgZD0iTTI0LDE5LjRjLTAuNywwLjgtMS40LDEuNi0yLjIsMi40Yy03LDctMTUuMywxMC4yLTE4LjUsN3MtMC4xLTExLjUsNy0xOC41czE1LjMtMTAuMiwxOC41LTcNCgljMS40LDEuNCwxLjYsMy42LDAuOCw2LjMiLz4NCjxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik0xMSwyMi41Yy0wLjMtMC4yLTAuNS0wLjUtMC44LTAuOGMtNy03LTEwLjItMTUuMy03LTE4LjVzMTEuNS0wLjEsMTguNSw3czEwLjIsMTUuMyw3LDE4LjUNCgljLTEuNywxLjctNC44LDEuNi04LjQsMC4xIi8+DQo8L3N2Zz4NCg==","name":"MousePointerLock","previewIconUrl":"https://resources.gdevelop-app.com/assets/Icons/Line Hero Pack/Master/SVG/Virtual Reality/Virtual Reality_360_rotate_vr_movement.svg","shortDescription":"This behavior removes the limit on the distance the mouse can move and hides the cursor.","version":"0.3.0","description":["This behavior removes the limit on the distance the mouse can move and hides the cursor.","","For example, a user can rotate or continue to manipulate an object by moving the mouse endlessly ([open the project online](https://editor.gdevelop.io/?project=example://mouse-pointer-lock)).","Without the pointer lock, the rotation or operation will stop the moment the pointer reaches the edge of the browser or screen.","","Game players don't have to worry about leaving the gameplay area or accidentally clicking on another application that moves the mouse focus away from the game.","","Locking the pointer locks `CursorX()` and `CursorY()` expressions.","Use `MovementX()` and `MovementY()` instead.",""],"origin":{"identifier":"MousePointerLock","name":"gdevelop-extension-store"},"tags":["mouse","lock","cursor","pointer"],"authorIds":["Zu55H5hcb9YmZTltIVOTAFDJQyB2","IWykYNRvhCZBN3vEgKEbBPOR3Oc2"],"dependencies":[],"globalVariables":[],"sceneVariables":[{"name":"TouchId","type":"number","value":-1.0},{"name":"OldX","type":"number","value":0.0},{"name":"OldY","type":"number","value":0.0},{"name":"TouchSpeedFactor","type":"number","value":4.0}],"eventsFunctions":[{"fullName":"","functionType":"Action","name":"onFirstSceneLoaded","sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["class PointerLockHandler {","    movementX = 0;","    movementY = 0;","    retried = false;","    /**","     * @type {gdjs.RuntimeGame}","     */","    game;","","    /**","     * @param {gdjs.RuntimeGame} game","     */","    constructor(game) {","        this.game = game;","        const canvas = game.getRenderer().getCanvas();","","        canvas.addEventListener(\"pointermove\", event => {","            if (!!document.pointerLockElement) {","                this.movementX += event.movementX || 0;","                this.movementY += event.movementY || 0;","            }","        }, false);","","        document.addEventListener(\"pointerlockerror\", event => {","            if (!this.retried) {","                canvas.requestPointerLock();","                this.retried = true;","            }","        });","    }","","    requestPointerLock() {","        const canvas = this.game.getRenderer().getCanvas();","        if (canvas.requestPointerLock && !document.pointerLockElement) {","            this.retried = false;","            canvas.requestPointerLock({ unadjustedMovement: true });","        }","    }","","    exitPointerLock() {","        if (document.exitPointerLock) {","            document.exitPointerLock();","        }","    }","","    isPointerLocked() {","        return !!document.pointerLockElement;","    }","","    resetMovement() {","        this.movementX = 0;","        this.movementY = 0;","    }","};","","gdjs._MousePointerLockExtension = { handler: new PointerLockHandler(runtimeScene.getGame()) };",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[],"objectGroups":[]},{"fullName":"","functionType":"Action","name":"onScenePostEvents","sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["const { handler } = gdjs._MousePointerLockExtension;\r","\r","handler.resetMovement();\r",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":false},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"MousePointerLock::isEmulatingPointerLock"},"parameters":["",""]}],"actions":[{"type":{"value":"MousePointerLock::SetMovementX"},"parameters":["","=","(MousePointerLock::TouchX(TouchId) - OldX) * TouchSpeedFactor",""]},{"type":{"value":"MousePointerLock::SetMovementY"},"parameters":["","=","(MousePointerLock::TouchY(TouchId) - OldY) * TouchSpeedFactor",""]},{"type":{"value":"SetNumberVariable"},"parameters":["OldX","=","MousePointerLock::TouchX(TouchId)"]},{"type":{"value":"SetNumberVariable"},"parameters":["OldY","=","MousePointerLock::TouchY(TouchId)"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"HasTouchEnded"},"parameters":["","TouchId"]}],"actions":[{"type":{"value":"SetNumberVariable"},"parameters":["TouchId","=","-1"]}]}],"parameters":[],"objectGroups":[]},{"description":"Lock the mouse pointer to hide it.","fullName":"Request Pointer Lock","functionType":"Action","name":"RequestPointerLock","sentence":"Request Pointer Lock","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"HasAnyTouchOrMouseStarted"},"parameters":[""]},{"type":{"value":"NumberVariable"},"parameters":["TouchId","=","-1"]}],"actions":[{"type":{"value":"SetNumberVariable"},"parameters":["TouchId","=","StartedTouchOrMouseId(0)"]},{"type":{"value":"SetNumberVariable"},"parameters":["OldX","=","MousePointerLock::TouchX(TouchId)"]},{"type":{"value":"SetNumberVariable"},"parameters":["OldY","=","MousePointerLock::TouchY(TouchId)"]}]},{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["const { handler } = gdjs._MousePointerLockExtension;\r","\r","handler.requestPointerLock();\r",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":false}],"parameters":[],"objectGroups":[]},{"description":"Unlocks the mouse pointer and show it.","fullName":"Exit pointer lock","functionType":"Action","name":"ExitPointerLock","sentence":"Exit pointer lock","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetNumberVariable"},"parameters":["TouchId","=","-1"]}]},{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["\r","const { handler } = gdjs._MousePointerLockExtension;\r","\r","handler.exitPointerLock();\r",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":false}],"parameters":[],"objectGroups":[]},{"description":"Check if the mouse pointer is locked.","fullName":"Pointer is locked","functionType":"Condition","name":"isPointerLocked","sentence":"The mouse pointer is locked","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"NumberVariable"},"parameters":["TouchId",">=","0"]}],"actions":[{"type":{"value":"SetReturnBoolean"},"parameters":["True"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"NumberVariable"},"parameters":["TouchId","<","0"]},{"type":{"value":"MousePointerLock::isPointerActuallyLocked"},"parameters":["",""]}],"actions":[{"type":{"value":"SetReturnBoolean"},"parameters":["True"]}]}],"parameters":[],"objectGroups":[]},{"description":"Check if the mouse pointer is actually locked.","fullName":"Pointer is actually locked","functionType":"Condition","name":"isPointerActuallyLocked","private":true,"sentence":"The mouse pointer actually is locked","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["\r","const { handler } = gdjs._MousePointerLockExtension;\r","\r","eventsFunctionContext.returnValue = handler.isPointerLocked();\r",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":false}],"parameters":[],"objectGroups":[]},{"description":"Check if the mouse pointer lock is emulated.","fullName":"Pointer lock is emulated","functionType":"Condition","name":"isEmulatingPointerLock","private":true,"sentence":"The mouse pointer is lock is emulated","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"inverted":true,"value":"MousePointerLock::isPointerActuallyLocked"},"parameters":["",""]},{"type":{"value":"NumberVariable"},"parameters":["TouchId",">=","0"]}],"actions":[{"type":{"value":"SetReturnBoolean"},"parameters":["True"]}]}],"parameters":[],"objectGroups":[]},{"description":"Check if the locked pointer is moving.","fullName":"Locked pointer is moving","functionType":"Condition","name":"IsMoving","sentence":"Locked pointer is moving","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"BuiltinCommonInstructions::Or"},"parameters":[],"subInstructions":[{"type":{"value":"MousePointerLock::MovementX"},"parameters":["","!=","0",""]},{"type":{"value":"MousePointerLock::MovementY"},"parameters":["","!=","0",""]}]}],"actions":[{"type":{"value":"SetReturnBoolean"},"parameters":["True"]}]}],"parameters":[],"objectGroups":[]},{"description":"the movement of the locked pointer on the X axis.","fullName":"Pointer X movement","functionType":"ExpressionAndCondition","name":"MovementX","sentence":"the movement of the locked pointer on the X axis","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["\r","eventsFunctionContext.returnValue = gdjs._MousePointerLockExtension.handler.movementX || 0;\r",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":false}],"expressionType":{"type":"expression"},"parameters":[],"objectGroups":[]},{"description":"the movement of the locked pointer on the X axis.","fullName":"Pointer X movement","functionType":"ActionWithOperator","getterName":"MovementX","name":"SetMovementX","private":true,"sentence":"the movement of the locked pointer on the X axis","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["\r","const value = eventsFunctionContext.getArgument(\"Value\");\r","gdjs._MousePointerLockExtension.handler.movementX = value;\r",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":false}],"parameters":[],"objectGroups":[]},{"description":"the movement of the pointer on the Y axis.","fullName":"Pointer Y movement","functionType":"ExpressionAndCondition","name":"MovementY","sentence":"the movement of the pointer on the Y axis","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["\r","eventsFunctionContext.returnValue = gdjs._MousePointerLockExtension.handler.movementY || 0;\r",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":false}],"expressionType":{"type":"expression"},"parameters":[],"objectGroups":[]},{"description":"the movement of the locked pointer on the X axis.","fullName":"Pointer X movement","functionType":"ActionWithOperator","getterName":"MovementY","name":"SetMovementY","private":true,"sentence":"the movement of the locked pointer on the X axis","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["\r","const value = eventsFunctionContext.getArgument(\"Value\");\r","gdjs._MousePointerLockExtension.handler.movementY = value;\r",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":false}],"parameters":[],"objectGroups":[]},{"description":"Return the X position of a specific touch","fullName":"Touch X position","functionType":"Expression","name":"TouchX","private":true,"sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["const touchId = eventsFunctionContext.getArgument(\"NewTouchId\");","eventsFunctionContext.returnValue = runtimeScene.getGame().getInputManager().getTouchX(touchId);",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":false}],"expressionType":{"type":"expression"},"parameters":[{"description":"Touch identifier","name":"NewTouchId","type":"expression"}],"objectGroups":[]},{"description":"Return the Y position of a specific touch","fullName":"Touch Y position","functionType":"Expression","name":"TouchY","private":true,"sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["const touchId = eventsFunctionContext.getArgument(\"NewTouchId\");","eventsFunctionContext.returnValue = runtimeScene.getGame().getInputManager().getTouchY(touchId);",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":false}],"expressionType":{"type":"expression"},"parameters":[{"description":"Touch identifier","name":"NewTouchId","type":"expression"}],"objectGroups":[]},{"description":"the speed factor for touch movement.","fullName":"Speed factor for touch movement","functionType":"ExpressionAndCondition","name":"TouchSpeedFactor","sentence":"the speed factor for touch movement","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["TouchSpeedFactor"]}]}],"expressionType":{"type":"expression"},"parameters":[],"objectGroups":[]},{"fullName":"","functionType":"ActionWithOperator","getterName":"TouchSpeedFactor","name":"SetTouchSpeedFactor","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetNumberVariable"},"parameters":["TouchSpeedFactor","=","Value"]}]}],"parameters":[],"objectGroups":[]}],"eventsBasedBehaviors":[{"description":"Control camera rotations with a mouse.","fullName":"First person camera mouse mapper","name":"FirstPersonPointerMapper","objectType":"","eventsFunctions":[{"fullName":"","functionType":"Action","name":"doStepPreEvents","sentence":"","events":[{"type":"BuiltinCommonInstructions::Comment","color":{"b":109,"g":230,"r":255,"textB":0,"textG":0,"textR":0},"comment":"TODO It's probably a bad idea to rotate the object around Y."},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"MousePointerLock::isPointerLocked"},"parameters":["",""]}],"actions":[{"type":{"value":"SetAngle"},"parameters":["Object","+","MousePointerLock::MovementX() * HorizontalSpeed / SceneWindowWidth()"]},{"type":{"value":"Scene3D::Base3DBehavior::SetRotationY"},"parameters":["Object","Object3D","+","MousePointerLock::MovementY() * VerticalSpeed / SceneWindowHeight()"]},{"type":{"value":"Scene3D::Base3DBehavior::SetRotationY"},"parameters":["Object","Object3D","=","clamp(Object.Object3D::RotationY(), VerticalAngleMin, VerticalAngleMax)"]},{"type":{"value":"MousePointerLock::FirstPersonPointerMapper::LookFromObjectEyes"},"parameters":["Object","Behavior",""]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"MouseButtonReleased"},"parameters":["","Left"]},{"type":{"value":"BooleanVariable"},"parameters":["ShouldLock","True",""]},{"type":{"inverted":true,"value":"MousePointerLock::isPointerLocked"},"parameters":["",""]}],"actions":[{"type":{"value":"MousePointerLock::RequestPointerLock"},"parameters":["",""]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"MousePointerLock::FirstPersonPointerMapper","type":"behavior"}],"objectGroups":[]},{"description":"Move the camera to look though _PARAM1_ eyes. The object must look to the right when all its angles are 0 and the top of its head be toward Z+.","fullName":"Look through object eyes","functionType":"Action","group":"Layers and cameras","name":"LookFromObjectEyes","private":true,"sentence":"Move the camera to look though _PARAM0_ eyes","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"CentreCamera"},"parameters":["","Object","","Object.Layer()",""]},{"type":{"value":"Scene3D::SetCameraZ"},"parameters":["","=","Object.Object3D::Z() + Object.Object3D::Depth() + OffsetZ","",""]},{"type":{"value":"Scene3D::SetCameraRotationX"},"parameters":["","=","- Object.Object3D::RotationY() + 90","GetArgumentAsString(\"Layer\")",""]},{"type":{"value":"Scene3D::SetCameraRotationY"},"parameters":["","=","Object.Object3D::RotationX()","GetArgumentAsString(\"Layer\")",""]},{"type":{"value":"SetCameraAngle"},"parameters":["","=","Object.Angle() + 90","Object.Layer()",""]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"MousePointerLock::FirstPersonPointerMapper","type":"behavior"}],"objectGroups":[]},{"description":"the horizontal rotation speed factor of the object.","fullName":"Horizontal rotation speed factor","functionType":"ExpressionAndCondition","group":"First person camera mouse mapper configuration","name":"HorizontalSpeed","sentence":"the horizontal rotation speed factor","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["HorizontalSpeed"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"MousePointerLock::FirstPersonPointerMapper","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"ActionWithOperator","getterName":"HorizontalSpeed","name":"SetHorizontalSpeed","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetNumberVariable"},"parameters":["HorizontalSpeed","=","Value"]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"MousePointerLock::FirstPersonPointerMapper","type":"behavior"}],"objectGroups":[]},{"description":"the vertical rotation speed factor of the object.","fullName":"Vertical rotation speed factor","functionType":"ExpressionAndCondition","group":"First person camera mouse mapper configuration","name":"VerticalSpeed","sentence":"the vertical rotation speed factor","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["VerticalSpeed"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"MousePointerLock::FirstPersonPointerMapper","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"ActionWithOperator","getterName":"VerticalSpeed","name":"SetVerticalSpeed","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetNumberVariable"},"parameters":["VerticalSpeed","=","Value"]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"MousePointerLock::FirstPersonPointerMapper","type":"behavior"}],"objectGroups":[]},{"description":"the minimum vertical camera angle of the object.","fullName":"Minimum vertical camera angle","functionType":"ExpressionAndCondition","group":"First person camera mouse mapper configuration","name":"VerticalAngleMin","sentence":"the minimum vertical camera angle","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["VerticalAngleMin"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"MousePointerLock::FirstPersonPointerMapper","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"ActionWithOperator","getterName":"VerticalAngleMin","name":"SetVerticalAngleMin","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetNumberVariable"},"parameters":["VerticalAngleMin","=","Value"]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"MousePointerLock::FirstPersonPointerMapper","type":"behavior"}],"objectGroups":[]},{"description":"the maximum vertical camera angle of the object.","fullName":"Maximum vertical camera angle","functionType":"ExpressionAndCondition","group":"First person camera mouse mapper configuration","name":"VerticalAngleMax","sentence":"the maximum vertical camera angle","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["VerticalAngleMax"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"MousePointerLock::FirstPersonPointerMapper","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"ActionWithOperator","getterName":"VerticalAngleMax","name":"SetVerticalAngleMax","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetNumberVariable"},"parameters":["VerticalAngleMax","=","Value"]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"MousePointerLock::FirstPersonPointerMapper","type":"behavior"}],"objectGroups":[]},{"description":"the z position offset of the object.","fullName":"Z position offset","functionType":"ExpressionAndCondition","group":"First person camera mouse mapper configuration","name":"OffsetZ","sentence":"the z position offset","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["OffsetZ"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"MousePointerLock::FirstPersonPointerMapper","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"ActionWithOperator","getterName":"OffsetZ","name":"SetOffsetZ","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetNumberVariable"},"parameters":["OffsetZ","=","Value"]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"MousePointerLock::FirstPersonPointerMapper","type":"behavior"}],"objectGroups":[]}],"propertyDescriptors":[{"value":"","type":"Behavior","label":"3D capability","description":"","group":"","extraInformation":["Scene3D::Base3DBehavior"],"name":"Object3D"},{"value":"200","type":"Number","unit":"Dimensionless","label":"Horizontal rotation speed factor","description":"","group":"","extraInformation":[],"name":"HorizontalSpeed"},{"value":"100","type":"Number","unit":"Dimensionless","label":"Vertical rotation speed factor","description":"","group":"","extraInformation":[],"name":"VerticalSpeed"},{"value":"-90","type":"Number","unit":"DegreeAngle","label":"Minimum vertical camera angle","description":"","group":"","extraInformation":[],"name":"VerticalAngleMin"},{"value":"90","type":"Number","unit":"DegreeAngle","label":"Maximum vertical camera angle","description":"","group":"","extraInformation":[],"name":"VerticalAngleMax"},{"value":"0","type":"Number","unit":"Pixel","label":"Z position offset","description":"","group":"","extraInformation":[],"name":"OffsetZ"},{"value":"true","type":"Boolean","label":"Lock the pointer on click","description":"","group":"","extraInformation":[],"name":"ShouldLock"}],"sharedPropertyDescriptors":[]}],"eventsBasedObjects":[]},{"author":"","category":"Movement","extensionNamespace":"","fullName":"Navigation mesh pathfinding (experimental)","gdevelopVersion":">=5.5.222","helpPath":"","iconUrl":"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAyMy4wLjMsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT4NCjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iSWNvbnMiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4Ig0KCSB2aWV3Qm94PSIwIDAgMzIgMzIiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDMyIDMyOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+DQo8c3R5bGUgdHlwZT0idGV4dC9jc3MiPg0KCS5zdDB7ZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyO3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDoxMDt9DQo8L3N0eWxlPg0KPHBvbHlsaW5lIGNsYXNzPSJzdDAiIHBvaW50cz0iMTcsMjYgNSwyNiA1LDQgMjcsNCAyNywyNiAyNSwyNiAiLz4NCjxwb2x5bGluZSBjbGFzcz0ic3QwIiBwb2ludHM9IjUsMTkgMTYsOCAyNywxOSAiLz4NCjxsaW5lIGNsYXNzPSJzdDAiIHgxPSIxMiIgeTE9IjQiIHgyPSIxOSIgeTI9IjExIi8+DQo8bGluZSBjbGFzcz0ic3QwIiB4MT0iMjIiIHkxPSI0IiB4Mj0iMjIiIHkyPSIxNCIvPg0KPHBhdGggY2xhc3M9InN0MCIgZD0iTTIwLjUsMTcuNWMtMS45LTEuOS01LjEtMS45LTcsMGMtMS45LDEuOS0xLjksNS4xLDAsN2MxLjQsMS41LDMuNiwxLjgsNS40LDEuMWMwLjYtMC4yLDEuMi0wLjYsMS42LTEuMQ0KCUMyMi40LDIyLjYsMjIuNCwxOS41LDIwLjUsMTcuNXoiLz4NCjxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik0yMS41LDIzbDMuOSwzLjZjMC44LDAuOCwwLjgsMiwwLDIuOGwwLDBjLTAuOCwwLjgtMiwwLjgtMi44LDBsLTMuNS0zLjUiLz4NCjwvc3ZnPg0K","name":"NavMeshPathfinding","previewIconUrl":"https://resources.gdevelop-app.com/assets/Icons/Line Hero Pack/Master/SVG/Maps and Navigation/Maps and Navigation_map_find_search.svg","shortDescription":"Pathfinding allows to compute an efficient path for objects, avoiding obstacles on the way.","version":"0.3.0","description":["In comparison to the built-in pathfinding behavior, this one aims to:","- better respect obstacle shapes","- find paths faster if obstacles don't move","","The isometric example shows how to use this extension to move a character to a destination ([open the project online](https://editor.gdevelop.io/?project=example://isometric-game))."],"origin":{"identifier":"NavMeshPathfinding","name":"gdevelop-extension-store"},"tags":["navmesh","pathfinding","obstacle","solid","path","detour","recast"],"authorIds":["IWykYNRvhCZBN3vEgKEbBPOR3Oc2"],"dependencies":[],"globalVariables":[],"sceneVariables":[],"eventsFunctions":[{"description":"Define JavaScript classes.","fullName":"Define JavaScript classes","functionType":"Action","name":"DefineJavaScript","private":true,"sentence":"Define JavaScript classes","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["// This code has been built from https://github.com/D8H/NavMesh-GDevelop-Extension","// If you need to make any modification, please open a PR on github.","","if (gdjs.__NavMeshPathfinding) {","    return;","}","","var extendStatics = function(d, b) {","    extendStatics = Object.setPrototypeOf ||","        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||","        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };","    return extendStatics(d, b);","};","","function __extends(d, b) {","    if (typeof b !== \"function\" && b !== null)","        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");","    extendStatics(d, b);","    function __() { this.constructor = d; }","    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());","}","","/**"," * Stripped down version of Phaser's Vector2 with just the functionality needed for navmeshes."," *"," * @export"," * @class Vector2"," */","var Vector2 = /** @class */ (function () {","    function Vector2(x, y) {","        if (x === void 0) { x = 0; }","        if (y === void 0) { y = 0; }","        this.x = x;","        this.y = y;","    }","    Vector2.prototype.equals = function (v) {","        return this.x === v.x && this.y === v.y;","    };","    Vector2.prototype.angle = function (v) {","        return Math.atan2(v.y - this.y, v.x - this.x);","    };","    Vector2.prototype.distance = function (v) {","        var dx = v.x - this.x;","        var dy = v.y - this.y;","        return Math.sqrt(dx * dx + dy * dy);","    };","    Vector2.prototype.add = function (v) {","        this.x += v.x;","        this.y += v.y;","    };","    Vector2.prototype.subtract = function (v) {","        this.x -= v.x;","        this.y -= v.y;","    };","    Vector2.prototype.clone = function () {","        return new Vector2(this.x, this.y);","    };","    return Vector2;","}());","","var GridNode = /** @class */ (function () {","    function GridNode(weight) {","        this.h = 0;","        this.g = 0;","        this.f = 0;","        this.closed = false;","        this.visited = false;","        this.parent = null;","        this.weight = weight;","    }","    GridNode.prototype.isWall = function () {","        return this.weight === 0;","    };","    GridNode.prototype.clean = function () {","        this.f = 0;","        this.g = 0;","        this.h = 0;","        this.visited = false;","        this.closed = false;","        this.parent = null;","    };","    return GridNode;","}());","","/**"," * A class that represents a navigable polygon with a navmesh. It is built on top of a"," * {@link Polygon}. It implements the properties and fields that javascript-astar needs - weight,"," * toString, isWall and getCost. See GPS test from astar repo for structure:"," * https://github.com/bgrins/javascript-astar/blob/master/test/tests.js"," */","var NavPoly = /** @class */ (function (_super) {","    __extends(NavPoly, _super);","    /**","     * Creates an instance of NavPoly.","     */","    function NavPoly(id, polygon) {","        var _this = _super.call(this, 1) || this;","        _this.id = id;","        _this.polygon = polygon;","        _this.edges = polygon.edges;","        _this.neighbors = [];","        _this.portals = [];","        _this.centroid = _this.calculateCentroid();","        _this.boundingRadius = _this.calculateRadius();","        return _this;","    }","    /**","     * Returns an array of points that form the polygon.","     */","    NavPoly.prototype.getPoints = function () {","        return this.polygon.points;","    };","    /**","     * Check if the given point-like object is within the polygon.","     */","    NavPoly.prototype.contains = function (point) {","        // Phaser's polygon check doesn't handle when a point is on one of the edges of the line. Note:","        // check numerical stability here. It would also be good to optimize this for different shapes.","        return this.polygon.contains(point.x, point.y) || this.isPointOnEdge(point);","    };","    /**","     * Only rectangles are supported, so this calculation works, but this is not actually the centroid","     * calculation for a polygon. This is just the average of the vertices - proper centroid of a","     * polygon factors in the area.","     */","    NavPoly.prototype.calculateCentroid = function () {","        var centroid = new Vector2(0, 0);","        var length = this.polygon.points.length;","        this.polygon.points.forEach(function (p) { return centroid.add(p); });","        centroid.x /= length;","        centroid.y /= length;","        return centroid;","    };","    /**","     * Calculate the radius of a circle that circumscribes the polygon.","     */","    NavPoly.prototype.calculateRadius = function () {","        var boundingRadius = 0;","        for (var _i = 0, _a = this.polygon.points; _i < _a.length; _i++) {","            var point = _a[_i];","            var d = this.centroid.distance(point);","            if (d > boundingRadius)","                boundingRadius = d;","        }","        return boundingRadius;","    };","    /**","     * Check if the given point-like object is on one of the edges of the polygon.","     */","    NavPoly.prototype.isPointOnEdge = function (_a) {","        var x = _a.x, y = _a.y;","        for (var _i = 0, _b = this.edges; _i < _b.length; _i++) {","            var edge = _b[_i];","            if (edge.pointOnSegment(x, y))","                return true;","        }","        return false;","    };","    NavPoly.prototype.destroy = function () {","        this.neighbors = [];","        this.portals = [];","    };","    // === jsastar methods ===","    NavPoly.prototype.toString = function () {","        return \"NavPoly(id: \" + this.id + \" at: \" + this.centroid + \")\";","    };","    NavPoly.prototype.isWall = function () {","        return false;","    };","    NavPoly.prototype.centroidDistance = function (navPolygon) {","        return this.centroid.distance(navPolygon.centroid);","    };","    NavPoly.prototype.getCost = function (navPolygon) {","        //TODO the cost method should not be in the Node","        return this.centroidDistance(navPolygon);","    };","    return NavPoly;","}(GridNode));","","/**"," * A graph memory structure"," */","var Graph = /** @class */ (function () {","    /**","     * A graph memory structure","     * @param {Array} gridIn 2D array of input weights","     * @param {Object} [options]","     * @param {bool} [options.diagonal] Specifies whether diagonal moves are allowed","     */","    function Graph(nodes, options) {","        this.dirtyNodes = [];","        options = options || {};","        this.nodes = nodes;","        this.diagonal = !!options.diagonal;","        this.init();","    }","    Graph.prototype.init = function () {","        this.dirtyNodes = [];","        for (var i = 0; i < this.nodes.length; i++) {","            this.nodes[i].clean();","        }","    };","    Graph.prototype.cleanDirty = function () {","        for (var i = 0; i < this.dirtyNodes.length; i++) {","            this.dirtyNodes[i].clean();","        }","        this.dirtyNodes = [];","    };","    Graph.prototype.markDirty = function (node) {","        this.dirtyNodes.push(node);","    };","    return Graph;","}());","","/**"," * Graph for javascript-astar. It implements the functionality for astar. See GPS test from astar"," * repo for structure: https://github.com/bgrins/javascript-astar/blob/master/test/tests.js"," *"," * @class NavGraph"," * @private"," */","var NavGraph = /** @class */ (function (_super) {","    __extends(NavGraph, _super);","    function NavGraph(navPolygons) {","        var _this = _super.call(this, navPolygons) || this;","        _this.nodes = navPolygons;","        _this.init();","        return _this;","    }","    NavGraph.prototype.neighbors = function (navPolygon) {","        return navPolygon.neighbors;","    };","    NavGraph.prototype.navHeuristic = function (navPolygon1, navPolygon2) {","        return navPolygon1.centroidDistance(navPolygon2);","    };","    NavGraph.prototype.destroy = function () {","        this.cleanDirty();","        this.nodes = [];","    };","    return NavGraph;","}(Graph));","","/**"," * Calculate the distance squared between two points. This is an optimization to a square root when"," * you just need to compare relative distances without needing to know the specific distance."," * @param a"," * @param b"," */","function distanceSquared(a, b) {","    var dx = b.x - a.x;","    var dy = b.y - a.y;","    return dx * dx + dy * dy;","}","/**"," * Project a point onto a line segment."," * JS Source: http://stackoverflow.com/questions/849211/shortest-distance-between-a-point-and-a-line-segment"," * @param point"," * @param line"," */","function projectPointToEdge(point, line) {","    var a = line.start;","    var b = line.end;","    // Consider the parametric equation for the edge's line, p = a + t (b - a). We want to find","    // where our point lies on the line by solving for t:","    //  t = [(p-a) . (b-a)] / |b-a|^2","    var l2 = distanceSquared(a, b);","    var t = ((point.x - a.x) * (b.x - a.x) + (point.y - a.y) * (b.y - a.y)) / l2;","    // We clamp t from [0,1] to handle points outside the segment vw.","    t = clamp(t, 0, 1);","    // Project onto the segment","    var p = new Vector2(a.x + t * (b.x - a.x), a.y + t * (b.y - a.y));","    return p;","}","/**"," * Twice the area of the triangle formed by a, b and c."," */","function triarea2(a, b, c) {","    var ax = b.x - a.x;","    var ay = b.y - a.y;","    var bx = c.x - a.x;","    var by = c.y - a.y;","    return bx * ay - ax * by;","}","/**"," * Clamp the given value between min and max."," */","function clamp(value, min, max) {","    if (value < min)","        value = min;","    if (value > max)","        value = max;","    return value;","}","/**"," * Check if two values are within a small margin of one another."," */","function almostEqual(value1, value2, errorMargin) {","    if (errorMargin === void 0) { errorMargin = 0.0001; }","    if (Math.abs(value1 - value2) <= errorMargin)","        return true;","    else","        return false;","}","/**"," * Find the smallest angle difference between two angles"," * https://gist.github.com/Aaronduino/4068b058f8dbc34b4d3a9eedc8b2cbe0"," */","function angleDifference(x, y) {","    var a = x - y;","    var i = a + Math.PI;","    var j = Math.PI * 2;","    a = i - Math.floor(i / j) * j; // (a+180) % 360; this ensures the correct sign","    a -= Math.PI;","    return a;","}","/**"," * Check if two lines are collinear (within a small error margin)."," */","function areCollinear(line1, line2, errorMargin) {","    if (errorMargin === void 0) { errorMargin = 0.0001; }","    // Figure out if the two lines are equal by looking at the area of the triangle formed","    // by their points","    var area1 = triarea2(line1.start, line1.end, line2.start);","    var area2 = triarea2(line1.start, line1.end, line2.end);","    if (almostEqual(area1, 0, errorMargin) && almostEqual(area2, 0, errorMargin)) {","        return true;","    }","    else","        return false;","}","","// Mostly sourced from PatrolJS at the moment. TODO: come back and reimplement this as an incomplete","/**"," * @private"," */","var Channel = /** @class */ (function () {","    function Channel() {","        this.portals = [];","        this.path = [];","    }","    Channel.prototype.push = function (p1, p2) {","        if (p2 === undefined)","            p2 = p1;","        this.portals.push({","            left: p1,","            right: p2,","        });","    };","    Channel.prototype.stringPull = function () {","        var portals = this.portals;","        var pts = [];","        // Init scan state","        var apexIndex = 0;","        var leftIndex = 0;","        var rightIndex = 0;","        var portalApex = portals[0].left;","        var portalLeft = portals[0].left;","        var portalRight = portals[0].right;","        // Add start point.","        pts.push(portalApex);","        for (var i = 1; i < portals.length; i++) {","            // Find the next portal vertices","            var left = portals[i].left;","            var right = portals[i].right;","            // Update right vertex.","            if (triarea2(portalApex, portalRight, right) <= 0.0) {","                if (portalApex.equals(portalRight) || triarea2(portalApex, portalLeft, right) > 0.0) {","                    // Tighten the funnel.","                    portalRight = right;","                    rightIndex = i;","                }","                else {","                    // Right vertex just crossed over the left vertex, so the left vertex should","                    // now be part of the path.","                    pts.push(portalLeft);","                    // Restart scan from portal left point.","                    // Make current left the new apex.","                    portalApex = portalLeft;","                    apexIndex = leftIndex;","                    // Reset portal","                    portalLeft = portalApex;","                    portalRight = portalApex;","                    leftIndex = apexIndex;","                    rightIndex = apexIndex;","                    // Restart scan","                    i = apexIndex;","                    continue;","                }","            }","            // Update left vertex.","            if (triarea2(portalApex, portalLeft, left) >= 0.0) {","                if (portalApex.equals(portalLeft) || triarea2(portalApex, portalRight, left) < 0.0) {","                    // Tighten the funnel.","                    portalLeft = left;","                    leftIndex = i;","                }","                else {","                    // Left vertex just crossed over the right vertex, so the right vertex should","                    // now be part of the path","                    pts.push(portalRight);","                    // Restart scan from portal right point.","                    // Make current right the new apex.","                    portalApex = portalRight;","                    apexIndex = rightIndex;","                    // Reset portal","                    portalLeft = portalApex;","                    portalRight = portalApex;","                    leftIndex = apexIndex;","                    rightIndex = apexIndex;","                    // Restart scan","                    i = apexIndex;","                    continue;","                }","            }","        }","        if (pts.length === 0 || !pts[pts.length - 1].equals(portals[portals.length - 1].left)) {","            // Append last point to path.","            pts.push(portals[portals.length - 1].left);","        }","        this.path = pts;","        return pts;","    };","    return Channel;","}());","","/**"," * Stripped down version of Phaser's Line with just the functionality needed for navmeshes."," *"," * @export"," * @class Line"," */","var Line = /** @class */ (function () {","    function Line(x1, y1, x2, y2) {","        this.start = new Vector2(x1, y1);","        this.end = new Vector2(x2, y2);","        this.left = Math.min(x1, x2);","        this.right = Math.max(x1, x2);","        this.top = Math.min(y1, y2);","        this.bottom = Math.max(y1, y2);","    }","    Line.prototype.pointOnSegment = function (x, y) {","        return (x >= this.left &&","            x <= this.right &&","            y >= this.top &&","            y <= this.bottom &&","            this.pointOnLine(x, y));","    };","    Line.prototype.pointOnLine = function (x, y) {","        // Compare slope of line start -> xy to line start -> line end","        return (x - this.left) * (this.bottom - this.top) === (this.right - this.left) * (y - this.top);","    };","    return Line;","}());","","/**"," * Stripped down version of Phaser's Polygon with just the functionality needed for navmeshes."," *"," * @export"," * @class Polygon"," */","var Polygon = /** @class */ (function () {","    function Polygon(points, closed) {","        if (closed === void 0) { closed = true; }","        this.isClosed = closed;","        this.points = points;","        this.edges = [];","        for (var i = 1; i < points.length; i++) {","            var p1 = points[i - 1];","            var p2 = points[i];","            this.edges.push(new Line(p1.x, p1.y, p2.x, p2.y));","        }","        if (this.isClosed) {","            var first = points[0];","            var last = points[points.length - 1];","            this.edges.push(new Line(first.x, first.y, last.x, last.y));","        }","    }","    Polygon.prototype.contains = function (x, y) {","        var inside = false;","        for (var i = -1, j = this.points.length - 1; ++i < this.points.length; j = i) {","            var ix = this.points[i].x;","            var iy = this.points[i].y;","            var jx = this.points[j].x;","            var jy = this.points[j].y;","            if (((iy <= y && y < jy) || (jy <= y && y < iy)) &&","                x < ((jx - ix) * (y - iy)) / (jy - iy) + ix) {","                inside = !inside;","            }","        }","        return inside;","    };","    return Polygon;","}());","","var BinaryHeap = /** @class */ (function () {","    function BinaryHeap(scoreFunction) {","        this.content = new Array();","        this.scoreFunction = scoreFunction;","    }","    BinaryHeap.prototype.push = function (element) {","        // Add the new element to the end of the array.","        this.content.push(element);","        // Allow it to sink down.","        this.sinkDown(this.content.length - 1);","    };","    BinaryHeap.prototype.pop = function () {","        // Store the first element so we can return it later.","        var result = this.content[0];","        // Get the element at the end of the array.","        var end = this.content.pop();","        if (!end)","            return;","        // If there are any elements left, put the end element at the","        // start, and let it bubble up.","        if (this.content.length > 0) {","            this.content[0] = end;","            this.bubbleUp(0);","        }","        return result;","    };","    BinaryHeap.prototype.remove = function (node) {","        var i = this.content.indexOf(node);","        // When it is found, the process seen in 'pop' is repeated","        // to fill up the hole.","        var end = this.content.pop();","        if (!end)","            return;","        if (i !== this.content.length - 1) {","            this.content[i] = end;","            if (this.scoreFunction(end) < this.scoreFunction(node)) {","                this.sinkDown(i);","            }","            else {","                this.bubbleUp(i);","            }","        }","    };","    BinaryHeap.prototype.size = function () {","        return this.content.length;","    };","    BinaryHeap.prototype.rescoreElement = function (node) {","        this.sinkDown(this.content.indexOf(node));","    };","    BinaryHeap.prototype.sinkDown = function (n) {","        // Fetch the element that has to be sunk.","        var element = this.content[n];","        // When at 0, an element can not sink any further.","        while (n > 0) {","            // Compute the parent element's index, and fetch it.","            var parentN = ((n + 1) >> 1) - 1;","            var parent = this.content[parentN];","            // Swap the elements if the parent is greater.","            if (this.scoreFunction(element) < this.scoreFunction(parent)) {","                this.content[parentN] = element;","                this.content[n] = parent;","                // Update 'n' to continue at the new position.","                n = parentN;","            }","            // Found a parent that is less, no need to sink any further.","            else {","                break;","            }","        }","    };","    BinaryHeap.prototype.bubbleUp = function (n) {","        // Look up the target element and its score.","        var length = this.content.length;","        var element = this.content[n];","        var elemScore = this.scoreFunction(element);","        while (true) {","            // Compute the indices of the child elements.","            var child2N = (n + 1) << 1;","            var child1N = child2N - 1;","            // This is used to store the new position of the element, if any.","            var swap = null;","            var child1Score = 0;","            // If the first child exists (is inside the array)...","            if (child1N < length) {","                // Look it up and compute its score.","                var child1 = this.content[child1N];","                child1Score = this.scoreFunction(child1);","                // If the score is less than our element's, we need to swap.","                if (child1Score < elemScore) {","                    swap = child1N;","                }","            }","            // Do the same checks for the other child.","            if (child2N < length) {","                var child2 = this.content[child2N];","                var child2Score = this.scoreFunction(child2);","                if (child2Score < (swap === null ? elemScore : child1Score)) {","                    swap = child2N;","                }","            }","            // If the element needs to be moved, swap it, and continue.","            if (swap !== null) {","                this.content[n] = this.content[swap];","                this.content[swap] = element;","                n = swap;","            }","            // Otherwise, we are done.","            else {","                break;","            }","        }","    };","    return BinaryHeap;","}());","","// The following implementation of the A* algorithm is from:","var AStar = /** @class */ (function () {","    function AStar() {","    }","    /**","     * Perform an A* Search on a graph given a start and end node.","     * @param {Graph} graph","     * @param {GridNode} start","     * @param {GridNode} end","     * @param {Object} [options]","     * @param {bool} [options.closest] Specifies whether to return the","     path to the closest node if the target is unreachable.","    * @param {Function} [options.heuristic] Heuristic function (see","    *          astar.heuristics).","    */","    AStar.prototype.search = function (graph, start, end, ","    // See list of heuristics: http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html","    heuristic, closest) {","        if (closest === void 0) { closest = false; }","        graph.cleanDirty();","        var openHeap = this.getHeap();","        var closestNode = start; // set the start node to be the closest if required","        start.h = heuristic(start, end);","        graph.markDirty(start);","        openHeap.push(start);","        while (openHeap.size() > 0) {","            // Grab the lowest f(x) to process next.  Heap keeps this sorted for us.","            var currentNode = openHeap.pop();","            // never happen","            if (!currentNode)","                return [];","            // End case -- result has been found, return the traced path.","            if (currentNode === end) {","                return this.pathTo(currentNode);","            }","            // Normal case -- move currentNode from open to closed, process each of its neighbors.","            currentNode.closed = true;","            // Find all neighbors for the current node.","            var neighbors = graph.neighbors(currentNode);","            for (var i = 0, il = neighbors.length; i < il; ++i) {","                var neighbor = neighbors[i];","                if (neighbor.closed || neighbor.isWall()) {","                    // Not a valid node to process, skip to next neighbor.","                    continue;","                }","                // The g score is the shortest distance from start to current node.","                // We need to check if the path we have arrived at this neighbor is the shortest one we have seen yet.","                var gScore = currentNode.g + neighbor.getCost(currentNode);","                var beenVisited = neighbor.visited;","                if (!beenVisited || gScore < neighbor.g) {","                    // Found an optimal (so far) path to this node.  Take score for node to see how good it is.","                    neighbor.visited = true;","                    neighbor.parent = currentNode;","                    neighbor.h = neighbor.h || heuristic(neighbor, end);","                    neighbor.g = gScore;","                    neighbor.f = neighbor.g + neighbor.h;","                    graph.markDirty(neighbor);","                    if (closest) {","                        // If the neighbor is closer than the current closestNode or if it's equally close but has","                        // a cheaper path than the current closest node then it becomes the closest node","                        if (neighbor.h < closestNode.h ||","                            (neighbor.h === closestNode.h && neighbor.g < closestNode.g)) {","                            closestNode = neighbor;","                        }","                    }","                    if (!beenVisited) {","                        // Pushing to heap will put it in proper place based on the 'f' value.","                        openHeap.push(neighbor);","                    }","                    else {","                        // Already seen the node, but since it has been rescored we need to reorder it in the heap","                        openHeap.rescoreElement(neighbor);","                    }","                }","            }","        }","        if (closest) {","            return this.pathTo(closestNode);","        }","        // No result was found - empty array signifies failure to find path.","        return [];","    };","    AStar.prototype.pathTo = function (node) {","        var curr = node;","        var path = new Array();","        while (curr.parent) {","            path.unshift(curr);","            curr = curr.parent;","        }","        return path;","    };","    AStar.prototype.getHeap = function () {","        return new BinaryHeap(function (node) {","            return node.f;","        });","    };","    return AStar;","}());","","/**"," * The `NavMesh` class is the workhorse that represents a navigation mesh built from a series of"," * polygons. Once built, the mesh can be asked for a path from one point to another point. Some"," * internal terminology usage:"," * - neighbor: a polygon that shares part of an edge with another polygon"," * - portal: when two neighbor's have edges that overlap, the portal is the overlapping line segment"," * - channel: the path of polygons from starting point to end point"," * - pull the string: run the funnel algorithm on the channel so that the path hugs the edges of the"," *   channel. Equivalent to having a string snaking through a hallway and then pulling it taut."," */","var NavMesh = /** @class */ (function () {","    /**","     * @param meshPolygonPoints Array where each element is an array of point-like objects that","     * defines a polygon.","     * @param meshShrinkAmount The amount (in pixels) that the navmesh has been shrunk around","     * obstacles (a.k.a the amount obstacles have been expanded).","     */","    function NavMesh(meshPolygonPoints, meshShrinkAmount) {","        if (meshShrinkAmount === void 0) { meshShrinkAmount = 0; }","        this.meshShrinkAmount = meshShrinkAmount;","        // Convert the PolyPoints[] into NavPoly instances.","        this.navPolygons = meshPolygonPoints.map(function (polyPoints, i) { return new NavPoly(i, new Polygon(polyPoints)); });","        this.calculateNeighbors();","        // Astar graph of connections between polygons","        this.graph = new NavGraph(this.navPolygons);","    }","    /**","     * Get the NavPolys that are in this navmesh.","     */","    NavMesh.prototype.getPolygons = function () {","        return this.navPolygons;","    };","    /**","     * Cleanup method to remove references.","     */","    NavMesh.prototype.destroy = function () {","        this.graph.destroy();","        for (var _i = 0, _a = this.navPolygons; _i < _a.length; _i++) {","            var poly = _a[_i];","            poly.destroy();","        }","        this.navPolygons = [];","    };","    /**","     * Find if the given point is within any of the polygons in the mesh.","     * @param point","     */","    NavMesh.prototype.isPointInMesh = function (point) {","        return this.navPolygons.some(function (navPoly) { return navPoly.contains(point); });","    };","    /**","     * Find the closest point in the mesh to the given point. If the point is already in the mesh,","     * this will give you that point. If the point is outside of the mesh, this will attempt to","     * project this point into the mesh (up to the given maxAllowableDist). This returns an object","     * with:","     * - distance - from the given point to the mesh","     * - polygon - the one the point is closest to, or null","     * - point - the point inside the mesh, or null","     * @param point","     * @param maxAllowableDist","     */","    NavMesh.prototype.findClosestMeshPoint = function (point, maxAllowableDist) {","        if (maxAllowableDist === void 0) { maxAllowableDist = Number.POSITIVE_INFINITY; }","        var minDistance = maxAllowableDist;","        var closestPoly = null;","        var pointOnClosestPoly = null;","        for (var _i = 0, _a = this.navPolygons; _i < _a.length; _i++) {","            var navPoly = _a[_i];","            // If we are inside a poly, we've got the closest.","            if (navPoly.contains(point)) {","                minDistance = 0;","                closestPoly = navPoly;","                pointOnClosestPoly = point;","                break;","            }","            // Is the poly close enough to warrant a more accurate check? Point is definitely outside of","            // the polygon. Distance - Radius is the smallest possible distance to an edge of the poly.","            // This will underestimate distance, but that's perfectly fine.","            var r = navPoly.boundingRadius;","            var d = navPoly.centroid.distance(point);","            if (d - r < minDistance) {","                var result = this.projectPointToPolygon(point, navPoly);","                if (result.distance < minDistance) {","                    minDistance = result.distance;","                    closestPoly = navPoly;","                    pointOnClosestPoly = result.point;","                }","            }","        }","        return { distance: minDistance, polygon: closestPoly, point: pointOnClosestPoly };","    };","    /**","     * Find a path from the start point to the end point using this nav mesh.","     * @param startPoint A point-like object in the form {x, y}","     * @param endPoint A point-like object in the form {x, y}","     * @returns An array of points if a path is found, or null if no path","     */","    NavMesh.prototype.findPath = function (startPoint, endPoint) {","        var startPoly = null;","        var endPoly = null;","        var startDistance = Number.MAX_VALUE;","        var endDistance = Number.MAX_VALUE;","        var d, r;","        var startVector = new Vector2(startPoint.x, startPoint.y);","        var endVector = new Vector2(endPoint.x, endPoint.y);","        // Find the closest poly for the starting and ending point","        for (var _i = 0, _a = this.navPolygons; _i < _a.length; _i++) {","            var navPoly = _a[_i];","            r = navPoly.boundingRadius;","            // Start","            d = navPoly.centroid.distance(startVector);","            if (d <= startDistance && d <= r && navPoly.contains(startVector)) {","                startPoly = navPoly;","                startDistance = d;","            }","            // End","            d = navPoly.centroid.distance(endVector);","            if (d <= endDistance && d <= r && navPoly.contains(endVector)) {","                endPoly = navPoly;","                endDistance = d;","            }","        }","        // If the end point wasn't inside a polygon, run a more liberal check that allows a point","        // to be within meshShrinkAmount radius of a polygon","        if (!endPoly && this.meshShrinkAmount > 0) {","            for (var _b = 0, _c = this.navPolygons; _b < _c.length; _b++) {","                var navPoly = _c[_b];","                r = navPoly.boundingRadius + this.meshShrinkAmount;","                d = navPoly.centroid.distance(endVector);","                if (d <= r) {","                    var distance = this.projectPointToPolygon(endVector, navPoly).distance;","                    if (distance <= this.meshShrinkAmount && distance < endDistance) {","                        endPoly = navPoly;","                        endDistance = distance;","                    }","                }","            }","        }","        // No matching polygons locations for the end, so no path found","        // because start point is valid normally, check end point first","        if (!endPoly)","            return null;","        // Same check as above, but for the start point","        if (!startPoly && this.meshShrinkAmount > 0) {","            for (var _d = 0, _e = this.navPolygons; _d < _e.length; _d++) {","                var navPoly = _e[_d];","                // Check if point is within bounding circle to avoid extra projection calculations","                r = navPoly.boundingRadius + this.meshShrinkAmount;","                d = navPoly.centroid.distance(startVector);","                if (d <= r) {","                    // Check if projected point is within range of a polygon and is closer than the","                    // previous point","                    var distance = this.projectPointToPolygon(startVector, navPoly).distance;","                    if (distance <= this.meshShrinkAmount && distance < startDistance) {","                        startPoly = navPoly;","                        startDistance = distance;","                    }","                }","            }","        }","        // No matching polygons locations for the start, so no path found","        if (!startPoly)","            return null;","        // If the start and end polygons are the same, return a direct path","        if (startPoly === endPoly)","            return [startVector, endVector];","        // Search!","        var astarPath = new AStar().search(this.graph, startPoly, endPoly, this.graph.navHeuristic);","        // While the start and end polygons may be valid, no path between them","        if (astarPath.length === 0)","            return null;","        // jsastar drops the first point from the path, but the funnel algorithm needs it","        astarPath.unshift(startPoly);","        // We have a path, so now time for the funnel algorithm","        var channel = new Channel();","        channel.push(startVector);","        for (var i = 0; i < astarPath.length - 1; i++) {","            var navPolygon = astarPath[i];","            var nextNavPolygon = astarPath[i + 1];","            // Find the portal","            var portal = null;","            for (var i_1 = 0; i_1 < navPolygon.neighbors.length; i_1++) {","                if (navPolygon.neighbors[i_1].id === nextNavPolygon.id) {","                    portal = navPolygon.portals[i_1];","                }","            }","            if (!portal)","                throw new Error(\"Path was supposed to be found, but portal is missing!\");","            // Push the portal vertices into the channel","            channel.push(portal.start, portal.end);","        }","        channel.push(endVector);","        // Pull a string along the channel to run the funnel","        channel.stringPull();","        // Clone path, excluding duplicates","        var lastPoint = null;","        var phaserPath = new Array();","        for (var _f = 0, _g = channel.path; _f < _g.length; _f++) {","            var p = _g[_f];","            var newPoint = p.clone();","            if (!lastPoint || !newPoint.equals(lastPoint))","                phaserPath.push(newPoint);","            lastPoint = newPoint;","        }","        return phaserPath;","    };","    NavMesh.prototype.calculateNeighbors = function () {","        // Fill out the neighbor information for each navpoly","        for (var i = 0; i < this.navPolygons.length; i++) {","            var navPoly = this.navPolygons[i];","            for (var j = i + 1; j < this.navPolygons.length; j++) {","                var otherNavPoly = this.navPolygons[j];","                // Check if the other navpoly is within range to touch","                var d = navPoly.centroid.distance(otherNavPoly.centroid);","                if (d > navPoly.boundingRadius + otherNavPoly.boundingRadius)","                    continue;","                // The are in range, so check each edge pairing","                for (var _i = 0, _a = navPoly.edges; _i < _a.length; _i++) {","                    var edge = _a[_i];","                    for (var _b = 0, _c = otherNavPoly.edges; _b < _c.length; _b++) {","                        var otherEdge = _c[_b];","                        // If edges aren't collinear, not an option for connecting navpolys","                        if (!areCollinear(edge, otherEdge))","                            continue;","                        // If they are collinear, check if they overlap","                        var overlap = this.getSegmentOverlap(edge, otherEdge);","                        if (!overlap)","                            continue;","                        // Connections are symmetric!","                        navPoly.neighbors.push(otherNavPoly);","                        otherNavPoly.neighbors.push(navPoly);","                        // Calculate the portal between the two polygons - this needs to be in","                        // counter-clockwise order, relative to each polygon","                        var p1 = overlap[0], p2 = overlap[1];","                        var edgeStartAngle = navPoly.centroid.angle(edge.start);","                        var a1 = navPoly.centroid.angle(overlap[0]);","                        var a2 = navPoly.centroid.angle(overlap[1]);","                        var d1 = angleDifference(edgeStartAngle, a1);","                        var d2 = angleDifference(edgeStartAngle, a2);","                        if (d1 < d2) {","                            navPoly.portals.push(new Line(p1.x, p1.y, p2.x, p2.y));","                        }","                        else {","                            navPoly.portals.push(new Line(p2.x, p2.y, p1.x, p1.y));","                        }","                        edgeStartAngle = otherNavPoly.centroid.angle(otherEdge.start);","                        a1 = otherNavPoly.centroid.angle(overlap[0]);","                        a2 = otherNavPoly.centroid.angle(overlap[1]);","                        d1 = angleDifference(edgeStartAngle, a1);","                        d2 = angleDifference(edgeStartAngle, a2);","                        if (d1 < d2) {","                            otherNavPoly.portals.push(new Line(p1.x, p1.y, p2.x, p2.y));","                        }","                        else {","                            otherNavPoly.portals.push(new Line(p2.x, p2.y, p1.x, p1.y));","                        }","                        // Two convex polygons shouldn't be connected more than once! (Unless","                        // there are unnecessary vertices...)","                    }","                }","            }","        }","    };","    // Check two collinear line segments to see if they overlap by sorting the points.","    // Algorithm source: http://stackoverflow.com/a/17152247","    NavMesh.prototype.getSegmentOverlap = function (line1, line2) {","        var points = [","            { line: line1, point: line1.start },","            { line: line1, point: line1.end },","            { line: line2, point: line2.start },","            { line: line2, point: line2.end },","        ];","        points.sort(function (a, b) {","            if (a.point.x < b.point.x)","                return -1;","            else if (a.point.x > b.point.x)","                return 1;","            else {","                if (a.point.y < b.point.y)","                    return -1;","                else if (a.point.y > b.point.y)","                    return 1;","                else","                    return 0;","            }","        });","        // If the first two points in the array come from the same line, no overlap","        var noOverlap = points[0].line === points[1].line;","        // If the two middle points in the array are the same coordinates, then there is a","        // single point of overlap.","        var singlePointOverlap = points[1].point.equals(points[2].point);","        if (noOverlap || singlePointOverlap)","            return null;","        else","            return [points[1].point, points[2].point];","    };","    /**","     * Project a point onto a polygon in the shortest distance possible.","     *","     * @param {Phaser.Point} point The point to project","     * @param {NavPoly} navPoly The navigation polygon to test against","     * @returns {{point: Phaser.Point, distance: number}}","     */","    NavMesh.prototype.projectPointToPolygon = function (point, navPoly) {","        var closestProjection = null;","        var closestDistance = Number.MAX_VALUE;","        for (var _i = 0, _a = navPoly.edges; _i < _a.length; _i++) {","            var edge = _a[_i];","            var projectedPoint = projectPointToEdge(point, edge);","            var d = point.distance(projectedPoint);","            if (closestProjection === null || d < closestDistance) {","                closestDistance = d;","                closestProjection = projectedPoint;","            }","        }","        return { point: closestProjection, distance: closestDistance };","    };","    return NavMesh;","}());","","/**"," * This implementation is strongly inspired from CritterAI class \"Geometry\"."," */","var Geometry = /** @class */ (function () {","    function Geometry() {","    }","    /**","     * Returns TRUE if line segment AB intersects with line segment CD in any","     * manner. Either collinear or at a single point.","     * @param ax The x-value for point (ax, ay) in line segment AB.","     * @param ay The y-value for point (ax, ay) in line segment AB.","     * @param bx The x-value for point (bx, by) in line segment AB.","     * @param by The y-value for point (bx, by) in line segment AB.","     * @param cx The x-value for point (cx, cy) in line segment CD.","     * @param cy The y-value for point (cx, cy) in line segment CD.","     * @param dx The x-value for point (dx, dy) in line segment CD.","     * @param dy The y-value for point (dx, dy) in line segment CD.","     * @return TRUE if line segment AB intersects with line segment CD in any","     * manner.","     */","    Geometry.segmentsIntersect = function (ax, ay, bx, by, cx, cy, dx, dy) {","        // This is modified 2D line-line intersection/segment-segment","        // intersection test.","        var deltaABx = bx - ax;","        var deltaABy = by - ay;","        var deltaCAx = ax - cx;","        var deltaCAy = ay - cy;","        var deltaCDx = dx - cx;","        var deltaCDy = dy - cy;","        var numerator = deltaCAy * deltaCDx - deltaCAx * deltaCDy;","        var denominator = deltaABx * deltaCDy - deltaABy * deltaCDx;","        // Perform early exit tests.","        if (denominator === 0 && numerator !== 0) {","            // If numerator is zero, then the lines are colinear.","            // Since it isn't, then the lines must be parallel.","            return false;","        }","        // Lines intersect. But do the segments intersect?","        // Forcing float division on both of these via casting of the","        // denominator.","        var factorAB = numerator / denominator;","        var factorCD = (deltaCAy * deltaABx - deltaCAx * deltaABy) / denominator;","        // Determine the type of intersection","        if (factorAB >= 0.0 &&","            factorAB <= 1.0 &&","            factorCD >= 0.0 &&","            factorCD <= 1.0) {","            return true; // The two segments intersect.","        }","        // The lines intersect, but segments to not.","        return false;","    };","    /**","     * Returns the distance squared from the point to the line segment.","     *","     * Behavior is undefined if the the closest distance is outside the","     * line segment.","     *","     * @param px The x-value of point (px, py).","     * @param py The y-value of point (px, py)","     * @param ax The x-value of the line segment's vertex A.","     * @param ay The y-value of the line segment's vertex A.","     * @param bx The x-value of the line segment's vertex B.","     * @param by The y-value of the line segment's vertex B.","     * @return The distance squared from the point (px, py) to line segment AB.","     */","    Geometry.getPointSegmentDistanceSq = function (px, py, ax, ay, bx, by) {","        // Reference: http://local.wasp.uwa.edu.au/~pbourke/geometry/pointline/","        //","        // The goal of the algorithm is to find the point on line segment AB","        // that is closest to P and then calculate the distance between P","        // and that point.","        var deltaABx = bx - ax;","        var deltaABy = by - ay;","        var deltaAPx = px - ax;","        var deltaAPy = py - ay;","        var segmentABLengthSq = deltaABx * deltaABx + deltaABy * deltaABy;","        if (segmentABLengthSq === 0) {","            // AB is not a line segment. So just return","            // distanceSq from P to A","            return deltaAPx * deltaAPx + deltaAPy * deltaAPy;","        }","        var u = (deltaAPx * deltaABx + deltaAPy * deltaABy) / segmentABLengthSq;","        if (u < 0) {","            // Closest point on line AB is outside outside segment AB and","            // closer to A. So return distanceSq from P to A.","            return deltaAPx * deltaAPx + deltaAPy * deltaAPy;","        }","        else if (u > 1) {","            // Closest point on line AB is outside segment AB and closer to B.","            // So return distanceSq from P to B.","            return (px - bx) * (px - bx) + (py - by) * (py - by);","        }","        // Closest point on lineAB is inside segment AB. So find the exact","        // point on AB and calculate the distanceSq from it to P.","        // The calculation in parenthesis is the location of the point on","        // the line segment.","        var deltaX = ax + u * deltaABx - px;","        var deltaY = ay + u * deltaABy - py;","        return deltaX * deltaX + deltaY * deltaY;","    };","    return Geometry;","}());","","/**"," * A cell that holds data needed by the 1st steps of the NavMesh generation."," */","var RasterizationCell = /** @class */ (function () {","    function RasterizationCell(x, y) {","        /**","         * 0 means there is an obstacle in the cell.","         * See {@link RegionGenerator}","         */","        this.distanceToObstacle = Number.MAX_VALUE;","        this.regionID = RasterizationCell.NULL_REGION_ID;","        this.distanceToRegionCore = 0;","        /**","         * If a cell is connected to one or more external regions then the","         *  flag will be a 4 bit value where connections are recorded as","         *  follows:","         *  - bit1 = neighbor0","         *  - bit2 = neighbor1","         *  - bit3 = neighbor2","         *  - bit4 = neighbor3","         *  With the meaning of the bits as follows:","         *  - 0 = neighbor in same region.","         *  - 1 = neighbor not in same region (neighbor may be the obstacle","         *    region or a real region).","         *","         * See {@link ContourBuilder}","         */","        this.contourFlags = 0;","        this.x = x;","        this.y = y;","        this.clear();","    }","    RasterizationCell.prototype.clear = function () {","        this.distanceToObstacle = Number.MAX_VALUE;","        this.regionID = RasterizationCell.NULL_REGION_ID;","        this.distanceToRegionCore = 0;","        this.contourFlags = 0;","    };","    /** A cell that has not been assigned to any region yet */","    RasterizationCell.NULL_REGION_ID = 0;","    /**","     * A cell that contains an obstacle.","     *","     * The value is the same as NULL_REGION_ID because the cells that are","     * not assigned to any region at the end of the flooding algorithm are","     * the obstacle cells.","     */","    RasterizationCell.OBSTACLE_REGION_ID = 0;","    return RasterizationCell;","}());","","var RasterizationGrid = /** @class */ (function () {","    function RasterizationGrid(left, top, right, bottom, cellWidth, cellHeight) {","        this.regionCount = 0;","        this.cellWidth = cellWidth;","        this.cellHeight = cellHeight;","        this.originX = left - cellWidth;","        this.originY = top - cellHeight;","        var dimX = 2 + Math.ceil((right - left) / cellWidth);","        var dimY = 2 + Math.ceil((bottom - top) / cellHeight);","        this.cells = [];","        for (var y = 0; y < dimY; y++) {","            this.cells[y] = [];","            for (var x = 0; x < dimX; x++) {","                this.cells[y][x] = new RasterizationCell(x, y);","            }","        }","    }","    RasterizationGrid.prototype.clear = function () {","        for (var _i = 0, _a = this.cells; _i < _a.length; _i++) {","            var row = _a[_i];","            for (var _b = 0, row_1 = row; _b < row_1.length; _b++) {","                var cell = row_1[_b];","                cell.clear();","            }","        }","        this.regionCount = 0;","    };","    /**","     *","     * @param position the position on the scene","     * @param gridPosition the position on the grid","     * @returns the position on the grid","     */","    RasterizationGrid.prototype.convertToGridBasis = function (position, gridPosition) {","        gridPosition.x = (position.x - this.originX) / this.cellWidth;","        gridPosition.y = (position.y - this.originY) / this.cellHeight;","        return gridPosition;","    };","    /**","     *","     * @param gridPosition the position on the grid","     * @param position the position on the scene","     * @returns the position on the scene","     */","    RasterizationGrid.prototype.convertFromGridBasis = function (gridPosition, position) {","        position.x = gridPosition.x * this.cellWidth + this.originX;","        position.y = gridPosition.y * this.cellHeight + this.originY;","        return position;","    };","    RasterizationGrid.prototype.get = function (x, y) {","        return this.cells[y][x];","    };","    RasterizationGrid.prototype.getNeighbor = function (cell, direction) {","        var delta = RasterizationGrid.neighbor8Deltas[direction];","        return this.cells[cell.y + delta.y][cell.x + delta.x];","    };","    RasterizationGrid.prototype.dimY = function () {","        return this.cells.length;","    };","    RasterizationGrid.prototype.dimX = function () {","        var firstColumn = this.cells[0];","        return firstColumn ? firstColumn.length : 0;","    };","    RasterizationGrid.prototype.obstacleDistanceMax = function () {","        var max = 0;","        for (var _i = 0, _a = this.cells; _i < _a.length; _i++) {","            var cellRow = _a[_i];","            for (var _b = 0, cellRow_1 = cellRow; _b < cellRow_1.length; _b++) {","                var cell = cellRow_1[_b];","                if (cell.distanceToObstacle > max) {","                    max = cell.distanceToObstacle;","                }","            }","        }","        return max;","    };","    RasterizationGrid.neighbor4Deltas = [","        { x: -1, y: 0 },","        { x: 0, y: 1 },","        { x: 1, y: 0 },","        { x: 0, y: -1 },","    ];","    RasterizationGrid.neighbor8Deltas = [","        { x: -1, y: 0 },","        { x: 0, y: 1 },","        { x: 1, y: 0 },","        { x: 0, y: -1 },","        { x: 1, y: 1 },","        { x: -1, y: 1 },","        { x: -1, y: -1 },","        { x: 1, y: -1 },","    ];","    return RasterizationGrid;","}());","","/**"," * Builds a set of contours from the region information contained in"," * {@link RasterizationCell}. It does this by locating and \"walking\" the edges."," *"," * This implementation is strongly inspired from CritterAI class \"ContourSetBuilder\"."," * http://www.critterai.org/projects/nmgen_study/contourgen.html"," */","var ContourBuilder = /** @class */ (function () {","    function ContourBuilder() {","        // These are working lists whose content changes with each iteration","        // of the up coming loop. They represent the detailed and simple","        // contour vertices.","        // Initial sizing is arbitrary.","        this.workingRawVertices = new Array(256);","        this.workingSimplifiedVertices = new Array(64);","    }","    /**","     * Generates a contour set from the provided {@link RasterizationGrid}","     *","     * The provided field is expected to contain region information.","     * Behavior is undefined if the provided field is malformed or incomplete.","     *","     * This operation overwrites the flag fields for all cells in the","     * provided field. So the flags must be saved and restored if they are","     * important.","     *","     * @param grid A fully generated field.","     * @param threshold The maximum distance (in cells) the edge of the contour","     * may deviate from the source geometry when the rastered obstacles are","     * vectorized.","     *","     * Setting it to:","     * - 1 ensure that an aliased edge won't be split to more edges.","     * - more that 1 will reduce the number of edges but the obstacles edges","     *   will be followed with less accuracy.","     * - less that 1 might be more accurate but it may try to follow the","     *   aliasing and be a lot less accurate.","     *","     * Values under 1 can be useful in specific cases:","     * - when edges are horizontal or vertical, there is no aliasing so value","     *   near 0 can do better results.","     * - when edges are 45° multiples, aliased vertex won't be farther than","     *   sqrt(2)/2 so values over 0.71 should give good results but not","     *   necessarily better than 1.","     *","     * @return The contours generated from the field.","     */","    ContourBuilder.prototype.buildContours = function (grid, threshold) {","        var contours = new Array(grid.regionCount);","        contours.length = 0;","        var contoursByRegion = new Array(grid.regionCount);","        var discardedContours = 0;","        //  Set the flags on all cells in non-obstacle regions to indicate which","        //  edges are connected to external regions.","        //","        //  Reference: Neighbor search and nomenclature.","        //  http://www.critterai.org/projects/nmgen_study/heightfields.html#nsearch","        //","        //  If a cell has no connections to external regions or is","        //  completely surrounded by other regions (a single cell island),","        //  its flag will be zero.","        //","        //  If a cell is connected to one or more external regions then the","        //  flag will be a 4 bit value where connections are recorded as","        //  follows:","        //      bit1 = neighbor0","        //      bit2 = neighbor1","        //      bit3 = neighbor2","        //      bit4 = neighbor3","        //  With the meaning of the bits as follows:","        //      0 = neighbor in same region.","        //      1 = neighbor not in same region (neighbor may be the obstacle","        //      region or a real region).","        for (var y = 1; y < grid.dimY() - 1; y++) {","            for (var x = 1; x < grid.dimX() - 1; x++) {","                var cell = grid.get(x, y);","                // Note:  This algorithm first sets the flag bits such that","                // 1 = \"neighbor is in the same region\". At the end it inverts","                // the bits so flags are as expected.","                // Default to \"not connected to any external region\".","                cell.contourFlags = 0;","                if (cell.regionID === RasterizationCell.OBSTACLE_REGION_ID)","                    // Don't care about cells in the obstacle region.","                    continue;","                for (var direction = 0; direction < RasterizationGrid.neighbor4Deltas.length; direction++) {","                    var delta = RasterizationGrid.neighbor4Deltas[direction];","                    var neighbor = grid.get(cell.x + delta.x, cell.y + delta.y);","                    if (cell.regionID === neighbor.regionID) {","                        // Neighbor is in same region as this cell.","                        // Set the bit for this neighbor to 1 (Will be inverted later).","                        cell.contourFlags |= 1 << direction;","                    }","                }","                // Invert the bits so a bit value of 1 indicates neighbor NOT in","                // same region.","                cell.contourFlags ^= 0xf;","                if (cell.contourFlags === 0xf) {","                    // This is an island cell (All neighbors are from other regions)","                    // Get rid of flags.","                    cell.contourFlags = 0;","                    console.warn(\"Discarded contour: Island cell. Can't form  a contour. Region: \" +","                        cell.regionID);","                    discardedContours++;","                }","            }","        }","        // Loop through all cells looking for cells on the edge of a region.","        //","        // At this point, only cells with flags != 0 are edge cells that","        // are part of a region contour.","        //","        // The process of building a contour will clear the flags on all cells","        // that make up the contour to ensure they are only processed once.","        for (var y = 1; y < grid.dimY() - 1; y++) {","            for (var x = 1; x < grid.dimX() - 1; x++) {","                var cell = grid.get(x, y);","                if (cell.regionID === RasterizationCell.OBSTACLE_REGION_ID ||","                    cell.contourFlags === 0) {","                    // cell is either: Part of the obstacle region, does not","                    // represent an edge cell, or was already processed during","                    // an earlier iteration.","                    continue;","                }","                this.workingRawVertices.length = 0;","                this.workingSimplifiedVertices.length = 0;","                // The cell is part of an unprocessed region's contour.","                // Locate a direction of the cell's edge which points toward","                // another region (there is at least one).","                var startDirection = 0;","                while ((cell.contourFlags & (1 << startDirection)) === 0) {","                    startDirection++;","                }","                // We now have a cell that is part of a contour and a direction","                // that points to a different region (obstacle or real).","                // Build the contour.","                this.buildRawContours(grid, cell, startDirection, this.workingRawVertices);","                // Perform post processing on the contour in order to","                // create the final, simplified contour.","                this.generateSimplifiedContour(cell.regionID, this.workingRawVertices, this.workingSimplifiedVertices, threshold);","                // The CritterAI implementation filters polygons with less than","                // 3 vertices, but they are needed to filter vertices in the middle","                // (not on an obstacle region border).","                var contour = Array.from(this.workingSimplifiedVertices);","                contours.push(contour);","                contoursByRegion[cell.regionID] = contour;","            }","        }","        if (contours.length + discardedContours !== grid.regionCount - 1) {","            // The only valid state is one contour per region.","            //","            // The only time this should occur is if an invalid contour","            // was formed or if a region resulted in multiple","            // contours (bad region data).","            //","            // IMPORTANT: While a mismatch may not be a fatal error,","            // it should be addressed since it can result in odd,","            // hard to spot anomalies later in the pipeline.","            //","            // A known cause is if a region fully encompasses another","            // region. In such a case, two contours will be formed.","            // The normal outer contour and an inner contour.","            // The CleanNullRegionBorders algorithm protects","            // against internal encompassed obstacle regions.","            console.error(\"Contour generation failed: Detected contours does\" +","                \" not match the number of regions. Regions: \" +","                (grid.regionCount - 1) +","                \", Detected contours: \" +","                (contours.length + discardedContours) +","                \" (Actual: \" +","                contours.length +","                \", Discarded: \" +","                discardedContours +","                \")\");","            // The CritterAI implementation has more detailed logs.","            // They can be interesting for debugging.","        }","        this.filterNonObstacleVertices(contours, contoursByRegion);","        return contours;","    };","    /**","     * Search vertices that are not shared with the obstacle region and","     * remove them.","     *","     * Some contours will have no vertex left.","     *","     * @param contours","     * @param contoursByRegion Some regions may have been discarded","     * so contours index can't be used.","     */","    ContourBuilder.prototype.filterNonObstacleVertices = function (contours, contoursByRegion) {","        // This was not part of the CritterAI implementation.","        // The removed vertex is merged on the nearest of the edges other extremity","        // that is on an obstacle border.","        var commonVertexContours = new Array(5);","        var commonVertexIndexes = new Array(5);","        // Each pass only filter vertex that have an edge other extremity on an obstacle.","        // Vertex depth (in number of edges to reach an obstacle) is reduces by","        // at least one by each pass.","        var movedAnyVertex = false;","        do {","            movedAnyVertex = false;","            for (var _i = 0, contours_1 = contours; _i < contours_1.length; _i++) {","                var contour = contours_1[_i];","                for (var vertexIndex = 0; vertexIndex < contour.length; vertexIndex++) {","                    var vertex = contour[vertexIndex];","                    var nextVertex = contour[(vertexIndex + 1) % contour.length];","                    if (vertex.region !== RasterizationCell.OBSTACLE_REGION_ID &&","                        nextVertex.region !== RasterizationCell.OBSTACLE_REGION_ID) {","                        // This is a vertex in the middle. It must be removed.","                        // Search the contours around the vertex.","                        //","                        // Typically a contour point to its neighbor and it form a cycle.","                        //","                        //   \\ C /","                        //    \\ /","                        //  A  |  B","                        //     |","                        //","                        // C -> B -> A -> C","                        //","                        // There can be more than 3 contours even if it's rare.","                        commonVertexContours.length = 0;","                        commonVertexIndexes.length = 0;","                        commonVertexContours.push(contour);","                        commonVertexIndexes.push(vertexIndex);","                        var errorFound = false;","                        var commonVertex = vertex;","                        do {","                            var neighborContour = contoursByRegion[commonVertex.region];","                            if (!neighborContour) {","                                errorFound = true;","                                if (commonVertex.region !== RasterizationCell.OBSTACLE_REGION_ID) {","                                    console.warn(\"contour already discarded: \" + commonVertex.region);","                                }","                                break;","                            }","                            var foundVertex = false;","                            for (var neighborVertexIndex = 0; neighborVertexIndex < neighborContour.length; neighborVertexIndex++) {","                                var neighborVertex = neighborContour[neighborVertexIndex];","                                if (neighborVertex.x === commonVertex.x &&","                                    neighborVertex.y === commonVertex.y) {","                                    commonVertexContours.push(neighborContour);","                                    commonVertexIndexes.push(neighborVertexIndex);","                                    commonVertex = neighborVertex;","                                    foundVertex = true;","                                    break;","                                }","                            }","                            if (!foundVertex) {","                                errorFound = true;","                                console.error(\"Can't find a common vertex with a neighbor contour. There is probably a superposition.\");","                                break;","                            }","                        } while (commonVertex !== vertex);","                        if (errorFound) {","                            continue;","                        }","                        if (commonVertexContours.length < 3) {","                            console.error(\"The vertex is shared by only \" + commonVertexContours.length + \" regions.\");","                        }","                        var shorterEdgeContourIndex = -1;","                        var edgeLengthMin = Number.MAX_VALUE;","                        for (var index = 0; index < commonVertexContours.length; index++) {","                            var vertexContour = commonVertexContours[index];","                            var vertexIndex_1 = commonVertexIndexes[index];","                            var previousVertex = vertexContour[(vertexIndex_1 - 1 + vertexContour.length) %","                                vertexContour.length];","                            if (previousVertex.region === RasterizationCell.OBSTACLE_REGION_ID) {","                                var deltaX = previousVertex.x - vertex.x;","                                var deltaY = previousVertex.y - vertex.y;","                                var lengthSq = deltaX * deltaX + deltaY * deltaY;","                                if (lengthSq < edgeLengthMin) {","                                    edgeLengthMin = lengthSq;","                                    shorterEdgeContourIndex = index;","                                }","                            }","                        }","                        if (shorterEdgeContourIndex === -1) {","                            // A vertex has no neighbor on an obstacle.","                            // It will be solved in next iterations.","                            continue;","                        }","                        // Merge the vertex on the other extremity of the smallest of the 3 edges.","                        //","                        //   \\ C /","                        //    \\ /","                        //  A  |  B","                        //     |","                        //","                        // - the shortest edge is between A and B","                        // - the Y will become a V","                        // - vertices are store clockwise","                        // - there can be more than one C (it's rare)","                        // This is B","                        var shorterEdgeContour = commonVertexContours[shorterEdgeContourIndex];","                        var shorterEdgeVertexIndex = commonVertexIndexes[shorterEdgeContourIndex];","                        var shorterEdgeExtremityVertex = shorterEdgeContour[(shorterEdgeVertexIndex - 1 + shorterEdgeContour.length) %","                            shorterEdgeContour.length];","                        // This is A","                        var shorterEdgeOtherContourIndex = (shorterEdgeContourIndex + 1) % commonVertexContours.length;","                        var shorterEdgeOtherContour = commonVertexContours[shorterEdgeOtherContourIndex];","                        var shorterEdgeOtherVertexIndex = commonVertexIndexes[shorterEdgeOtherContourIndex];","                        for (var index = 0; index < commonVertexContours.length; index++) {","                            if (index === shorterEdgeContourIndex ||","                                index === shorterEdgeOtherContourIndex) {","                                continue;","                            }","                            // These are C","                            var commonVertexContour = commonVertexContours[index];","                            var commonVertexIndex = commonVertexIndexes[index];","                            // Move the vertex to an obstacle border","                            var movedVertex = commonVertexContour[commonVertexIndex];","                            movedVertex.x = shorterEdgeExtremityVertex.x;","                            movedVertex.y = shorterEdgeExtremityVertex.y;","                            movedVertex.region = RasterizationCell.NULL_REGION_ID;","                        }","                        // There is no more border between A and B,","                        // update the region from B to C.","                        shorterEdgeOtherContour[(shorterEdgeOtherVertexIndex + 1) % shorterEdgeOtherContour.length].region =","                            shorterEdgeOtherContour[shorterEdgeOtherVertexIndex].region;","                        // Remove in A and B the vertex that's been move in C.","                        shorterEdgeContour.splice(shorterEdgeVertexIndex, 1);","                        shorterEdgeOtherContour.splice(shorterEdgeOtherVertexIndex, 1);","                        movedAnyVertex = true;","                    }","                }","            }","        } while (movedAnyVertex);","        // Clean the polygons from identical vertices.","        //","        // This can happen with 2 vertices regions.","        // 2 edges are superposed and there extremity is the same.","        // One is move over the other.","        // I could observe this with a region between 2 regions","        // where one of one of these 2 regions were also encompassed.","        // A bit like a rainbow, 2 big regions: the land, the sky","        // and 2 regions for the colors.","        //","        // The vertex can't be removed during the process because","        // they hold data used by other merging.","        //","        // Some contour will have no vertex left.","        // It more efficient to let the next step ignore them.","        for (var _a = 0, contours_2 = contours; _a < contours_2.length; _a++) {","            var contour = contours_2[_a];","            for (var vertexIndex = 0; vertexIndex < contour.length; vertexIndex++) {","                var vertex = contour[vertexIndex];","                var nextVertexIndex = (vertexIndex + 1) % contour.length;","                var nextVertex = contour[nextVertexIndex];","                if (vertex.x === nextVertex.x && vertex.y === nextVertex.y) {","                    contour.splice(nextVertexIndex, 1);","                    vertexIndex--;","                }","            }","        }","    };","    /**","     * Walk around the edge of this cell's region gathering vertices that","     * represent the corners of each cell on the sides that are external facing.","     *","     * There will be two or three vertices for each edge cell:","     * Two for cells that don't represent a change in edge direction. Three","     * for cells that represent a change in edge direction.","     *","     * The output array will contain vertices ordered as follows:","     * (x, y, z, regionID) where regionID is the region (obstacle or real) that","     * this vertex is considered to be connected to.","     *","     * WARNING: Only run this operation on cells that are already known","     * to be on a region edge. The direction must also be pointing to a","     * valid edge. Otherwise behavior will be undefined.","     *","     * @param grid the grid of cells","     * @param startCell A cell that is known to be on the edge of a region","     * (part of a region contour).","     * @param startDirection The direction of the edge of the cell that is","     * known to point","     * across the region edge.","     * @param outContourVertices The list of vertices that represent the edge","     * of the region.","     */","    ContourBuilder.prototype.buildRawContours = function (grid, startCell, startDirection, outContourVertices) {","        // Flaw in Algorithm:","        //","        // This method of contour generation can result in an inappropriate","        // impassable seam between two adjacent regions in the following case:","        //","        // 1. One region connects to another region on two sides in an","        // uninterrupted manner (visualize one region wrapping in an L","        // shape around the corner of another).","        // 2. At the corner shared by the two regions, a change in height","        // occurs.","        //","        // In this case, the two regions should share a corner vertex","        // (an obtuse corner vertex for one region and an acute corner","        // vertex for the other region).","        //","        // In reality, though this algorithm will select the same (x, z)","        // coordinates for each region's corner vertex, the vertex heights","        // may differ, eventually resulting in an impassable seam.","        // It is a bit hard to describe the stepping portion of this algorithm.","        // One way to visualize it is to think of a robot sitting on the","        // floor facing a known wall. It then does the following to skirt","        // the wall:","        // 1. If there is a wall in front of it, turn clockwise in 90 degrees","        //    increments until it finds the wall is gone.","        // 2. Move forward one step.","        // 3. Turn counter-clockwise by 90 degrees.","        // 4. Repeat from step 1 until it finds itself at its original","        //    location facing its original direction.","        //","        // See also: http://www.critterai.org/projects/nmgen_study/contourgen.html#robotwalk","        var cell = startCell;","        var direction = startDirection;","        var loopCount = 0;","        do {","            // Note: The design of this loop is such that the cell variable","            // will always reference an edge cell from the same region as","            // the start cell.","            if ((cell.contourFlags & (1 << direction)) !== 0) {","                // The current direction is pointing toward an edge.","                // Get this edge's vertex.","                var delta = ContourBuilder.leftVertexOfFacingCellBorderDeltas[direction];","                var neighbor = grid.get(cell.x + RasterizationGrid.neighbor4Deltas[direction].x, cell.y + RasterizationGrid.neighbor4Deltas[direction].y);","                outContourVertices.push({","                    x: cell.x + delta.x,","                    y: cell.y + delta.y,","                    region: neighbor.regionID,","                });","                // Remove the flag for this edge. We never need to consider","                // it again since we have a vertex for this edge.","                cell.contourFlags &= ~(1 << direction);","                // Rotate in clockwise direction.","                direction = (direction + 1) & 0x3;","            }","            else {","                // The current direction does not point to an edge. So it","                // must point to a neighbor cell in the same region as the","                // current cell. Move to the neighbor and swing the search","                // direction back one increment (counterclockwise).","                // By moving the direction back one increment we guarantee we","                // don't miss any edges.","                var neighbor = grid.get(cell.x + RasterizationGrid.neighbor4Deltas[direction].x, cell.y + RasterizationGrid.neighbor4Deltas[direction].y);","                cell = neighbor;","                direction = (direction + 3) & 0x3; // Rotate counterclockwise.","            }","            // The loop limit is arbitrary. It exists only to guarantee that","            // bad input data doesn't result in an infinite loop.","            // The only down side of this loop limit is that it limits the","            // number of detectable edge vertices (the longer the region edge","            // and the higher the number of \"turns\" in a region's edge, the less","            // edge vertices can be detected for that region).","        } while (!(cell === startCell && direction === startDirection) &&","            ++loopCount < 65535);","        return outContourVertices;","    };","    /**","     * Takes a group of vertices that represent a region contour and changes","     * it in the following manner:","     * - For any edges that connect to non-obstacle regions, remove all","     * vertices except the start and end vertices for that edge (this","     * smooths the edges between non-obstacle regions into a straight line).","     * - Runs an algorithm's against the contour to follow the edge more closely.","     *","     * @param regionID The region the contour was derived from.","     * @param sourceVertices  The source vertices that represent the complex","     * contour.","     * @param outVertices The simplified contour vertices.","     * @param threshold The maximum distance the edge of the contour may deviate","     * from the source geometry.","     */","    ContourBuilder.prototype.generateSimplifiedContour = function (regionID, sourceVertices, outVertices, threshold) {","        var noConnections = true;","        for (var _i = 0, sourceVertices_1 = sourceVertices; _i < sourceVertices_1.length; _i++) {","            var sourceVertex = sourceVertices_1[_i];","            if (sourceVertex.region !== RasterizationCell.OBSTACLE_REGION_ID) {","                noConnections = false;","                break;","            }","        }","        // Seed the simplified contour with the mandatory edges","        // (At least one edge).","        if (noConnections) {","            // This contour represents an island region surrounded only by the","            // obstacle region. Seed the simplified contour with the source's","            // lower left (ll) and upper right (ur) vertices.","            var lowerLeftX = sourceVertices[0].x;","            var lowerLeftY = sourceVertices[0].y;","            var lowerLeftIndex = 0;","            var upperRightX = sourceVertices[0].x;","            var upperRightY = sourceVertices[0].y;","            var upperRightIndex = 0;","            for (var index = 0; index < sourceVertices.length; index++) {","                var sourceVertex = sourceVertices[index];","                var x = sourceVertex.x;","                var y = sourceVertex.y;","                if (x < lowerLeftX || (x === lowerLeftX && y < lowerLeftY)) {","                    lowerLeftX = x;","                    lowerLeftY = y;","                    lowerLeftIndex = index;","                }","                if (x >= upperRightX || (x === upperRightX && y > upperRightY)) {","                    upperRightX = x;","                    upperRightY = y;","                    upperRightIndex = index;","                }","            }","            // The region attribute is used to store an index locally in this function.","            // TODO Maybe there is a way to do this cleanly and keep no memory footprint.","            // Seed the simplified contour with this edge.","            outVertices.push({","                x: lowerLeftX,","                y: lowerLeftY,","                region: lowerLeftIndex,","            });","            outVertices.push({","                x: upperRightX,","                y: upperRightY,","                region: upperRightIndex,","            });","        }","        else {","            // The contour shares edges with other non-obstacle regions.","            // Seed the simplified contour with a new vertex for every","            // location where the region connection changes. These are","            // vertices that are important because they represent portals","            // to other regions.","            for (var index = 0; index < sourceVertices.length; index++) {","                var sourceVert = sourceVertices[index];","                if (sourceVert.region !==","                    sourceVertices[(index + 1) % sourceVertices.length].region) {","                    // The current vertex has a different region than the","                    // next vertex. So there is a change in vertex region.","                    outVertices.push({","                        x: sourceVert.x,","                        y: sourceVert.y,","                        region: index,","                    });","                }","            }","        }","        this.matchObstacleRegionEdges(sourceVertices, outVertices, threshold);","        if (outVertices.length < 2) {","            // It will be ignored by the triangulation.","            // It should be rare enough not to handle it now.","            console.warn(\"A region is encompassed in another region. It will be ignored.\");","        }","        // There can be polygons with only 2 vertices when a region is between","        // 2 non-obstacles regions. It's still a useful information to filter","        // vertices in the middle (not on an obstacle region border).","        // In this case, the CritterAI implementation adds a 3rd point to avoid","        // invisible polygons, but it makes it difficult to filter it later.","        // Replace the index pointers in the output list with region IDs.","        for (var _a = 0, outVertices_1 = outVertices; _a < outVertices_1.length; _a++) {","            var outVertex = outVertices_1[_a];","            outVertex.region = sourceVertices[outVertex.region].region;","        }","    };","    /**","     * Applies an algorithm to contours which results in obstacle-region edges","     * following the original detail source geometry edge more closely.","     * http://www.critterai.org/projects/nmgen_study/contourgen.html#nulledgesimple","     *","     * Adds vertices from the source list to the result list such that","     * if any obstacle region vertices are compared against the result list,","     * none of the vertices will be further from the obstacle region edges than","     * the allowed threshold.","     *","     * Only obstacle-region edges are operated on. All other edges are","     * ignored.","     *","     * The result vertices is expected to be seeded with at least two","     * source vertices.","     *","     * @param sourceVertices","     * @param inoutResultVertices","     * @param threshold The maximum distance the edge of the contour may deviate","     * from the source geometry.","     */","    ContourBuilder.prototype.matchObstacleRegionEdges = function (sourceVertices, inoutResultVertices, threshold) {","        // This implementation is strongly inspired from CritterAI class \"MatchNullRegionEdges\".","        // Loop through all edges in this contour.","        //","        // NOTE: The simplifiedVertCount in the loop condition","        // increases over iterations. That is what keeps the loop going beyond","        // the initial vertex count.","        var resultIndexA = 0;","        while (resultIndexA < inoutResultVertices.length) {","            var resultIndexB = (resultIndexA + 1) % inoutResultVertices.length;","            // The line segment's beginning vertex.","            var ax = inoutResultVertices[resultIndexA].x;","            var az = inoutResultVertices[resultIndexA].y;","            var sourceIndexA = inoutResultVertices[resultIndexA].region;","            // The line segment's ending vertex.","            var bx = inoutResultVertices[resultIndexB].x;","            var bz = inoutResultVertices[resultIndexB].y;","            var sourceIndexB = inoutResultVertices[resultIndexB].region;","            // The source index of the next vertex to test (the vertex just","            // after the current vertex in the source vertex list).","            var testedSourceIndex = (sourceIndexA + 1) % sourceVertices.length;","            var maxDeviation = 0;","            // Default to no index. No new vert to add.","            var toInsertSourceIndex = -1;","            if (sourceVertices[testedSourceIndex].region ===","                RasterizationCell.OBSTACLE_REGION_ID) {","                // This test vertex is part of a obstacle region edge.","                // Loop through the source vertices until the end vertex","                // is found, searching for the vertex that is farthest from","                // the line segment formed by the begin/end vertices.","                //","                // Visualizations:","                // http://www.critterai.org/projects/nmgen_study/contourgen.html#nulledgesimple","                while (testedSourceIndex !== sourceIndexB) {","                    var deviation = Geometry.getPointSegmentDistanceSq(sourceVertices[testedSourceIndex].x, sourceVertices[testedSourceIndex].y, ax, az, bx, bz);","                    if (deviation > maxDeviation) {","                        // A new maximum deviation was detected.","                        maxDeviation = deviation;","                        toInsertSourceIndex = testedSourceIndex;","                    }","                    // Move to the next vertex.","                    testedSourceIndex = (testedSourceIndex + 1) % sourceVertices.length;","                }","            }","            if (toInsertSourceIndex !== -1 && maxDeviation > threshold * threshold) {","                // A vertex was found that is further than allowed from the","                // current edge. Add this vertex to the contour.","                inoutResultVertices.splice(resultIndexA + 1, 0, {","                    x: sourceVertices[toInsertSourceIndex].x,","                    y: sourceVertices[toInsertSourceIndex].y,","                    region: toInsertSourceIndex,","                });","                // Not incrementing the vertex since we need to test the edge","                // formed by vertA  and this this new vertex on the next","                // iteration of the loop.","            }","            // This edge segment does not need to be altered. Move to","            // the next vertex.","            else","                resultIndexA++;","        }","    };","    ContourBuilder.leftVertexOfFacingCellBorderDeltas = [","        { x: 0, y: 1 },","        { x: 1, y: 1 },","        { x: 1, y: 0 },","        { x: 0, y: 0 },","    ];","    return ContourBuilder;","}());","","/**"," * Builds convex polygons from the provided polygons."," *"," * This implementation is strongly inspired from CritterAI class \"PolyMeshFieldBuilder\"."," * http://www.critterai.org/projects/nmgen_study/polygen.html"," */","var ConvexPolygonGenerator = /** @class */ (function () {","    function ConvexPolygonGenerator() {","    }","    /**","     * Builds convex polygons from the provided polygons.","     * @param concavePolygons The content is manipulated during the operation","     * and it will be left in an undefined state at the end of","     * the operation.","     * @param maxVerticesPerPolygon cap the vertex number in return polygons.","     * @return convex polygons.","     */","    ConvexPolygonGenerator.prototype.splitToConvexPolygons = function (concavePolygons, maxVerticesPerPolygon) {","        // The maximum possible number of polygons assuming that all will","        // be triangles.","        var maxPossiblePolygons = 0;","        // The maximum vertices found in a single contour.","        var maxVerticesPerContour = 0;","        for (var _i = 0, concavePolygons_1 = concavePolygons; _i < concavePolygons_1.length; _i++) {","            var contour = concavePolygons_1[_i];","            var count = contour.length;","            maxPossiblePolygons += count - 2;","            maxVerticesPerContour = Math.max(maxVerticesPerContour, count);","        }","        // Each list is initialized to a size that will minimize resizing.","        var convexPolygons = new Array(maxPossiblePolygons);","        convexPolygons.length = 0;","        // Various working variables.","        // (Values are meaningless outside of the iteration)","        var workingContourFlags = new Array(maxVerticesPerContour);","        workingContourFlags.length = 0;","        var workingPolygons = new Array(maxVerticesPerContour + 1);","        workingPolygons.length = 0;","        var workingMergeInfo = {","            lengthSq: -1,","            polygonAVertexIndex: -1,","            polygonBVertexIndex: -1,","        };","        var workingMergedPolygon = new Array(maxVerticesPerPolygon);","        workingMergedPolygon.length = 0;","        var _loop_1 = function (contour) {","            if (contour.length < 3) {","                return \"continue\";","            }","            // Initialize the working polygon array.","            workingPolygons.length = 0;","            // Triangulate the contour.","            var foundAnyTriangle = false;","            this_1.triangulate(contour, workingContourFlags, function (p1, p2, p3) {","                var workingPolygon = new Array(maxVerticesPerPolygon);","                workingPolygon.length = 0;","                workingPolygon.push(p1);","                workingPolygon.push(p2);","                workingPolygon.push(p3);","                workingPolygons.push(workingPolygon);","                foundAnyTriangle = true;","            });","            if (!foundAnyTriangle) {","                /*","                    * Failure of the triangulation.","                    * This is known to occur if the source polygon is","                    * self-intersecting or the source region contains internal","                    * holes. In both cases, the problem is likely due to bad","                    * region formation.","                    */","                console.error(\"Polygon generation failure: Could not triangulate contour.\");","                console.error(\"contour:\" +","                    contour.map(function (point) { return point.x + \" \" + point.y; }).join(\" ; \"));","                return \"continue\";","            }","            if (maxVerticesPerPolygon > 3) {","                // Merging of triangles into larger polygons is permitted.","                // Continue until no polygons can be found to merge.","                // http://www.critterai.org/nmgen_polygen#mergepolys","                while (true) {","                    var longestMergeEdge = -1;","                    var bestPolygonA = [];","                    var polygonAVertexIndex = -1; // Start of the shared edge.","                    var bestPolygonB = [];","                    var polygonBVertexIndex = -1; // Start of the shared edge.","                    var bestPolygonBIndex = -1;","                    // Loop through all but the last polygon looking for the","                    // best polygons to merge in this iteration.","                    for (var indexA = 0; indexA < workingPolygons.length - 1; indexA++) {","                        var polygonA = workingPolygons[indexA];","                        for (var indexB = indexA + 1; indexB < workingPolygons.length; indexB++) {","                            var polygonB = workingPolygons[indexB];","                            // Can polyB merge with polyA?","                            this_1.getPolyMergeInfo(polygonA, polygonB, maxVerticesPerPolygon, workingMergeInfo);","                            if (workingMergeInfo.lengthSq > longestMergeEdge) {","                                // polyB has the longest shared edge with","                                // polyA found so far. Save the merge","                                // information.","                                longestMergeEdge = workingMergeInfo.lengthSq;","                                bestPolygonA = polygonA;","                                polygonAVertexIndex = workingMergeInfo.polygonAVertexIndex;","                                bestPolygonB = polygonB;","                                polygonBVertexIndex = workingMergeInfo.polygonBVertexIndex;","                                bestPolygonBIndex = indexB;","                            }","                        }","                    }","                    if (longestMergeEdge <= 0)","                        // No valid merges found during this iteration.","                        break;","                    // Found polygons to merge. Perform the merge.","                    /*","                        * Fill the mergedPoly array.","                        * Start the vertex at the end of polygon A's shared edge.","                        * Add all vertices until looping back to the vertex just","                        * before the start of the shared edge. Repeat for","                        * polygon B.","                        *","                        * Duplicate vertices are avoided, while ensuring we get","                        * all vertices, since each loop  drops the vertex that","                        * starts its polygon's shared edge and:","                        *","                        * PolyAStartVert == PolyBEndVert and","                        * PolyAEndVert == PolyBStartVert.","                        */","                    var vertCountA = bestPolygonA.length;","                    var vertCountB = bestPolygonB.length;","                    workingMergedPolygon.length = 0;","                    for (var i = 0; i < vertCountA - 1; i++)","                        workingMergedPolygon.push(bestPolygonA[(polygonAVertexIndex + 1 + i) % vertCountA]);","                    for (var i = 0; i < vertCountB - 1; i++)","                        workingMergedPolygon.push(bestPolygonB[(polygonBVertexIndex + 1 + i) % vertCountB]);","                    // Copy the merged polygon over the top of polygon A.","                    bestPolygonA.length = 0;","                    Array.prototype.push.apply(bestPolygonA, workingMergedPolygon);","                    // Remove polygon B","                    workingPolygons.splice(bestPolygonBIndex, 1);","                }","            }","            // Polygon creation for this contour is complete.","            // Add polygons to the global polygon array","            Array.prototype.push.apply(convexPolygons, workingPolygons);","        };","        var this_1 = this;","        // Split every concave polygon into convex polygons.","        for (var _a = 0, concavePolygons_2 = concavePolygons; _a < concavePolygons_2.length; _a++) {","            var contour = concavePolygons_2[_a];","            _loop_1(contour);","        }","        // The original implementation builds polygon adjacency information.","        // but the library for the pathfinding already does it.","        return convexPolygons;","    };","    /**","     * Checks two polygons to see if they can be merged. If a merge is","     * allowed, provides data via the outResult argument (see {@link PolyMergeResult}).","     *","     * @param polygonA The polygon A","     * @param polygonB The polygon B","     * @param maxVerticesPerPolygon cap the vertex number in return polygons.","     * @param outResult contains merge information.","     */","    ConvexPolygonGenerator.prototype.getPolyMergeInfo = function (polygonA, polygonB, maxVerticesPerPolygon, outResult) {","        outResult.lengthSq = -1; // Default to invalid merge","        outResult.polygonAVertexIndex = -1;","        outResult.polygonBVertexIndex = -1;","        var vertexCountA = polygonA.length;","        var vertexCountB = polygonB.length;","        // If the merged polygon would would have to many vertices, do not","        // merge. Subtracting two since to take into account the effect of","        // a merge.","        if (vertexCountA + vertexCountB - 2 > maxVerticesPerPolygon)","            return;","        // Check if the polygons share an edge.","        for (var indexA = 0; indexA < vertexCountA; indexA++) {","            // Get the vertex indices for the polygonA edge","            var vertexA = polygonA[indexA];","            var nextVertexA = polygonA[(indexA + 1) % vertexCountA];","            // Search polygonB for matches.","            for (var indexB = 0; indexB < vertexCountB; indexB++) {","                // Get the vertex indices for the polygonB edge.","                var vertexB = polygonB[indexB];","                var nextVertexB = polygonB[(indexB + 1) % vertexCountB];","                // === can be used because vertices comme from the same concave polygon.","                if (vertexA === nextVertexB && nextVertexA === vertexB) {","                    // The vertex indices for this edge are the same and","                    // sequenced in opposite order. So the edge is shared.","                    outResult.polygonAVertexIndex = indexA;","                    outResult.polygonBVertexIndex = indexB;","                }","            }","        }","        if (outResult.polygonAVertexIndex === -1)","            // No common edge, cannot merge.","            return;","        // Check to see if the merged polygon would be convex.","        //","        // Gets the vertices near the section where the merge would occur.","        // Do they form a concave section?  If so, the merge is invalid.","        //","        // Note that the following algorithm is only valid for clockwise","        // wrapped convex polygons.","        var sharedVertMinus = polygonA[(outResult.polygonAVertexIndex - 1 + vertexCountA) % vertexCountA];","        var sharedVert = polygonA[outResult.polygonAVertexIndex];","        var sharedVertPlus = polygonB[(outResult.polygonBVertexIndex + 2) % vertexCountB];","        if (!ConvexPolygonGenerator.isLeft(sharedVert.x, sharedVert.y, sharedVertMinus.x, sharedVertMinus.y, sharedVertPlus.x, sharedVertPlus.y)) {","            // The shared vertex (center) is not to the left of segment","            // vertMinus->vertPlus. For a clockwise wrapped polygon, this","            // indicates a concave section. Merged polygon would be concave.","            // Invalid merge.","            return;","        }","        sharedVertMinus =","            polygonB[(outResult.polygonBVertexIndex - 1 + vertexCountB) % vertexCountB];","        sharedVert = polygonB[outResult.polygonBVertexIndex];","        sharedVertPlus =","            polygonA[(outResult.polygonAVertexIndex + 2) % vertexCountA];","        if (!ConvexPolygonGenerator.isLeft(sharedVert.x, sharedVert.y, sharedVertMinus.x, sharedVertMinus.y, sharedVertPlus.x, sharedVertPlus.y)) {","            // The shared vertex (center) is not to the left of segment","            // vertMinus->vertPlus. For a clockwise wrapped polygon, this","            // indicates a concave section. Merged polygon would be concave.","            // Invalid merge.","            return;","        }","        // Get the vertex indices that form the shared edge.","        sharedVertMinus = polygonA[outResult.polygonAVertexIndex];","        sharedVert = polygonA[(outResult.polygonAVertexIndex + 1) % vertexCountA];","        // Store the lengthSq of the shared edge.","        var deltaX = sharedVertMinus.x - sharedVert.x;","        var deltaZ = sharedVertMinus.y - sharedVert.y;","        outResult.lengthSq = deltaX * deltaX + deltaZ * deltaZ;","    };","    /**","     * Attempts to triangulate a polygon.","     *","     * @param vertices the polygon to be triangulate.","     * The content is manipulated during the operation","     * and it will be left in an undefined state at the end of","     * the operation.","     * @param vertexFlags only used internally","     * @param outTriangles is called for each triangle derived","     * from the original polygon.","     * @return The number of triangles generated. Or, if triangulation","     * failed, a negative number.","     */","    ConvexPolygonGenerator.prototype.triangulate = function (vertices, vertexFlags, outTriangles) {","        // Terminology, concepts and such:","        //","        // This algorithm loops around the edges of a polygon looking for","        // new internal edges to add that will partition the polygon into a","        // new valid triangle internal to the starting polygon. During each","        // iteration the shortest potential new edge is selected to form that","        // iteration's new triangle.","        //","        // Triangles will only be formed if a single new edge will create","        // a triangle. Two new edges will never be added during a single","        // iteration. This means that the triangulated portions of the","        // original polygon will only contain triangles and the only","        // non-triangle polygon will exist in the untriangulated portion","        // of the original polygon.","        //","        // \"Partition edge\" refers to a potential new edge that will form a","        // new valid triangle.","        //","        // \"Center\" vertex refers to the vertex in a potential new triangle","        // which, if the triangle is formed, will be external to the","        // remaining untriangulated portion of the polygon. Since it","        // is now external to the polygon, it can't be used to form any","        // new triangles.","        //","        // Some documentation refers to \"iPlus2\" even though the variable is","        // not in scope or does not exist for that section of code. For","        // documentation purposes, iPlus2 refers to the 2nd vertex after the","        // primary vertex.","        // E.g.: i, iPlus1, and iPlus2.","        //","        // Visualizations: http://www.critterai.org/projects/nmgen_study/polygen.html#triangulation","        // Loop through all vertices, flagging all indices that represent","        // a center vertex of a valid new triangle.","        vertexFlags.length = vertices.length;","        for (var i = 0; i < vertices.length; i++) {","            var iPlus1 = (i + 1) % vertices.length;","            var iPlus2 = (i + 2) % vertices.length;","            // A triangle formed by i, iPlus1, and iPlus2 will result","            // in a valid internal triangle.","            // Flag the center vertex (iPlus1) to indicate a valid triangle","            // location.","            vertexFlags[iPlus1] = ConvexPolygonGenerator.isValidPartition(i, iPlus2, vertices);","        }","        // Loop through the vertices creating triangles. When there is only a","        // single triangle left,  the operation is complete.","        //","        // When a valid triangle is formed, remove its center vertex. So for","        // each loop, a single vertex will be removed.","        //","        // At the start of each iteration the indices list is in the following","        // state:","        // - Represents a simple polygon representing the un-triangulated","        //   portion of the original polygon.","        // - All valid center vertices are flagged.","        while (vertices.length > 3) {","            // Find the shortest new valid edge.","            // NOTE: i and iPlus1 are defined in two different scopes in","            // this section. So be careful.","            // Loop through all indices in the remaining polygon.","            var minLengthSq = Number.MAX_VALUE;","            var minLengthSqVertexIndex = -1;","            for (var i_1 = 0; i_1 < vertices.length; i_1++) {","                if (vertexFlags[(i_1 + 1) % vertices.length]) {","                    // Indices i, iPlus1, and iPlus2 are known to form a","                    // valid triangle.","                    var vert = vertices[i_1];","                    var vertPlus2 = vertices[(i_1 + 2) % vertices.length];","                    // Determine the length of the partition edge.","                    // (i -> iPlus2)","                    var deltaX = vertPlus2.x - vert.x;","                    var deltaY = vertPlus2.y - vert.y;","                    var lengthSq = deltaX * deltaX + deltaY * deltaY;","                    if (lengthSq < minLengthSq) {","                        minLengthSq = lengthSq;","                        minLengthSqVertexIndex = i_1;","                    }","                }","            }","            if (minLengthSqVertexIndex === -1)","                // Could not find a new triangle. Triangulation failed.","                // This happens if there are three or more vertices","                // left, but none of them are flagged as being a","                // potential center vertex.","                return;","            var i = minLengthSqVertexIndex;","            var iPlus1 = (i + 1) % vertices.length;","            // Add the new triangle to the output.","            outTriangles(vertices[i], vertices[iPlus1], vertices[(i + 2) % vertices.length]);","            // iPlus1, the \"center\" vert in the new triangle, is now external","            // to the untriangulated portion of the polygon. Remove it from","            // the vertices list since it cannot be a member of any new","            // triangles.","            vertices.splice(iPlus1, 1);","            vertexFlags.splice(iPlus1, 1);","            if (iPlus1 === 0 || iPlus1 >= vertices.length) {","                // The vertex removal has invalidated iPlus1 and/or i. So","                // force a wrap, fixing the indices so they reference the","                // correct indices again. This only occurs when the new","                // triangle is formed across the wrap location of the polygon.","                // Case 1: i = 14, iPlus1 = 15, iPlus2 = 0","                // Case 2: i = 15, iPlus1 = 0, iPlus2 = 1;","                i = vertices.length - 1;","                iPlus1 = 0;","            }","            // At this point i and iPlus1 refer to the two indices from a","            // successful triangulation that will be part of another new","            // triangle. We now need to re-check these indices to see if they","            // can now be the center index in a potential new partition.","            vertexFlags[i] = ConvexPolygonGenerator.isValidPartition((i - 1 + vertices.length) % vertices.length, iPlus1, vertices);","            vertexFlags[iPlus1] = ConvexPolygonGenerator.isValidPartition(i, (i + 2) % vertices.length, vertices);","        }","        // Only 3 vertices remain.","        // Add their triangle to the output list.","        outTriangles(vertices[0], vertices[1], vertices[2]);","    };","    /**","     * Check if the line segment formed by vertex A and vertex B will","     * form a valid partition of the polygon.","     *","     * I.e. the line segment AB is internal to the polygon and will not","     * cross existing line segments.","     *","     * Assumptions:","     * - The vertices arguments define a valid simple polygon","     * with vertices wrapped clockwise.","     * - indexA != indexB","     *","     * Behavior is undefined if the arguments to not meet these","     * assumptions","     *","     * @param indexA the index of the vertex that will form the segment AB.","     * @param indexB the index of the vertex that will form the segment AB.","     * @param vertices a polygon wrapped clockwise.","     * @return true if the line segment formed by vertex A and vertex B will","     * form a valid partition of the polygon.","     */","    ConvexPolygonGenerator.isValidPartition = function (indexA, indexB, vertices) {","        //  First check whether the segment AB lies within the internal","        //  angle formed at A (this is the faster check).","        //  If it does, then perform the more costly check.","        return (ConvexPolygonGenerator.liesWithinInternalAngle(indexA, indexB, vertices) &&","            !ConvexPolygonGenerator.hasIllegalEdgeIntersection(indexA, indexB, vertices));","    };","    /**","     * Check if vertex B lies within the internal angle of the polygon","     * at vertex A.","     *","     * Vertex B does not have to be within the polygon border. It just has","     * be be within the area encompassed by the internal angle formed at","     * vertex A.","     *","     * This operation is a fast way of determining whether a line segment","     * can possibly form a valid polygon partition. If this test returns","     * FALSE, then more expensive checks can be skipped.","     *","     * Visualizations: http://www.critterai.org/projects/nmgen_study/polygen.html#anglecheck","     *","     * Special case:","     * FALSE is returned if vertex B lies directly on either of the rays","     * cast from vertex A along its associated polygon edges. So the test","     * on vertex B is exclusive of the polygon edges.","     *","     * Assumptions:","     * - The vertices and indices arguments define a valid simple polygon","     * with vertices wrapped clockwise.","     * -indexA != indexB","     *","     * Behavior is undefined if the arguments to not meet these","     * assumptions","     *","     * @param indexA the index of the vertex that will form the segment AB.","     * @param indexB the index of the vertex that will form the segment AB.","     * @param vertices a polygon wrapped clockwise.","     * @return true if vertex B lies within the internal angle of","     * the polygon at vertex A.","     */","    ConvexPolygonGenerator.liesWithinInternalAngle = function (indexA, indexB, vertices) {","        // Get pointers to the main vertices being tested.","        var vertexA = vertices[indexA];","        var vertexB = vertices[indexB];","        // Get pointers to the vertices just before and just after vertA.","        var vertexAMinus = vertices[(indexA - 1 + vertices.length) % vertices.length];","        var vertexAPlus = vertices[(indexA + 1) % vertices.length];","        // First, find which of the two angles formed by the line segments","        //  AMinus->A->APlus is internal to (pointing towards) the polygon.","        // Then test to see if B lies within the area formed by that angle.","        // TRUE if A is left of or on line AMinus->APlus","        if (ConvexPolygonGenerator.isLeftOrCollinear(vertexA.x, vertexA.y, vertexAMinus.x, vertexAMinus.y, vertexAPlus.x, vertexAPlus.y))","            // The angle internal to the polygon is <= 180 degrees","            // (non-reflex angle).","            // Test to see if B lies within this angle.","            return (ConvexPolygonGenerator.isLeft(","            // TRUE if B is left of line A->AMinus","            vertexB.x, vertexB.y, vertexA.x, vertexA.y, vertexAMinus.x, vertexAMinus.y) &&","                // TRUE if B is right of line A->APlus","                ConvexPolygonGenerator.isRight(vertexB.x, vertexB.y, vertexA.x, vertexA.y, vertexAPlus.x, vertexAPlus.y));","        // The angle internal to the polygon is > 180 degrees (reflex angle).","        // Test to see if B lies within the external (<= 180 degree) angle and","        // flip the result. (If B lies within the external angle, it can't","        // lie within the internal angle)","        return !(","        // TRUE if B is left of or on line A->APlus","        (ConvexPolygonGenerator.isLeftOrCollinear(vertexB.x, vertexB.y, vertexA.x, vertexA.y, vertexAPlus.x, vertexAPlus.y) &&","            // TRUE if B is right of or on line A->AMinus","            ConvexPolygonGenerator.isRightOrCollinear(vertexB.x, vertexB.y, vertexA.x, vertexA.y, vertexAMinus.x, vertexAMinus.y)));","    };","    /**","     * Check if the line segment AB intersects any edges not already","     * connected to one of the two vertices.","     *","     * Assumptions:","     * - The vertices and indices arguments define a valid simple polygon","     * with vertices wrapped clockwise.","     * - indexA != indexB","     *","     * Behavior is undefined if the arguments to not meet these","     * assumptions","     *","     * @param indexA the index of the vertex that will form the segment AB.","     * @param indexB the index of the vertex that will form the segment AB.","     * @param vertices a polygon wrapped clockwise.","     * @return true if the line segment AB intersects any edges not already","     * connected to one of the two vertices.","     */","    ConvexPolygonGenerator.hasIllegalEdgeIntersection = function (indexA, indexB, vertices) {","        // Get pointers to the primary vertices being tested.","        var vertexA = vertices[indexA];","        var vertexB = vertices[indexB];","        // Loop through the polygon edges.","        for (var edgeBeginIndex = 0; edgeBeginIndex < vertices.length; edgeBeginIndex++) {","            var edgeEndIndex = (edgeBeginIndex + 1) % vertices.length;","            if (edgeBeginIndex === indexA ||","                edgeBeginIndex === indexB ||","                edgeEndIndex === indexA ||","                edgeEndIndex === indexB) {","                continue;","            }","            // Neither of the test indices are endpoints of this edge.","            // Get this edge's vertices.","            var edgeBegin = vertices[edgeBeginIndex];","            var edgeEnd = vertices[edgeEndIndex];","            if ((edgeBegin.x === vertexA.x && edgeBegin.y === vertexA.y) ||","                (edgeBegin.x === vertexB.x && edgeBegin.y === vertexB.y) ||","                (edgeEnd.x === vertexA.x && edgeEnd.y === vertexA.y) ||","                (edgeEnd.x === vertexB.x && edgeEnd.y === vertexB.y)) {","                // One of the test vertices is co-located","                // with one of the endpoints of this edge (this is a","                // test of the actual position of the vertices rather than","                // simply the index check performed earlier).","                // Skip this edge.","                continue;","            }","            // This edge is not connected to either of the test vertices.","            // If line segment AB intersects  with this edge, then the","            // intersection is illegal.","            // I.e. New edges cannot cross existing edges.","            if (Geometry.segmentsIntersect(vertexA.x, vertexA.y, vertexB.x, vertexB.y, edgeBegin.x, edgeBegin.y, edgeEnd.x, edgeEnd.y)) {","                return true;","            }","        }","        return false;","    };","    /**","     * Check if point P is to the left of line AB when looking","     * from A to B.","     * @param px The x-value of the point to test.","     * @param py The y-value of the point to test.","     * @param ax The x-value of the point (ax, ay) that is point A on line AB.","     * @param ay The y-value of the point (ax, ay) that is point A on line AB.","     * @param bx The x-value of the point (bx, by) that is point B on line AB.","     * @param by The y-value of the point (bx, by) that is point B on line AB.","     * @return TRUE if point P is to the left of line AB when looking","     * from A to B.","     */","    ConvexPolygonGenerator.isLeft = function (px, py, ax, ay, bx, by) {","        return ConvexPolygonGenerator.getSignedAreaX2(ax, ay, px, py, bx, by) < 0;","    };","    /**","     * Check if point P is to the left of line AB when looking","     * from A to B or is collinear with line AB.","     * @param px The x-value of the point to test.","     * @param py The y-value of the point to test.","     * @param ax The x-value of the point (ax, ay) that is point A on line AB.","     * @param ay The y-value of the point (ax, ay) that is point A on line AB.","     * @param bx The x-value of the point (bx, by) that is point B on line AB.","     * @param by The y-value of the point (bx, by) that is point B on line AB.","     * @return TRUE if point P is to the left of line AB when looking","     * from A to B, or is collinear with line AB.","     */","    ConvexPolygonGenerator.isLeftOrCollinear = function (px, py, ax, ay, bx, by) {","        return ConvexPolygonGenerator.getSignedAreaX2(ax, ay, px, py, bx, by) <= 0;","    };","    /**","     * Check if point P is to the right of line AB when looking","     * from A to B.","     * @param px The x-value of the point to test.","     * @param py The y-value of the point to test.","     * @param ax The x-value of the point (ax, ay) that is point A on line AB.","     * @param ay The y-value of the point (ax, ay) that is point A on line AB.","     * @param bx The x-value of the point (bx, by) that is point B on line AB.","     * @param by The y-value of the point (bx, by) that is point B on line AB.","     * @return TRUE if point P is to the right of line AB when looking","     * from A to B.","     */","    ConvexPolygonGenerator.isRight = function (px, py, ax, ay, bx, by) {","        return ConvexPolygonGenerator.getSignedAreaX2(ax, ay, px, py, bx, by) > 0;","    };","    /**","     * Check if point P is to the right of or on line AB when looking","     * from A to B.","     * @param px The x-value of the point to test.","     * @param py The y-value of the point to test.","     * @param ax The x-value of the point (ax, ay) that is point A on line AB.","     * @param ay The y-value of the point (ax, ay) that is point A on line AB.","     * @param bx The x-value of the point (bx, by) that is point B on line AB.","     * @param by The y-value of the point (bx, by) that is point B on line AB.","     * @return TRUE if point P is to the right of or on line AB when looking","     * from A to B.","     */","    ConvexPolygonGenerator.isRightOrCollinear = function (px, py, ax, ay, bx, by) {","        return ConvexPolygonGenerator.getSignedAreaX2(ax, ay, px, py, bx, by) >= 0;","    };","    /**","     * The absolute value of the returned value is two times the area of the","     * triangle defined by points (A, B, C).","     *","     * A positive value indicates:","     * - Counterclockwise wrapping of the points.","     * - Point B lies to the right of line AC, looking from A to C.","     *","     * A negative value indicates:","     * - Clockwise wrapping of the points.<","     * - Point B lies to the left of line AC, looking from A to C.","     *","     * A value of zero indicates that all points are collinear or","     * represent the same point.","     *","     * This is a fast operation.","     *","     * @param ax The x-value for point (ax, ay) for vertex A of the triangle.","     * @param ay The y-value for point (ax, ay) for vertex A of the triangle.","     * @param bx The x-value for point (bx, by) for vertex B of the triangle.","     * @param by The y-value for point (bx, by) for vertex B of the triangle.","     * @param cx The x-value for point (cx, cy) for vertex C of the triangle.","     * @param cy The y-value for point (cx, cy) for vertex C of the triangle.","     * @return The signed value of two times the area of the triangle defined","     * by the points (A, B, C).","     */","    ConvexPolygonGenerator.getSignedAreaX2 = function (ax, ay, bx, by, cx, cy) {","        // References:","        // http://softsurfer.com/Archive/algorithm_0101/algorithm_0101.htm#Modern%20Triangles","        // http://mathworld.wolfram.com/TriangleArea.html (Search for \"signed\")","        return (bx - ax) * (cy - ay) - (cx - ax) * (by - ay);","    };","    return ConvexPolygonGenerator;","}());","","var GridCoordinateConverter = /** @class */ (function () {","    function GridCoordinateConverter() {","    }","    /**","     *","     * @param gridPosition the position on the grid","     * @param position the position on the scene","     * @param scaleY for isometry","     * @returns the position on the scene","     */","    GridCoordinateConverter.prototype.convertFromGridBasis = function (grid, polygons) {","        // point can be shared so them must be copied to be scaled.","        return polygons.map(function (polygon) {","            return polygon.map(function (point) { return grid.convertFromGridBasis(point, { x: 0, y: 0 }); });","        });","    };","    return GridCoordinateConverter;","}());","","/**"," * It rasterizes obstacles on a grid."," *"," * It flags cells as obstacle to be used by {@link RegionGenerator}."," */","var ObstacleRasterizer = /** @class */ (function () {","    function ObstacleRasterizer() {","        this.workingNodes = new Array(8);","        this.gridBasisIterable = new GridBasisIterable();","    }","    /**","     * Rasterize obstacles on a grid.","     * @param grid","     * @param obstacles","     */","    ObstacleRasterizer.prototype.rasterizeObstacles = function (grid, obstacles) {","        var obstaclesItr = obstacles[Symbol.iterator]();","        for (var next = obstaclesItr.next(); !next.done; next = obstaclesItr.next()) {","            var obstacle = next.value;","            this.gridBasisIterable.set(grid, obstacle);","            var vertices = this.gridBasisIterable;","            var minX = Number.MAX_VALUE;","            var maxX = -Number.MAX_VALUE;","            var minY = Number.MAX_VALUE;","            var maxY = -Number.MAX_VALUE;","            var verticesItr = vertices[Symbol.iterator]();","            for (var next_1 = verticesItr.next(); !next_1.done; next_1 = verticesItr.next()) {","                var vertex = next_1.value;","                minX = Math.min(minX, vertex.x);","                maxX = Math.max(maxX, vertex.x);","                minY = Math.min(minY, vertex.y);","                maxY = Math.max(maxY, vertex.y);","            }","            minX = Math.max(Math.floor(minX), 0);","            maxX = Math.min(Math.ceil(maxX), grid.dimX());","            minY = Math.max(Math.floor(minY), 0);","            maxY = Math.min(Math.ceil(maxY), grid.dimY());","            this.fillPolygon(vertices, minX, maxX, minY, maxY, function (x, y) { return (grid.get(x, y).distanceToObstacle = 0); });","        }","    };","    ObstacleRasterizer.prototype.fillPolygon = function (vertices, minX, maxX, minY, maxY, fill) {","        // The following implementation of the scan-line polygon fill algorithm","        // is strongly inspired from:","        // https://alienryderflex.com/polygon_fill/","        // The original implementation was under this license:","        // public-domain code by Darel Rex Finley, 2007","        // This implementation differ with the following:","        // - it handles float vertices","        //   so it focus on pixels center","        // - it is conservative to thin vertical or horizontal polygons","        var fillAnyPixels = false;","        this.scanY(vertices, minX, maxX, minY, maxY, function (pixelY, minX, maxX) {","            for (var pixelX = minX; pixelX < maxX; pixelX++) {","                fillAnyPixels = true;","                fill(pixelX, pixelY);","            }","        });","        if (fillAnyPixels) {","            return;","        }","        this.scanY(vertices, minX, maxX, minY, maxY, function (pixelY, minX, maxX) {","            // conserve thin (less than one cell large) horizontal polygons","            if (minX === maxX) {","                fill(minX, pixelY);","            }","        });","        this.scanX(vertices, minX, maxX, minY, maxY, function (pixelX, minY, maxY) {","            for (var pixelY = minY; pixelY < maxY; pixelY++) {","                fill(pixelX, pixelY);","            }","            // conserve thin (less than one cell large) vertical polygons","            if (minY === maxY) {","                fill(pixelX, minY);","            }","        });","    };","    ObstacleRasterizer.prototype.scanY = function (vertices, minX, maxX, minY, maxY, checkAndFillY) {","        var workingNodes = this.workingNodes;","        //  Loop through the rows of the image.","        for (var pixelY = minY; pixelY < maxY; pixelY++) {","            var pixelCenterY = pixelY + 0.5;","            //  Build a list of nodes.","            workingNodes.length = 0;","            //let j = vertices.length - 1;","            var verticesItr = vertices[Symbol.iterator]();","            var next = verticesItr.next();","            var vertex = next.value;","            // The iterator always return the same instance.","            // It must be copied to be save for later.","            var firstVertexX = vertex.x;","            var firstVertexY = vertex.y;","            while (!next.done) {","                var previousVertexX = vertex.x;","                var previousVertexY = vertex.y;","                next = verticesItr.next();","                if (next.done) {","                    vertex.x = firstVertexX;","                    vertex.y = firstVertexY;","                }","                else {","                    vertex = next.value;","                }","                if ((vertex.y <= pixelCenterY && pixelCenterY < previousVertexY) ||","                    (previousVertexY < pixelCenterY && pixelCenterY <= vertex.y)) {","                    workingNodes.push(Math.round(vertex.x +","                        ((pixelCenterY - vertex.y) / (previousVertexY - vertex.y)) *","                            (previousVertexX - vertex.x)));","                }","            }","            //  Sort the nodes, via a simple “Bubble” sort.","            {","                var i = 0;","                while (i < workingNodes.length - 1) {","                    if (workingNodes[i] > workingNodes[i + 1]) {","                        var swap = workingNodes[i];","                        workingNodes[i] = workingNodes[i + 1];","                        workingNodes[i + 1] = swap;","                        if (i > 0)","                            i--;","                    }","                    else {","                        i++;","                    }","                }","            }","            //  Fill the pixels between node pairs.","            for (var i = 0; i < workingNodes.length; i += 2) {","                if (workingNodes[i] >= maxX) {","                    break;","                }","                if (workingNodes[i + 1] <= minX) {","                    continue;","                }","                if (workingNodes[i] < minX) {","                    workingNodes[i] = minX;","                }","                if (workingNodes[i + 1] > maxX) {","                    workingNodes[i + 1] = maxX;","                }","                checkAndFillY(pixelY, workingNodes[i], workingNodes[i + 1]);","            }","        }","    };","    ObstacleRasterizer.prototype.scanX = function (vertices, minX, maxX, minY, maxY, checkAndFillX) {","        var workingNodes = this.workingNodes;","        //  Loop through the columns of the image.","        for (var pixelX = minX; pixelX < maxX; pixelX++) {","            var pixelCenterX = pixelX + 0.5;","            //  Build a list of nodes.","            workingNodes.length = 0;","            var verticesItr = vertices[Symbol.iterator]();","            var next = verticesItr.next();","            var vertex = next.value;","            // The iterator always return the same instance.","            // It must be copied to be save for later.","            var firstVertexX = vertex.x;","            var firstVertexY = vertex.y;","            while (!next.done) {","                var previousVertexX = vertex.x;","                var previousVertexY = vertex.y;","                next = verticesItr.next();","                if (next.done) {","                    vertex.x = firstVertexX;","                    vertex.y = firstVertexY;","                }","                else {","                    vertex = next.value;","                }","                if ((vertex.x < pixelCenterX && pixelCenterX < previousVertexX) ||","                    (previousVertexX < pixelCenterX && pixelCenterX < vertex.x)) {","                    workingNodes.push(Math.round(vertex.y +","                        ((pixelCenterX - vertex.x) / (previousVertexX - vertex.x)) *","                            (previousVertexY - vertex.y)));","                }","            }","            //  Sort the nodes, via a simple “Bubble” sort.","            {","                var i = 0;","                while (i < workingNodes.length - 1) {","                    if (workingNodes[i] > workingNodes[i + 1]) {","                        var swap = workingNodes[i];","                        workingNodes[i] = workingNodes[i + 1];","                        workingNodes[i + 1] = swap;","                        if (i > 0)","                            i--;","                    }","                    else {","                        i++;","                    }","                }","            }","            //  Fill the pixels between node pairs.","            for (var i = 0; i < workingNodes.length; i += 2) {","                if (workingNodes[i] >= maxY) {","                    break;","                }","                if (workingNodes[i + 1] <= minY) {","                    continue;","                }","                if (workingNodes[i] < minY) {","                    workingNodes[i] = minY;","                }","                if (workingNodes[i + 1] > maxY) {","                    workingNodes[i + 1] = maxY;","                }","                checkAndFillX(pixelX, workingNodes[i], workingNodes[i + 1]);","            }","        }","    };","    return ObstacleRasterizer;","}());","/**"," * Iterable that converts coordinates to the grid."," *"," * This is an allocation free iterable"," * that can only do one iteration at a time."," */","var GridBasisIterable = /** @class */ (function () {","    function GridBasisIterable() {","        this.grid = null;","        this.sceneVertices = [];","        this.verticesItr = this.sceneVertices[Symbol.iterator]();","        this.result = {","            value: { x: 0, y: 0 },","            done: false,","        };","    }","    GridBasisIterable.prototype.set = function (grid, sceneVertices) {","        this.grid = grid;","        this.sceneVertices = sceneVertices;","    };","    GridBasisIterable.prototype[Symbol.iterator] = function () {","        this.verticesItr = this.sceneVertices[Symbol.iterator]();","        return this;","    };","    GridBasisIterable.prototype.next = function () {","        var next = this.verticesItr.next();","        if (next.done) {","            return next;","        }","        this.grid.convertToGridBasis(next.value, this.result.value);","        return this.result;","    };","    return GridBasisIterable;","}());","","/**"," * Build cohesive regions from the non-obstacle space. It uses the data"," * from the obstacles rasterization {@link ObstacleRasterizer}."," *"," * This implementation is strongly inspired from CritterAI class \"OpenHeightfieldBuilder\"."," *"," * Introduction to Height Fields: http://www.critterai.org/projects/nmgen_study/heightfields.html"," *"," * Region Generation: http://www.critterai.org/projects/nmgen_study/regiongen.html"," */","var RegionGenerator = /** @class */ (function () {","    function RegionGenerator() {","        this.obstacleRegionBordersCleaner = new ObstacleRegionBordersCleaner();","        this.floodedCells = new Array(1024);","        this.workingStack = new Array(1024);","    }","    //TODO implement the smoothing pass on the distance field?","    /**","     * Groups cells into cohesive regions using an watershed based algorithm.","     *","     * This operation depends on neighbor and distance field information.","     * So {@link RegionGenerator.generateDistanceField} operations must be","     * run before this operation.","     *","     * @param grid A field with cell distance information fully generated.","     * @param obstacleCellPadding a padding in cells to apply around the","     * obstacles.","     */","    RegionGenerator.prototype.generateRegions = function (grid, obstacleCellPadding) {","        // Watershed Algorithm","        //","        // Reference: http://en.wikipedia.org/wiki/Watershed_%28algorithm%29","        // A good visualization:","        // http://artis.imag.fr/Publications/2003/HDS03/ (PDF)","        //","        // Summary:","        //","        // This algorithm utilizes the cell.distanceToObstacle value, which","        // is generated by the generateDistanceField() operation.","        //","        // Using the watershed analogy, the cells which are furthest from","        // a border (highest distance to border) represent the lowest points","        // in the watershed. A border cell represents the highest possible","        // water level.","        //","        // The main loop iterates, starting at the lowest point in the","        // watershed, then incrementing with each loop until the highest","        // allowed water level is reached. This slowly \"floods\" the cells","        // starting at the lowest points.","        //","        // During each iteration of the loop, cells that are below the","        // current water level are located and an attempt is made to either","        // add them to exiting regions or create new regions from them.","        //","        // During the region expansion phase, if a newly flooded cell","        // borders on an existing region, it is usually added to the region.","        //","        // Any newly flooded cell that survives the region expansion phase","        // is used as a seed for a new region.","        //","        // At the end of the main loop, a final region expansion is","        // performed which should catch any stray cells that escaped region","        // assignment during the main loop.","        // Represents the minimum distance to an obstacle that is considered","        // traversable. I.e. Can't traverse cells closer than this distance","        // to a border. This provides a way of artificially capping the","        // height to which watershed flooding can occur.","        // I.e. Don't let the algorithm flood all the way to the actual border.","        //","        // We add the minimum border distance to take into account the","        // blurring algorithm which can result in a border cell having a","        // border distance > 0.","        var distanceMin = obstacleCellPadding * 2;","        // TODO: EVAL: Figure out why this iteration limit is needed","        // (todo from the CritterAI sources).","        var expandIterations = 4 + distanceMin * 2;","        // Zero is reserved for the obstacle-region. So initializing to 1.","        var nextRegionID = 1;","        var floodedCells = this.floodedCells;","        // Search until the current distance reaches the minimum allowed","        // distance.","        //","        // Note: This loop will not necessarily complete all region","        // assignments. This is OK since a final region assignment step","        // occurs after the loop iteration is complete.","        for (","        // This value represents the current distance from the border which","        // is to be searched. The search starts at the maximum distance then","        // moves toward zero (toward borders).","        //","        // This number will always be divisible by 2.","        var distance = grid.obstacleDistanceMax() & ~1; distance > distanceMin; distance = Math.max(distance - 2, 0)) {","            // Find all cells that are at or below the current \"water level\"","            // and are not already assigned to a region. Add these cells to","            // the flooded cell list for processing.","            floodedCells.length = 0;","            for (var y = 1; y < grid.dimY() - 1; y++) {","                for (var x = 1; x < grid.dimX() - 1; x++) {","                    var cell = grid.get(x, y);","                    if (cell.regionID === RasterizationCell.NULL_REGION_ID &&","                        cell.distanceToObstacle >= distance) {","                        // The cell is not already assigned a region and is","                        // below the current \"water level\". So the cell can be","                        // considered for region assignment.","                        floodedCells.push(cell);","                    }","                }","            }","            if (nextRegionID > 1) {","                // At least one region has already been created, so first","                // try to  put the newly flooded cells into existing regions.","                if (distance > 0) {","                    this.expandRegions(grid, floodedCells, expandIterations);","                }","                else {","                    this.expandRegions(grid, floodedCells, -1);","                }","            }","            // Create new regions for all cells that could not be added to","            // existing regions.","            for (var _i = 0, floodedCells_1 = floodedCells; _i < floodedCells_1.length; _i++) {","                var floodedCell = floodedCells_1[_i];","                if (!floodedCell ||","                    floodedCell.regionID !== RasterizationCell.NULL_REGION_ID) {","                    // This cell was assigned to a newly created region","                    // during an earlier iteration of this loop.","                    // So it can be skipped.","                    continue;","                }","                // Fill to slightly more than the current \"water level\".","                // This improves efficiency of the algorithm.","                // And it is necessary with the conservative expansion to ensure that","                // more than one cell is added initially to a new regions otherwise","                // no cell could be added to it later because of the conservative","                // constraint.","                var fillTo = Math.max(distance - 2, distanceMin + 1, 1);","                if (this.floodNewRegion(grid, floodedCell, fillTo, nextRegionID)) {","                    nextRegionID++;","                }","            }","        }","        // Find all cells that haven't been assigned regions by the main loop","        // (up to the minimum distance).","        floodedCells.length = 0;","        for (var y = 1; y < grid.dimY() - 1; y++) {","            for (var x = 1; x < grid.dimX() - 1; x++) {","                var cell = grid.get(x, y);","                if (cell.distanceToObstacle > distanceMin &&","                    cell.regionID === RasterizationCell.NULL_REGION_ID) {","                    // Not a border or obstacle region cell. Should be in a region.","                    floodedCells.push(cell);","                }","            }","        }","        // Perform a final expansion of existing regions.","        // Allow more iterations than normal for this last expansion.","        if (distanceMin > 0) {","            this.expandRegions(grid, floodedCells, expandIterations * 8);","        }","        else {","            this.expandRegions(grid, floodedCells, -1);","        }","        grid.regionCount = nextRegionID;","        this.obstacleRegionBordersCleaner.fixObstacleRegion(grid);","        //TODO Also port FilterOutSmallRegions?","        // The algorithm to remove vertices in the middle (added at the end of","        // ContourBuilder.buildContours) may already filter them and contour are","        // faster to process than cells.","    };","    /**","     * Attempts to find the most appropriate regions to attach cells to.","     *","     * Any cells successfully attached to a region will have their list","     * entry set to null. So any non-null entries in the list will be cells","     * for which a region could not be determined.","     *","     * @param grid","     * @param inoutCells As input, the list of cells available for formation","     * of new regions. As output, the cells that could not be assigned","     * to new regions.","     * @param maxIterations If set to -1, will iterate through completion.","     */","    RegionGenerator.prototype.expandRegions = function (grid, inoutCells, iterationMax) {","        if (inoutCells.length === 0)","            return;","        var skipped = 0;","        for (var iteration = 0; (iteration < iterationMax || iterationMax === -1) &&","            // All cells have either been processed or could not be","            // processed during the last cycle.","            skipped < inoutCells.length; iteration++) {","            // The number of cells in the working list that have been","            // successfully processed or could not be processed successfully","            // for some reason.","            // This value controls when iteration ends.","            skipped = 0;","            for (var index = 0; index < inoutCells.length; index++) {","                var cell = inoutCells[index];","                if (cell === null) {","                    // The cell originally at this index location has","                    // already been successfully assigned a region. Nothing","                    // else to do with it.","                    skipped++;","                    continue;","                }","                // Default to unassigned.","                var cellRegion = RasterizationCell.NULL_REGION_ID;","                var regionCenterDist = Number.MAX_VALUE;","                for (var _i = 0, _a = RasterizationGrid.neighbor4Deltas; _i < _a.length; _i++) {","                    var delta = _a[_i];","                    var neighbor = grid.get(cell.x + delta.x, cell.y + delta.y);","                    if (neighbor.regionID !== RasterizationCell.NULL_REGION_ID) {","                        if (neighbor.distanceToRegionCore + 2 < regionCenterDist) {","                            // This neighbor is closer to its region core","                            // than previously detected neighbors.","                            // Conservative expansion constraint:","                            // Check to ensure that this neighbor has","                            // at least two other neighbors in its region.","                            // This makes sure that adding this cell to","                            // this neighbor's  region will not result","                            // in a single width line of cells.","                            var sameRegionCount = 0;","                            for (var neighborDirection = 0; neighborDirection < 4; neighborDirection++) {","                                var nnCell = grid.getNeighbor(neighbor, neighborDirection);","                                // There is a diagonal-neighbor","                                if (nnCell.regionID === neighbor.regionID) {","                                    // This neighbor has a neighbor in","                                    // the same region.","                                    sameRegionCount++;","                                }","                            }","                            if (sameRegionCount > 1) {","                                cellRegion = neighbor.regionID;","                                regionCenterDist = neighbor.distanceToRegionCore + 2;","                            }","                        }","                    }","                }","                if (cellRegion !== RasterizationCell.NULL_REGION_ID) {","                    // Found a suitable region for this cell to belong to.","                    // Mark this index as having been processed.","                    inoutCells[index] = null;","                    cell.regionID = cellRegion;","                    cell.distanceToRegionCore = regionCenterDist;","                }","                else {","                    // Could not find an existing region for this cell.","                    skipped++;","                }","            }","        }","    };","    /**","     * Creates a new region surrounding a cell, adding neighbor cells to the","     * new region as appropriate.","     *","     * The new region creation will fail if the root cell is on the","     * border of an existing region.","     *","     * All cells added to the new region as part of this process become","     * \"core\" cells with a distance to region core of zero.","     *","     * @param grid","     * @param rootCell The cell used to seed the new region.","     * @param fillToDist The watershed distance to flood to.","     * @param regionID The region ID to use for the new region","     * (if creation is successful).","     * @return true if a new region was created.","     */","    RegionGenerator.prototype.floodNewRegion = function (grid, rootCell, fillToDist, regionID) {","        var workingStack = this.workingStack;","        workingStack.length = 0;","        workingStack.push(rootCell);","        rootCell.regionID = regionID;","        rootCell.distanceToRegionCore = 0;","        var regionSize = 0;","        var cell;","        while ((cell = workingStack.pop())) {","            // Check regions of neighbor cells.","            //","            // If any neighbor is found to have a region assigned, then","            // the current cell can't be in the new region","            // (want standard flooding algorithm to handle deciding which","            // region this cell should go in).","            //","            // Up to 8 neighbors are checked.","            //","            // Neighbor searches:","            // http://www.critterai.org/projects/nmgen_study/heightfields.html#nsearch","            var isOnRegionBorder = false;","            for (var _i = 0, _a = RasterizationGrid.neighbor8Deltas; _i < _a.length; _i++) {","                var delta = _a[_i];","                var neighbor = grid.get(cell.x + delta.x, cell.y + delta.y);","                isOnRegionBorder =","                    neighbor.regionID !== RasterizationCell.NULL_REGION_ID &&","                        neighbor.regionID !== regionID;","                if (isOnRegionBorder)","                    break;","            }","            if (isOnRegionBorder) {","                cell.regionID = RasterizationCell.NULL_REGION_ID;","                continue;","            }","            regionSize++;","            // If got this far, we know the current cell is part of the new","            // region. Now check its neighbors to see if they should be","            // assigned to this new region.","            for (var _b = 0, _c = RasterizationGrid.neighbor4Deltas; _b < _c.length; _b++) {","                var delta = _c[_b];","                var neighbor = grid.get(cell.x + delta.x, cell.y + delta.y);","                if (neighbor.distanceToObstacle >= fillToDist &&","                    neighbor.regionID === RasterizationCell.NULL_REGION_ID) {","                    neighbor.regionID = regionID;","                    neighbor.distanceToRegionCore = 0;","                    workingStack.push(neighbor);","                }","            }","        }","        return regionSize > 0;","    };","    /**","     * Generates distance field information.","     * The {@link RasterizationCell.distanceToObstacle} information is generated","     * for all cells in the field.","     *","     * All distance values are relative and do not represent explicit","     * distance values (such as grid unit distance). The algorithm which is","     * used results in an approximation only. It is not exhaustive.","     *","     * The data generated by this operation is required by","     * {@link RegionGenerator.generateRegions}.","     *","     * @param grid A field with cells obstacle information already generated.","     */","    RegionGenerator.prototype.generateDistanceField = function (grid) {","        // close borders","        for (var x = 0; x < grid.dimX(); x++) {","            var leftCell = grid.get(x, 0);","            leftCell.distanceToObstacle = 0;","            var rightCell = grid.get(x, grid.dimY() - 1);","            rightCell.distanceToObstacle = 0;","        }","        for (var y = 1; y < grid.dimY() - 1; y++) {","            var topCell = grid.get(0, y);","            topCell.distanceToObstacle = 0;","            var bottomCell = grid.get(grid.dimX() - 1, y);","            bottomCell.distanceToObstacle = 0;","        }","        // The next two phases basically check the neighbors of a cell and","        // set the cell's distance field to be slightly greater than the","        // neighbor with the lowest border distance. Distance is increased","        // slightly more for diagonal-neighbors than for axis-neighbors.","        // 1st pass","        // During this pass, the following neighbors are checked:","        // (-1, 0) (-1, -1) (0, -1) (1, -1)","        for (var y = 1; y < grid.dimY() - 1; y++) {","            for (var x = 1; x < grid.dimX() - 1; x++) {","                var cell = grid.get(x, y);","                for (var _i = 0, _a = RegionGenerator.firstPassDeltas; _i < _a.length; _i++) {","                    var delta = _a[_i];","                    var distanceByNeighbor = grid.get(x + delta.x, y + delta.y).distanceToObstacle +","                        delta.distance;","                    if (cell.distanceToObstacle > distanceByNeighbor) {","                        cell.distanceToObstacle = distanceByNeighbor;","                    }","                }","            }","        }","        // 2nd pass","        // During this pass, the following neighbors are checked:","        //   (1, 0) (1, 1) (0, 1) (-1, 1)","        //","        // Besides checking different neighbors, this pass performs its","        // grid search in reverse order.","        for (var y = grid.dimY() - 2; y >= 1; y--) {","            for (var x = grid.dimX() - 2; x >= 1; x--) {","                var cell = grid.get(x, y);","                for (var _b = 0, _c = RegionGenerator.secondPassDeltas; _b < _c.length; _b++) {","                    var delta = _c[_b];","                    var distanceByNeighbor = grid.get(x + delta.x, y + delta.y).distanceToObstacle +","                        delta.distance;","                    if (cell.distanceToObstacle > distanceByNeighbor) {","                        cell.distanceToObstacle = distanceByNeighbor;","                    }","                }","            }","        }","    };","    RegionGenerator.firstPassDeltas = [","        { x: -1, y: 0, distance: 2 },","        { x: -1, y: -1, distance: 3 },","        { x: 0, y: -1, distance: 2 },","        { x: 1, y: -1, distance: 3 },","    ];","    RegionGenerator.secondPassDeltas = [","        { x: 1, y: 0, distance: 2 },","        { x: 1, y: 1, distance: 3 },","        { x: 0, y: 1, distance: 2 },","        { x: -1, y: 1, distance: 3 },","    ];","    return RegionGenerator;","}());","/**"," * Implements three algorithms that clean up issues that can"," * develop around obstacle region boarders."," *"," * - Detect and fix encompassed obstacle regions:"," *"," * If a obstacle region is found that is fully encompassed by a single"," * region, then the region will be split into two regions at the"," * obstacle region border."," *"," * - Detect and fix \"short wrapping\" of obstacle regions:"," *"," * Regions can sometimes wrap slightly around the corner of a obstacle region"," * in a manner that eventually results in the formation of self-intersecting"," * polygons."," *"," * Example: Before the algorithm is applied:"," * http://www.critterai.org/projects/nmgen_study/media/images/ohfg_08_cornerwrapbefore.jpg\""," *"," * Example: After the algorithm is applied:"," * http://www.critterai.org/projects/nmgen_study/media/images/ohfg_09_cornerwrapafter.jpg"," *"," * - Detect and fix incomplete obstacle region connections:"," *"," * If a region touches obstacle region only diagonally, then contour detection"," * algorithms may not properly detect the obstacle region connection. This can"," * adversely effect other algorithms in the pipeline."," *"," * Example: Before algorithm is applied:"," *"," *     b b a a a a"," *     b b a a a a"," *     a a x x x x"," *     a a x x x x"," *"," * Example: After algorithm is applied:"," *"," *     b b a a a a"," *     b b b a a a <-- Cell transferred to region B."," *     a a x x x x"," *     a a x x x x"," *"," *"," * Region Generation: http://www.critterai.org/projects/nmgen_study/regiongen.html"," */","var ObstacleRegionBordersCleaner = /** @class */ (function () {","    function ObstacleRegionBordersCleaner() {","        this.workingUpLeftOpenCells = new Array(512);","        this.workingDownRightOpenCells = new Array(512);","        this.workingOpenCells = new Array(512);","    }","    /**","     * This operation utilizes {@link RasterizationCell.contourFlags}. It","     * expects the value to be zero on entry, and re-zero's the value","     * on exit.","     *","     * @param grid a grid with fully built regions.","     */","    ObstacleRegionBordersCleaner.prototype.fixObstacleRegion = function (grid) {","        var workingUpLeftOpenCells = this.workingUpLeftOpenCells;","        workingUpLeftOpenCells.length = 0;","        var workingDownRightOpenCells = this.workingDownRightOpenCells;","        workingDownRightOpenCells.length = 0;","        var workingOpenCells = this.workingOpenCells;","        workingOpenCells.length = 0;","        var extremeCells = [","            null,","            null,","        ];","        var nextRegionID = grid.regionCount;","        // Iterate over the cells, trying to find obstacle region borders.","        for (var y = 1; y < grid.dimY() - 1; y++) {","            for (var x = 1; x < grid.dimX() - 1; x++) {","                var cell = grid.get(x, y);","                if (cell.contourFlags !== 0)","                    // Cell was processed in a previous iteration.","                    // Ignore it.","                    continue;","                cell.contourFlags = 1;","                var workingCell = null;","                var edgeDirection = -1;","                if (cell.regionID !== RasterizationCell.OBSTACLE_REGION_ID) {","                    // Not interested in this cell.","                    continue;","                }","                // This is a obstacle region cell. See if it","                // connects to a cell in a non-obstacle region.","                edgeDirection = this.getNonNullBorderDirection(grid, cell);","                if (edgeDirection === -1)","                    // This cell is not a border cell. Ignore it.","                    continue;","                // This is a border cell. Step into the non-null","                // region and swing the direction around 180 degrees.","                workingCell = grid.getNeighbor(cell, edgeDirection);","                edgeDirection = (edgeDirection + 2) & 0x3;","                // Process the obstacle region contour. Detect and fix","                // local issues. Determine if the region is","                // fully encompassed by a single non-obstacle region.","                var isEncompassedNullRegion = this.processNullRegion(grid, workingCell, edgeDirection, extremeCells);","                if (isEncompassedNullRegion) {","                    // This cell is part of a group of obstacle region cells","                    // that is encompassed within a single non-obstacle region.","                    // This is not permitted. Need to fix it.","                    this.partialFloodRegion(grid, extremeCells[0], extremeCells[1], nextRegionID);","                    nextRegionID++;","                }","            }","        }","        grid.regionCount = nextRegionID;","        // Clear all flags.","        for (var y = 1; y < grid.dimY() - 1; y++) {","            for (var x = 1; x < grid.dimX() - 1; x++) {","                var cell = grid.get(x, y);","                cell.contourFlags = 0;","            }","        }","    };","    /**","     * Partially flood a region away from the specified direction.","     *","     * {@link RasterizationCell.contourFlags}","     * is set to zero for all flooded cells.","     *","     * @param grid","     * @param startCell The cell to start the flood from.","     * @param borderDirection  The hard border for flooding. No","     * cells in this direction from the startCell will be flooded.","     * @param newRegionID The region id to assign the flooded","     * cells to.","     */","    ObstacleRegionBordersCleaner.prototype.partialFloodRegion = function (grid, upLeftCell, downRightCell, newRegionID) {","        var upLeftOpenCells = this.workingUpLeftOpenCells;","        var downRightOpenCells = this.workingDownRightOpenCells;","        var workingOpenCells = this.workingOpenCells;","        // The implementation differs from CritterAI to avoid non-contiguous","        // sections. Instead of brushing in one direction, it floods from","        // 2 extremities of the encompassed obstacle region.","        var regionID = upLeftCell.regionID;","        if (regionID === newRegionID) {","            // avoid infinity loop","            console.error(\"Can't create a new region with an ID that already exist.\");","            return;","        }","        // The 1st flooding set a new the regionID","        upLeftCell.regionID = newRegionID;","        upLeftCell.distanceToRegionCore = 0; // This information is lost.","        upLeftOpenCells.length = 0;","        upLeftOpenCells.push(upLeftCell);","        // The 2nd flooding keep the regionID and mark the cell as visited.","        downRightCell.contourFlags = 2;","        downRightCell.distanceToRegionCore = 0; // This information is lost.","        downRightOpenCells.length = 0;","        downRightOpenCells.push(downRightCell);","        var swap;","        workingOpenCells.length = 0;","        while (upLeftOpenCells.length !== 0 || downRightOpenCells.length !== 0) {","            for (var _i = 0, upLeftOpenCells_1 = upLeftOpenCells; _i < upLeftOpenCells_1.length; _i++) {","                var cell = upLeftOpenCells_1[_i];","                for (var direction = 0; direction < 4; direction++) {","                    var neighbor = grid.getNeighbor(cell, direction);","                    if (neighbor.regionID !== regionID || neighbor.contourFlags === 2) {","                        continue;","                    }","                    // Transfer the neighbor to the new region.","                    neighbor.regionID = newRegionID;","                    neighbor.distanceToRegionCore = 0; // This information is lost.","                    workingOpenCells.push(neighbor);","                }","            }","            // This allows to flood the nearest cells first without needing lifo queue.","            // But a queue would take less memory.","            swap = upLeftOpenCells;","            upLeftOpenCells = workingOpenCells;","            workingOpenCells = swap;","            workingOpenCells.length = 0;","            for (var _a = 0, downRightOpenCells_1 = downRightOpenCells; _a < downRightOpenCells_1.length; _a++) {","                var cell = downRightOpenCells_1[_a];","                for (var direction = 0; direction < 4; direction++) {","                    var neighbor = grid.getNeighbor(cell, direction);","                    if (neighbor.regionID !== regionID || neighbor.contourFlags === 2) {","                        continue;","                    }","                    // Keep the neighbor to the current region.","                    neighbor.contourFlags = 2;","                    neighbor.distanceToRegionCore = 0; // This information is lost.","                    workingOpenCells.push(neighbor);","                }","            }","            swap = downRightOpenCells;","            downRightOpenCells = workingOpenCells;","            workingOpenCells = swap;","            workingOpenCells.length = 0;","        }","    };","    /**","     * Detects and fixes bad cell configurations in the vicinity of a","     * obstacle region contour (See class description for details).","     * @param grid","     * @param startCell A cell in a non-obstacle region that borders a null","     * region.","     * @param startDirection The direction of the obstacle region border.","     * @return TRUE if the start cell's region completely encompasses","     * the obstacle region.","     */","    ObstacleRegionBordersCleaner.prototype.processNullRegion = function (grid, startCell, startDirection, extremeCells) {","        // This algorithm traverses the contour. As it does so, it detects","        // and fixes various known dangerous cell configurations.","        //","        // Traversing the contour:  A good way to  visualize it is to think","        // of a robot sitting on the floor facing  a known wall. It then","        // does the following to skirt the wall:","        // 1. If there is a wall in front of it, turn clockwise in 90 degrees","        //    increments until it finds the wall is gone.","        // 2. Move forward one step.","        // 3. Turn counter-clockwise by 90 degrees.","        // 4. Repeat from step 1 until it finds itself at its original","        //    location facing its original direction.","        //","        // See also: http://www.critterai.org/projects/nmgen_study/regiongen.html#robotwalk","        //","        // As the traversal occurs, the number of acute (90 degree) and","        // obtuse (270 degree) corners are monitored. If a complete contour is","        // detected and (obtuse corners > acute corners), then the null","        // region is inside the contour. Otherwise the obstacle region is","        // outside the contour, which we don't care about.","        var borderRegionID = startCell.regionID;","        // Prepare for loop.","        var cell = startCell;","        var neighbor = null;","        var direction = startDirection;","        var upLeftCell = cell;","        var downRightCell = cell;","        // Initialize monitoring variables.","        var loopCount = 0;","        var acuteCornerCount = 0;","        var obtuseCornerCount = 0;","        var stepsWithoutBorder = 0;","        var borderSeenLastLoop = false;","        var isBorder = true; // Initial value doesn't matter.","        // Assume a single region is connected to the obstacle region","        // until proven otherwise.","        var hasSingleConnection = true;","        // The loop limit exists for the sole reason of preventing","        // an infinite loop in case of bad input data.","        // It is set to a very high value because there is no way of","        // definitively determining a safe smaller value. Setting","        // the value too low can result in rescanning a contour","        // multiple times, killing performance.","        while (++loopCount < 1 << 30) {","            // Get the cell across the border.","            neighbor = grid.getNeighbor(cell, direction);","            // Detect which type of edge this direction points across.","            if (neighbor === null) {","                // It points across a obstacle region border edge.","                isBorder = true;","            }","            else {","                // We never need to perform contour detection","                // on this cell again. So mark it as processed.","                neighbor.contourFlags = 1;","                if (neighbor.regionID === RasterizationCell.OBSTACLE_REGION_ID) {","                    // It points across a obstacle region border edge.","                    isBorder = true;","                }","                else {","                    // This isn't a obstacle region border.","                    isBorder = false;","                    if (neighbor.regionID !== borderRegionID)","                        // It points across a border to a non-obstacle region.","                        // This means the current contour can't","                        // represent a fully encompassed obstacle region.","                        hasSingleConnection = false;","                }","            }","            // Process the border.","            if (isBorder) {","                // It is a border edge.","                if (borderSeenLastLoop) {","                    // A border was detected during the last loop as well.","                    // Two detections in a row indicates we passed an acute","                    // (inner) corner.","                    //","                    //     a x","                    //     x x","                    acuteCornerCount++;","                }","                else if (stepsWithoutBorder > 1) {","                    // We have moved at least two cells before detecting","                    // a border. This indicates we passed an obtuse","                    // (outer) corner.","                    //","                    //     a a","                    //     a x","                    obtuseCornerCount++;","                    stepsWithoutBorder = 0;","                    // Detect and fix cell configuration issue around this","                    // corner.","                    if (this.processOuterCorner(grid, cell, direction))","                        // A change was made and it resulted in the","                        // corner area having multiple region connections.","                        hasSingleConnection = false;","                }","                direction = (direction + 1) & 0x3; // Rotate in clockwise direction.","                borderSeenLastLoop = true;","                stepsWithoutBorder = 0;","            }","            else {","                // Not a obstacle region border.","                // Move to the neighbor and swing the search direction back","                // one increment (counterclockwise). By moving the direction","                // back one increment we guarantee we don't miss any edges.","                cell = neighbor;","                direction = (direction + 3) & 0x3; // Rotate counterclockwise direction.","                borderSeenLastLoop = false;","                stepsWithoutBorder++;","                if (cell.x < upLeftCell.x ||","                    (cell.x === upLeftCell.x && cell.y < upLeftCell.y)) {","                    upLeftCell = cell;","                }","                if (cell.x > downRightCell.x ||","                    (cell.x === downRightCell.x && cell.y > downRightCell.y)) {","                    downRightCell = cell;","                }","            }","            if (startCell === cell && startDirection === direction) {","                extremeCells[0] = upLeftCell;","                extremeCells[1] = downRightCell;","                // Have returned to the original cell and direction.","                // The search is complete.","                // Is the obstacle region inside the contour?","                return hasSingleConnection && obtuseCornerCount > acuteCornerCount;","            }","        }","        // If got here then the obstacle region boarder is too large to be fully","        // explored. So it can't be encompassed.","        return false;","    };","    /**","     * Detects and fixes cell configuration issues in the vicinity","     * of obtuse (outer) obstacle region corners.","     * @param grid","     * @param referenceCell The cell in a non-obstacle region that is","     * just past the outer corner.","     * @param borderDirection The direction of the obstacle region border.","     * @return TRUE if more than one region connects to the obstacle region","     * in the vicinity of the corner (this may or may not be due to","     * a change made by this operation).","     */","    ObstacleRegionBordersCleaner.prototype.processOuterCorner = function (grid, referenceCell, borderDirection) {","        var hasMultiRegions = false;","        // Get the previous two cells along the border.","        var backOne = grid.getNeighbor(referenceCell, (borderDirection + 3) & 0x3);","        var backTwo = grid.getNeighbor(backOne, borderDirection);","        var testCell;","        if (backOne.regionID !== referenceCell.regionID &&","            // This differ from the CritterAI implementation.","            // To filter vertices in the middle, this must be avoided too:","            //     a x","            //     b c","            backTwo.regionID !== backOne.regionID) {","            // Dangerous corner configuration.","            //","            //     a x","            //     b a","            //","            // Need to change to one of the following configurations:","            //","            //     b x        a x","            //     b a        b b","            //","            // Reason: During contour detection this type of configuration can","            // result in the region connection being detected as a","            // region-region portal, when it is not. The region connection","            // is actually interrupted by the obstacle region.","            //","            // This configuration has been demonstrated to result in","            // two regions being improperly merged to encompass an","            // internal obstacle region.","            //","            // Example:","            //","            //     a a x x x a","            //     a a x x a a","            //     b b a a a a","            //     b b a a a a","            //","            // During contour and connection detection for region b, at no","            // point will the obstacle region be detected. It will appear","            // as if a clean a-b portal exists.","            //","            // An investigation into fixing this issue via updates to the","            // watershed or contour detection algorithms did not turn","            // up a better way of resolving this issue.","            hasMultiRegions = true;","            // Determine how many connections backTwo has to backOne's region.","            testCell = grid.getNeighbor(backOne, (borderDirection + 3) & 0x3);","            var backTwoConnections = 0;","            if (testCell.regionID === backOne.regionID) {","                backTwoConnections++;","                testCell = grid.getNeighbor(testCell, borderDirection);","                if (testCell.regionID === backOne.regionID)","                    backTwoConnections++;","            }","            // Determine how many connections the reference cell has","            // to backOne's region.","            var referenceConnections = 0;","            testCell = grid.getNeighbor(backOne, (borderDirection + 2) & 0x3);","            if (testCell.regionID === backOne.regionID) {","                referenceConnections++;","                testCell = grid.getNeighbor(testCell, (borderDirection + 2) & 0x3);","                if (testCell.regionID === backOne.regionID)","                    backTwoConnections++;","            }","            // Change the region of the cell that has the most connections","            // to the target region.","            if (referenceConnections > backTwoConnections)","                referenceCell.regionID = backOne.regionID;","            else","                backTwo.regionID = backOne.regionID;","        }","        else if (backOne.regionID === referenceCell.regionID &&","            backTwo.regionID === referenceCell.regionID) {","            // Potential dangerous short wrap.","            //","            //  a x","            //  a a","            //","            //  Example of actual problem configuration:","            //","            //  b b x x","            //  b a x x <- Short wrap.","            //  b a a a","            //","            //  In the above case, the short wrap around the corner of the","            //  obstacle region has been demonstrated to cause self-intersecting","            //  polygons during polygon formation.","            //","            //  This algorithm detects whether or not one (and only one)","            //  of the axis neighbors of the corner should be re-assigned to","            //  a more appropriate region.","            //","            //  In the above example, the following configuration is more","            //  appropriate:","            //","            //  b b x x","            //  b b x x <- Change to this row.","            //  b a a a","            // Check to see if backTwo should be in a different region.","            var selectedRegion = this.selectedRegionID(grid, backTwo, (borderDirection + 1) & 0x3, (borderDirection + 2) & 0x3);","            if (selectedRegion === backTwo.regionID) {","                // backTwo should not be re-assigned. How about","                // the reference cell?","                selectedRegion = this.selectedRegionID(grid, referenceCell, borderDirection, (borderDirection + 3) & 0x3);","                if (selectedRegion !== referenceCell.regionID) {","                    // The reference cell should be reassigned","                    // to a new region.","                    referenceCell.regionID = selectedRegion;","                    hasMultiRegions = true;","                }","            }","            else {","                // backTwo should be re-assigned to a new region.","                backTwo.regionID = selectedRegion;","                hasMultiRegions = true;","            }","        }","        else","            hasMultiRegions = true;","        // No dangerous configurations detected. But definitely","        // has a change in regions at the corner. We know this","        // because one of the previous checks looked for a single","        // region for all wrap cells.","        return hasMultiRegions;","    };","    /**","     * Checks the cell to see if it should be reassigned to a new region.","     *","     * @param grid","     * @param referenceCell A cell on one side of an obstacle region contour's","     * outer corner. It is expected that the all cells that wrap the","     * corner are in the same region.","     * @param borderDirection  The direction of the obstacle region border.","     * @param cornerDirection The direction of the outer corner from the","     * reference cell.","     * @return The region the cell should be a member of. May be the","     * region the cell is currently a member of.","     */","    ObstacleRegionBordersCleaner.prototype.selectedRegionID = function (grid, referenceCell, borderDirection, cornerDirection) {","        // Initial example state:","        //","        // a - Known region.","        // x - Null region.","        // u - Unknown, not checked yet.","        //","        //     u u u","        //     u a x","        //     u a a","        // The only possible alternate region id is from","        // the cell that is opposite the border. So check it first.","        var regionID = grid.getNeighbor(referenceCell, (borderDirection + 2) & 0x3)","            .regionID;","        if (regionID === referenceCell.regionID ||","            regionID === RasterizationCell.OBSTACLE_REGION_ID)","            // The region away from the border is either a obstacle region","            // or the same region. So we keep the current region.","            //","            //     u u u      u u u","            //     a a x  or  x a x  <-- Potentially bad, but stuck with it.","            //     u a a      u a a","            return referenceCell.regionID;","        // Candidate region for re-assignment.","        var potentialRegion = regionID;","        // Next we check the region opposite from the corner direction.","        // If it is the current region, then we definitely can't","        // change the region id without risk of splitting the region.","        regionID = grid.getNeighbor(referenceCell, (cornerDirection + 2) & 0x3)","            .regionID;","        if (regionID === referenceCell.regionID ||","            regionID === RasterizationCell.OBSTACLE_REGION_ID)","            // The region opposite from the corner direction is","            // either a obstacle region or the same region. So we","            // keep the current region.","            //","            //     u a u      u x u","            //     b a x  or  b a x","            //     u a a      u a a","            return referenceCell.regionID;","        // We have checked the early exit special cases. Now a generalized","        // brute count is performed.","        //","        // Priority is given to the potential region. Here is why:","        // (Highly unlikely worst case scenario)","        //","        //     c c c    c c c","        //     b a x -> b b x  Select b even though b count == a count.","        //     b a a    b a a","        // Neighbors in potential region.","        // We know this will have a minimum value of 1.","        var potentialCount = 0;","        // Neighbors in the cell's current region.","        // We know this will have a minimum value of 2.","        var currentCount = 0;","        // Maximum edge case:","        //","        //     b b b","        //     b a x","        //     b a a","        //","        // The maximum edge case for region A can't exist. It","        // is filtered out during one of the earlier special cases","        // handlers.","        //","        // Other cases may exist if more regions are involved.","        // Such cases will tend to favor the current region.","        for (var direction = 0; direction < 8; direction++) {","            var regionID_1 = grid.getNeighbor(referenceCell, direction).regionID;","            if (regionID_1 === referenceCell.regionID)","                currentCount++;","            else if (regionID_1 === potentialRegion)","                potentialCount++;","        }","        return potentialCount < currentCount","            ? referenceCell.regionID","            : potentialRegion;","    };","    /**","     * Returns the direction of the first neighbor in a non-obstacle region.","     * @param grid","     * @param cell The cell to check.","     * @return The direction of the first neighbor in a non-obstacle region, or","     * -1 if all neighbors are in the obstacle region.","     */","    ObstacleRegionBordersCleaner.prototype.getNonNullBorderDirection = function (grid, cell) {","        // Search axis-neighbors.","        for (var direction = 0; direction < RasterizationGrid.neighbor4Deltas.length; direction++) {","            var delta = RasterizationGrid.neighbor4Deltas[direction];","            var neighbor = grid.get(cell.x + delta.x, cell.y + delta.y);","            if (neighbor.regionID !== RasterizationCell.OBSTACLE_REGION_ID)","                // The neighbor is a obstacle region.","                return direction;","        }","        // All neighbors are in a non-obstacle region.","        return -1;","    };","    return ObstacleRegionBordersCleaner;","}());","","// This implementation is strongly inspired from a Java one","// by Stephen A. Pratt:","// http://www.critterai.org/projects/nmgen_study/","//","// Most of the comments were written by him and were adapted to fit this implementation.","// This implementation differs a bit from the original:","// - it's only 2D instead of 3D","// - it has less features (see TODO) and might have lesser performance","// - it uses objects for points instead of pointer-like in arrays of numbers","// - the rasterization comes from other sources because of the 2d focus","// - partialFloodRegion was rewritten to fix an issue","// - filterNonObstacleVertices was added","//","// The Java implementation was also inspired from Recast that can be found here:","// https://github.com/recastnavigation/recastnavigation","var NavMeshGenerator = /** @class */ (function () {","    function NavMeshGenerator(areaLeftBound, areaTopBound, areaRightBound, areaBottomBound, rasterizationCellSize, isometricRatio) {","        if (isometricRatio === void 0) { isometricRatio = 1; }","        this.grid = new RasterizationGrid(areaLeftBound, areaTopBound, areaRightBound, areaBottomBound, rasterizationCellSize, ","        // make cells square in the world","        rasterizationCellSize / isometricRatio);","        this.isometricRatio = isometricRatio;","        this.obstacleRasterizer = new ObstacleRasterizer();","        this.regionGenerator = new RegionGenerator();","        this.contourBuilder = new ContourBuilder();","        this.convexPolygonGenerator = new ConvexPolygonGenerator();","        this.gridCoordinateConverter = new GridCoordinateConverter();","    }","    NavMeshGenerator.prototype.buildNavMesh = function (obstacles, obstacleCellPadding) {","        var _this = this;","        this.grid.clear();","        this.obstacleRasterizer.rasterizeObstacles(this.grid, obstacles);","        this.regionGenerator.generateDistanceField(this.grid);","        this.regionGenerator.generateRegions(this.grid, obstacleCellPadding);","        // It's probably not a good idea to expose the vectorization threshold.","        // As stated in the parameter documentation, the value 1 gives good","        // results in any situations.","        var threshold = 1;","        var contours = this.contourBuilder.buildContours(this.grid, threshold);","        var meshField = this.convexPolygonGenerator.splitToConvexPolygons(contours, 16);","        var scaledMeshField = this.gridCoordinateConverter.convertFromGridBasis(this.grid, meshField);","        if (this.isometricRatio != 1) {","            // Rescale the mesh to have the same unit length on the 2 axis for the pathfinding.","            scaledMeshField.forEach(function (polygon) {","                return polygon.forEach(function (point) {","                    point.y *= _this.isometricRatio;","                });","            });","        }","        return scaledMeshField;","    };","    return NavMeshGenerator;","}());","","/*","GDevelop - NavMesh Pathfinding Behavior Extension","    */","/**"," * PathfindingObstaclesManager manages the common objects shared by objects having a"," * pathfinding behavior: In particular, the obstacles behaviors are required to declare"," * themselves (see `PathfindingObstaclesManager.addObstacle`) to the manager of their associated scene"," * (see `NavMeshPathfindingRuntimeBehavior.obstaclesManagers`)."," */","var NavMeshPathfindingObstaclesManager = /** @class */ (function () {","    function NavMeshPathfindingObstaclesManager(instanceContainer, configuration) {","        /**","         * The navigation meshes by moving object size","         * (rounded on _cellSize)","         */","        this._navMeshes = new Map();","        /**","         * Used while NavMeshes update is disabled to remember to do the update","         * when it's enable back.","         */","        this._navMeshesAreUpToDate = true;","        /**","         * This allows to continue finding paths with the old NavMeshes while","         * moving obstacles.","         */","        this._navMeshesUpdateIsEnabled = true;","        var viewpoint = configuration._getViewpoint();","        if (viewpoint === 'Isometry 2:1 (26.565°)') {","            configuration._setIsometricRatio(2);","        }","        else if (viewpoint === 'True Isometry (30°)') {","            configuration._setIsometricRatio(Math.sqrt(3));","        }","        else {","            configuration._setIsometricRatio(1);","        }","        if (configuration._getCellSize() <= 0) {","            configuration._setCellSize(10);","        }","        if (configuration._getAreaLeftBound() === 0 &&","            configuration._getAreaTopBound() === 0 &&","            configuration._getAreaRightBound() === 0 &&","            configuration._getAreaBottomBound() === 0) {","            var game = instanceContainer.getGame();","            configuration._setAreaLeftBound(0);","            configuration._setAreaTopBound(0);","            configuration._setAreaRightBound(game.getGameResolutionWidth());","            configuration._setAreaBottomBound(game.getGameResolutionHeight());","        }","        this.configuration = configuration;","        this._obstacles = new Set();","        this._polygonIterableAdapter = new PolygonIterableAdapter();","        this._navMeshGenerator = new NavMeshGenerator(configuration._getAreaLeftBound(), configuration._getAreaTopBound(), configuration._getAreaRightBound(), configuration._getAreaBottomBound(), configuration._getCellSize(), ","        // make cells square in the world","        configuration._getIsometricRatio());","    }","    /**","     * Get the obstacles manager of a scene.","     */","    NavMeshPathfindingObstaclesManager.getManager = function (instanceContainer) {","        // @ts-ignore","        return instanceContainer.navMeshPathfindingObstaclesManager;","    };","    NavMeshPathfindingObstaclesManager.getManagerOrCreate = function (instanceContainer, configuration) {","        // @ts-ignore","        if (!instanceContainer.navMeshPathfindingObstaclesManager) {","            // Create the shared manager if necessary.","            // @ts-ignore","            instanceContainer.navMeshPathfindingObstaclesManager = new NavMeshPathfindingObstaclesManager(instanceContainer, configuration);","        }","        // @ts-ignore","        return instanceContainer.navMeshPathfindingObstaclesManager;","    };","    NavMeshPathfindingObstaclesManager.prototype.setNavMeshesUpdateEnabled = function (navMeshesUpdateIsEnabled) {","        this._navMeshesUpdateIsEnabled = navMeshesUpdateIsEnabled;","        if (navMeshesUpdateIsEnabled && !this._navMeshesAreUpToDate) {","            this._navMeshes.clear();","            this._navMeshesAreUpToDate = true;","        }","    };","    /**","     * Add a obstacle to the list of existing obstacles.","     */","    NavMeshPathfindingObstaclesManager.prototype.addObstacle = function (pathfindingObstacleBehavior) {","        this._obstacles.add(pathfindingObstacleBehavior.behavior.owner);","        this.invalidateNavMesh();","    };","    /**","     * Remove a obstacle from the list of existing obstacles. Be sure that the obstacle was","     * added before.","     */","    NavMeshPathfindingObstaclesManager.prototype.removeObstacle = function (pathfindingObstacleBehavior) {","        this._obstacles.delete(pathfindingObstacleBehavior.behavior.owner);","        this.invalidateNavMesh();","    };","    NavMeshPathfindingObstaclesManager.prototype.invalidateNavMesh = function () {","        if (this._navMeshesUpdateIsEnabled) {","            this._navMeshes.clear();","            this._navMeshesAreUpToDate = true;","        }","        else {","            this._navMeshesAreUpToDate = false;","        }","    };","    NavMeshPathfindingObstaclesManager.prototype.getNavMesh = function (obstacleCellPadding) {","        var navMesh = this._navMeshes.get(obstacleCellPadding);","        if (!navMesh) {","            var navMeshPolygons = this._navMeshGenerator.buildNavMesh(this._getVerticesIterable(this._obstacles), obstacleCellPadding);","            navMesh = new NavMesh(navMeshPolygons);","            this._navMeshes.set(obstacleCellPadding, navMesh);","        }","        return navMesh;","    };","    NavMeshPathfindingObstaclesManager.prototype._getVerticesIterable = function (objects) {","        this._polygonIterableAdapter.set(objects);","        return this._polygonIterableAdapter;","    };","    return NavMeshPathfindingObstaclesManager;","}());","/**"," * Iterable that adapts `RuntimeObject` to `Iterable<{x: float y: float}>`."," *"," * This is an allocation free iterable"," * that can only do one iteration at a time."," */","var PolygonIterableAdapter = /** @class */ (function () {","    function PolygonIterableAdapter() {","        this.objects = [];","        this.objectsItr = this.objects[Symbol.iterator]();","        this.polygonsItr = [][Symbol.iterator]();","        this.pointIterableAdapter = new PointIterableAdapter();","        this.result = {","            value: this.pointIterableAdapter,","            done: false,","        };","    }","    PolygonIterableAdapter.prototype.set = function (objects) {","        this.objects = objects;","    };","    PolygonIterableAdapter.prototype[Symbol.iterator] = function () {","        this.objectsItr = this.objects[Symbol.iterator]();","        this.polygonsItr = [][Symbol.iterator]();","        return this;","    };","    PolygonIterableAdapter.prototype.next = function () {","        var polygonNext = this.polygonsItr.next();","        while (polygonNext.done) {","            var objectNext = this.objectsItr.next();","            if (objectNext.done) {","                // IteratorReturnResult<gdjs.RuntimeObject> require a defined value","                // even though the spec state otherwise.","                // So, this class can't be typed as an iterable.","                this.result.value = undefined;","                this.result.done = true;","                return this.result;","            }","            this.polygonsItr = objectNext.value.getHitBoxes().values();","            polygonNext = this.polygonsItr.next();","        }","        this.pointIterableAdapter.set(polygonNext.value.vertices);","        this.result.value = this.pointIterableAdapter;","        this.result.done = false;","        return this.result;","    };","    return PolygonIterableAdapter;","}());","/**"," * Iterable that adapts coordinates from `[int, int]` to `{x: int, y: int}`."," *"," * This is an allocation free iterable"," * that can only do one iteration at a time."," */","var PointIterableAdapter = /** @class */ (function () {","    function PointIterableAdapter() {","        this.vertices = [];","        this.verticesItr = this.vertices[Symbol.iterator]();","        this.result = {","            value: { x: 0, y: 0 },","            done: false,","        };","    }","    PointIterableAdapter.prototype.set = function (vertices) {","        this.vertices = vertices;","    };","    PointIterableAdapter.prototype[Symbol.iterator] = function () {","        this.verticesItr = this.vertices[Symbol.iterator]();","        return this;","    };","    PointIterableAdapter.prototype.next = function () {","        var next = this.verticesItr.next();","        if (next.done) {","            return next;","        }","        this.result.value.x = next.value[0];","        this.result.value.y = next.value[1];","        return this.result;","    };","    return PointIterableAdapter;","}());","","/*","GDevelop - NavMesh Pathfinding Behavior Extension","    */","/**"," * NavMeshPathfindingRuntimeBehavior represents a behavior allowing objects to"," * follow a path computed to avoid obstacles."," */","var NavMeshRenderer = /** @class */ (function () {","    function NavMeshRenderer() {","        /** Used to draw traces for debugging */","        this._lastUsedObstacleCellPadding = null;","    }","    NavMeshRenderer.prototype.setLastUsedObstacleCellPadding = function (lastUsedObstacleCellPadding) {","        this._lastUsedObstacleCellPadding = lastUsedObstacleCellPadding;","    };","    NavMeshRenderer.prototype.render = function (instanceContainer, shapePainter) {","        if (this._lastUsedObstacleCellPadding === null) {","            return;","        }","        var manager = NavMeshPathfindingObstaclesManager.getManager(instanceContainer);","        if (!manager) {","            return;","        }","        var isometricRatio = manager.configuration._getIsometricRatio();","        // TODO find a way to rebuild drawing only when necessary.","        // Draw the navigation mesh on a shape painter object for debugging purpose","        var navMesh = manager.getNavMesh(this._lastUsedObstacleCellPadding);","        for (var _i = 0, _a = navMesh.getPolygons(); _i < _a.length; _i++) {","            var navPoly = _a[_i];","            var polygon = navPoly.getPoints();","            if (polygon.length === 0)","                continue;","            for (var index = 1; index < polygon.length; index++) {","                // It helps to spot vertices with 180° between edges.","                shapePainter.drawCircle(polygon[index].x, polygon[index].y / isometricRatio, 3);","            }","        }","        for (var _b = 0, _c = navMesh.getPolygons(); _b < _c.length; _b++) {","            var navPoly = _c[_b];","            var polygon = navPoly.getPoints();","            if (polygon.length === 0)","                continue;","            shapePainter.beginFillPath(polygon[0].x, polygon[0].y / isometricRatio);","            for (var index = 1; index < polygon.length; index++) {","                shapePainter.drawPathLineTo(polygon[index].x, polygon[index].y / isometricRatio);","            }","            shapePainter.closePath();","            shapePainter.endFillPath();","        }","    };","    return NavMeshRenderer;","}());","","/**"," * NavMeshPathfindingRuntimeBehavior represents a behavior allowing objects to"," * follow a path computed to avoid obstacles."," */","var PathFollower = /** @class */ (function () {","    function PathFollower(configuration) {","        // Attributes used for traveling on the path:","        this._path = [];","        this._speed = 0;","        this._distanceOnSegment = 0;","        this._totalSegmentDistance = 0;","        this._currentSegment = 0;","        this._movementAngle = 0;","        this.configuration = configuration;","    }","    PathFollower.prototype.setSpeed = function (speed) {","        this._speed = speed;","    };","    PathFollower.prototype.getSpeed = function () {","        return this._speed;","    };","    PathFollower.prototype.getMovementAngle = function () {","        return this._movementAngle;","    };","    PathFollower.prototype.movementAngleIsAround = function (degreeAngle, tolerance) {","        return (Math.abs(gdjs.evtTools.common.angleDifference(this._movementAngle, degreeAngle)) <= tolerance);","    };","    PathFollower.prototype.getNodeX = function (index) {","        if (index < this._path.length) {","            return this._path[index][0];","        }","        return 0;","    };","    PathFollower.prototype.getNodeY = function (index) {","        if (index < this._path.length) {","            return this._path[index][1];","        }","        return 0;","    };","    PathFollower.prototype.getNextNodeIndex = function () {","        return Math.min(this._currentSegment + 1, this._path.length - 1);","    };","    PathFollower.prototype.getNodeCount = function () {","        return this._path.length;","    };","    PathFollower.prototype.getNextNodeX = function () {","        if (this._path.length === 0) {","            return 0;","        }","        var nextIndex = Math.min(this._currentSegment + 1, this._path.length - 1);","        return this._path[nextIndex][0];","    };","    PathFollower.prototype.getNextNodeY = function () {","        if (this._path.length === 0) {","            return 0;","        }","        var nextIndex = Math.min(this._currentSegment + 1, this._path.length - 1);","        return this._path[nextIndex][1];","    };","    PathFollower.prototype.getPreviousNodeX = function () {","        if (this._path.length === 0) {","            return 0;","        }","        var previousIndex = Math.min(this._currentSegment, this._path.length - 1);","        return this._path[previousIndex][0];","    };","    PathFollower.prototype.getPreviousNodeY = function () {","        if (this._path.length === 0) {","            return 0;","        }","        var previousIndex = Math.min(this._currentSegment, this._path.length - 1);","        return this._path[previousIndex][1];","    };","    PathFollower.prototype.getDestinationX = function () {","        if (this._path.length === 0) {","            return 0;","        }","        return this._path[this._path.length - 1][0];","    };","    PathFollower.prototype.getDestinationY = function () {","        if (this._path.length === 0) {","            return 0;","        }","        return (this._path[this._path.length - 1][1]);","    };","    /**","     * Return true if the object reached its destination.","     */","    PathFollower.prototype.destinationReached = function () {","        return this._currentSegment >= this._path.length - 1;","    };","    /**","     * Compute and move on the path to the specified destination.","     */","    PathFollower.prototype.setPath = function (path) {","        this._path = path;","        this._enterSegment(0);","    };","    PathFollower.prototype._enterSegment = function (segmentNumber) {","        if (this._path.length === 0) {","            return;","        }","        this._currentSegment = segmentNumber;","        if (this._currentSegment < this._path.length - 1) {","            var pathX = this._path[this._currentSegment + 1][0] -","                this._path[this._currentSegment][0];","            var pathY = this._path[this._currentSegment + 1][1] -","                this._path[this._currentSegment][1];","            this._totalSegmentDistance = Math.sqrt(pathX * pathX + pathY * pathY);","            this._distanceOnSegment = 0;","            this._movementAngle =","                (gdjs.toDegrees(Math.atan2(pathY, pathX)) + 360) % 360;","        }","        else {","            this._speed = 0;","        }","    };","    PathFollower.prototype.isMoving = function () {","        return !(this._path.length === 0 || this.destinationReached());","    };","    PathFollower.prototype.step = function (timeDelta) {","        if (this._path.length === 0 || this.destinationReached()) {","            return;","        }","        // Update the speed of the object","        var previousSpeed = this._speed;","        var maxSpeed = this.configuration._getMaxSpeed();","        if (this._speed !== maxSpeed) {","            this._speed += this.configuration._getAcceleration() * timeDelta;","            if (this._speed > maxSpeed) {","                this._speed = maxSpeed;","            }","        }","        // Update the time on the segment and change segment if needed","        // Use a Verlet integration to be frame rate independent.","        this._distanceOnSegment +=","            ((this._speed + previousSpeed) / 2) * timeDelta;","        var remainingDistanceOnSegment = this._totalSegmentDistance - this._distanceOnSegment;","        if (remainingDistanceOnSegment <= 0 &&","            this._currentSegment < this._path.length) {","            this._enterSegment(this._currentSegment + 1);","            this._distanceOnSegment = -remainingDistanceOnSegment;","        }","    };","    PathFollower.prototype.getX = function () {","        return this._currentSegment < this._path.length - 1 ? gdjs.evtTools.common.lerp(this._path[this._currentSegment][0], this._path[this._currentSegment + 1][0], this._distanceOnSegment / this._totalSegmentDistance) : this._path[this._path.length - 1][0];","    };","    PathFollower.prototype.getY = function () {","        return this._currentSegment < this._path.length - 1 ? gdjs.evtTools.common.lerp(this._path[this._currentSegment][1], this._path[this._currentSegment + 1][1], this._distanceOnSegment / this._totalSegmentDistance) : this._path[this._path.length - 1][1];","    };","    return PathFollower;","}());","","/**"," * NavMeshPathfindingRuntimeBehavior represents a behavior allowing objects to"," * follow a path computed to avoid obstacles."," */","var NavMeshPathfindingBehavior = /** @class */ (function () {","    function NavMeshPathfindingBehavior(behavior) {","        // Attributes used for traveling on the path:","        this._pathFound = false;","        this.behavior = behavior;","        this.pathFollower = new PathFollower(behavior);","        this.navMeshRenderer = new NavMeshRenderer();","    }","    /**","     * Return true if the latest call to moveTo succeeded.","     */","    NavMeshPathfindingBehavior.prototype.pathFound = function () {","        return this._pathFound;","    };","    /**","     * Compute and move on the path to the specified destination.","     */","    NavMeshPathfindingBehavior.prototype.moveTo = function (instanceContainer, x, y) {","        var owner = this.behavior.owner;","        var manager = NavMeshPathfindingObstaclesManager.getManager(instanceContainer);","        if (!manager) {","            this._pathFound = true;","            this.pathFollower.setPath([[owner.getX(), owner.getY()], [x, y]]);","            return;","        }","        var isometricRatio = manager.configuration._getIsometricRatio();","        var cellSize = manager.configuration._getCellSize();","        var collisionShape = this.behavior._getCollisionShape();","        var extraBorder = this.behavior._getExtraBorder();","        var radiusSqMax = 0;","        if (collisionShape !== 'Dot at center') {","            var centerX = owner.getCenterXInScene();","            var centerY = owner.getCenterYInScene();","            for (var _i = 0, _a = owner.getHitBoxes(); _i < _a.length; _i++) {","                var hitBox = _a[_i];","                for (var _b = 0, _c = hitBox.vertices; _b < _c.length; _b++) {","                    var vertex = _c[_b];","                    var deltaX = vertex[0] - centerX;","                    // to have the same unit on x and y","                    var deltaY = (vertex[1] - centerY) * isometricRatio;","                    var radiusSq = deltaX * deltaX + deltaY * deltaY;","                    radiusSqMax = Math.max(radiusSq, radiusSqMax);","                }","            }","        }","        // Round to avoid to flicker between 2 NavMesh","        // because of trigonometry rounding errors.","        // Round the padding on cellSize to avoid almost identical NavMesh","        var obstacleCellPadding = Math.max(0, Math.round((Math.sqrt(radiusSqMax) + extraBorder) / cellSize));","        this.navMeshRenderer.setLastUsedObstacleCellPadding(obstacleCellPadding);","        var navMesh = manager.getNavMesh(obstacleCellPadding);","        // TODO avoid the path allocation","        var path = navMesh.findPath({","            x: owner.getX(),","            y: owner.getY() * isometricRatio,","        }, { x: x, y: y * isometricRatio }) || [];","        this._pathFound = path.length > 0;","        this.pathFollower.setPath(path.map(function (_a) {","            var x = _a.x, y = _a.y;","            return [x, y];","        }));","    };","    NavMeshPathfindingBehavior.prototype.doStepPreEvents = function (instanceContainer) {","        if (this.pathFollower.destinationReached()) {","            return;","        }","        var manager = NavMeshPathfindingObstaclesManager.getManager(instanceContainer);","        if (!manager) {","            return;","        }","        var isometricRatio = manager.configuration._getIsometricRatio();","        var owner = this.behavior.owner;","        var angleOffset = this.behavior._getAngleOffset();","        var angularMaxSpeed = this.behavior._getAngularMaxSpeed();","        var rotateObject = this.behavior._getRotateObject();","        var timeDelta = owner.getElapsedTime(instanceContainer) / 1000;","        this.pathFollower.step(timeDelta);","        // Position object on the segment and update its angle","        var movementAngle = this.pathFollower.getMovementAngle();","        if (rotateObject &&","            owner.getAngle() !== movementAngle + angleOffset) {","            owner.rotateTowardAngle(movementAngle + angleOffset, angularMaxSpeed, instanceContainer);","        }","        owner.setX(this.pathFollower.getX());","        // In case of isometry, convert coords back in screen.","        owner.setY(this.pathFollower.getY() / isometricRatio);","    };","    return NavMeshPathfindingBehavior;","}());","","/*","GDevelop - NavMesh Pathfinding Behavior Extension","    */","/**"," * NavMeshPathfindingObstacleRuntimeBehavior represents a behavior allowing objects to be"," * considered as a obstacle by objects having Pathfinding Behavior."," */","var NavMeshPathfindingObstacleBehavior = /** @class */ (function () {","    function NavMeshPathfindingObstacleBehavior(instanceContainer, behavior) {","        this._oldX = 0;","        this._oldY = 0;","        this._oldWidth = 0;","        this._oldHeight = 0;","        this._registeredInManager = false;","        this.behavior = behavior;","        this._manager = NavMeshPathfindingObstaclesManager.getManagerOrCreate(instanceContainer, ","        // @ts-ignore","        behavior._sharedData);","        //Note that we can't use getX(), getWidth()... of owner here:","        //The owner is not yet fully constructed.","    }","    NavMeshPathfindingObstacleBehavior.prototype.onDestroy = function () {","        if (this._manager && this._registeredInManager) {","            this._manager.removeObstacle(this);","        }","    };","    NavMeshPathfindingObstacleBehavior.prototype.doStepPreEvents = function (instanceContainer) {","        var owner = this.behavior.owner;","        //Make sure the obstacle is or is not in the obstacles manager.","        if (!this.behavior.activated() && this._registeredInManager) {","            this._manager.removeObstacle(this);","            this._registeredInManager = false;","        }","        else {","            if (this.behavior.activated() && !this._registeredInManager) {","                this._manager.addObstacle(this);","                this._registeredInManager = true;","            }","        }","        //Track changes in size or position","        if (this._oldX !== owner.getX() ||","            this._oldY !== owner.getY() ||","            this._oldWidth !== owner.getWidth() ||","            this._oldHeight !== owner.getHeight()) {","            if (this._registeredInManager) {","                this._manager.removeObstacle(this);","                this._manager.addObstacle(this);","            }","            this._oldX = owner.getX();","            this._oldY = owner.getY();","            this._oldWidth = owner.getWidth();","            this._oldHeight = owner.getHeight();","        }","    };","    NavMeshPathfindingObstacleBehavior.prototype.doStepPostEvents = function (instanceContainer) { };","    NavMeshPathfindingObstacleBehavior.prototype.onActivate = function () {","        if (this._registeredInManager) {","            return;","        }","        this._manager.addObstacle(this);","        this._registeredInManager = true;","    };","    NavMeshPathfindingObstacleBehavior.prototype.onDeActivate = function () {","        if (!this._registeredInManager) {","            return;","        }","        this._manager.removeObstacle(this);","        this._registeredInManager = false;","    };","    return NavMeshPathfindingObstacleBehavior;","}());","","gdjs.__NavMeshPathfinding = {","    NavMeshPathfindingBehavior,","    NavMeshPathfindingObstacleBehavior,","}",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[],"objectGroups":[]}],"eventsBasedBehaviors":[{"description":"Move objects to a target in straight lines while avoiding all objects that are flagged as obstacles.","fullName":"Navigation mesh pathfinding (experimental)","name":"NavMeshPathfindingBehavior","objectType":"","eventsFunctions":[{"fullName":"","functionType":"Action","name":"onCreated","sentence":"","events":[{"type":"BuiltinCommonInstructions::Comment","color":{"b":109,"g":230,"r":255,"textB":0,"textG":0,"textR":0},"comment":"Initiate and attach properties as objects variables"},{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"NavMeshPathfinding::DefineJavaScript"},"parameters":["",""]}]},{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["const object = objects[0];\r","const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");\r","const behavior = object.getBehavior(behaviorName);\r","behavior.__NavMeshPathfinding = behavior.__NavMeshPathfinding || {};\r","behavior.__NavMeshPathfinding.pathfinding = new gdjs.__NavMeshPathfinding.NavMeshPathfindingBehavior(behavior);\r",""],"parameterObjects":"Object","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingBehavior","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"Action","name":"doStepPreEvents","sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["const object = objects[0];\r","const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");\r","const behavior = object.getBehavior(behaviorName);\r","\r","behavior.__NavMeshPathfinding.pathfinding.doStepPreEvents(runtimeScene);\r",""],"parameterObjects":"Object","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingBehavior","type":"behavior"}],"objectGroups":[]},{"description":"Move the object to a position.","fullName":"Move to a position","functionType":"Action","group":"Movement on the path (navigation mesh)","name":"SetDestination","sentence":"Move _PARAM0_ to _PARAM2_;_PARAM3_","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["const object = objects[0];","const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");","const behavior = object.getBehavior(behaviorName);","","const destinationX = eventsFunctionContext.getArgument(\"DestinationX\");","const destinationY = eventsFunctionContext.getArgument(\"DestinationY\");","","behavior.__NavMeshPathfinding.pathfinding.moveTo(runtimeScene, destinationX, destinationY);",""],"parameterObjects":"Object","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingBehavior","type":"behavior"},{"description":"Destination X position","name":"DestinationX","type":"expression"},{"description":"Destination Y position","name":"DestinationY","type":"expression"}],"objectGroups":[]},{"description":"Check if the object is moving on a path.","fullName":"Is moving","functionType":"Condition","group":"Movement on the path (navigation mesh)","name":"IsMoving","sentence":"_PARAM0_ is moving on a path","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["const object = objects[0];","const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");","const behavior = object.getBehavior(behaviorName);","","eventsFunctionContext.returnValue = behavior.__NavMeshPathfinding.pathfinding.pathFollower.isMoving();",""],"parameterObjects":"Object","useStrict":true,"eventsSheetExpanded":false}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingBehavior","type":"behavior"}],"objectGroups":[]},{"description":"Check if a path has been found.","fullName":"Path found","functionType":"Condition","group":"Movement on the path (navigation mesh)","name":"PathFound","sentence":"A path has been found for _PARAM0_","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["const object = objects[0];","const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");","const behavior = object.getBehavior(behaviorName);","","eventsFunctionContext.returnValue = behavior.__NavMeshPathfinding.pathfinding.pathFound();",""],"parameterObjects":"Object","useStrict":true,"eventsSheetExpanded":false}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingBehavior","type":"behavior"}],"objectGroups":[]},{"description":"Check if the destination was reached.","fullName":"Destination reached","functionType":"Condition","group":"Movement on the path (navigation mesh)","name":"DestinationReached","sentence":"_PARAM0_ reached its destination","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["const object = objects[0];","const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");","const behavior = object.getBehavior(behaviorName);","","eventsFunctionContext.returnValue = behavior.__NavMeshPathfinding.pathfinding.pathFollower.destinationReached();",""],"parameterObjects":"Object","useStrict":true,"eventsSheetExpanded":false}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingBehavior","type":"behavior"}],"objectGroups":[]},{"description":"Get the number of waypoints on the path.","fullName":"Waypoint count","functionType":"Expression","group":"Movement on the path (navigation mesh)","name":"NodeCount","sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["const object = objects[0];","const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");","const behavior = object.getBehavior(behaviorName);","","eventsFunctionContext.returnValue = behavior.__NavMeshPathfinding.pathfinding.pathFollower.getNodeCount();",""],"parameterObjects":"Object","useStrict":true,"eventsSheetExpanded":false}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingBehavior","type":"behavior"}],"objectGroups":[]},{"description":"Return a waypoint X position.","fullName":"Waypoint X position","functionType":"Expression","group":"Movement on the path (navigation mesh)","name":"NodeX","sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["const object = objects[0];","const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");","const behavior = object.getBehavior(behaviorName);","","const nodeIndex = eventsFunctionContext.getArgument(\"NodeIndex\");","","eventsFunctionContext.returnValue = behavior.__NavMeshPathfinding.pathfinding.pathFollower.getNodeX(nodeIndex);",""],"parameterObjects":"Object","useStrict":true,"eventsSheetExpanded":false}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingBehavior","type":"behavior"},{"description":"Node index (start at 0)","name":"NodeIndex","type":"expression"}],"objectGroups":[]},{"description":"Return a waypoint Y position.","fullName":"Waypoint Y position","functionType":"Expression","group":"Movement on the path (navigation mesh)","name":"NodeY","sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["const object = objects[0];","const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");","const behavior = object.getBehavior(behaviorName);","","const nodeIndex = eventsFunctionContext.getArgument(\"NodeIndex\");","","eventsFunctionContext.returnValue = behavior.__NavMeshPathfinding.pathfinding.pathFollower.getNodeY(nodeIndex);",""],"parameterObjects":"Object","useStrict":true,"eventsSheetExpanded":false}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingBehavior","type":"behavior"},{"description":"Node index (start at 0)","name":"NodeIndex","type":"expression"}],"objectGroups":[]},{"description":"Return the index of the next waypoint to reach.","fullName":"Index of the next waypoint","functionType":"Expression","group":"Movement on the path (navigation mesh)","name":"NextNodeIndex","sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["const object = objects[0];","const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");","const behavior = object.getBehavior(behaviorName);","","eventsFunctionContext.returnValue = behavior.__NavMeshPathfinding.pathfinding.pathFollower.getNextNodeIndex();",""],"parameterObjects":"Object","useStrict":true,"eventsSheetExpanded":false}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingBehavior","type":"behavior"}],"objectGroups":[]},{"description":"Return the next waypoint X position.","fullName":"Next waypoint X position","functionType":"Expression","group":"Movement on the path (navigation mesh)","name":"NextNodeX","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["Object.Behavior::NodeX(Object.Behavior::NextNodeIndex())"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingBehavior","type":"behavior"}],"objectGroups":[]},{"description":"Return the next waypoint Y position.","fullName":"Next waypoint Y position","functionType":"Expression","group":"Movement on the path (navigation mesh)","name":"NextNodeY","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["Object.Behavior::NodeY(Object.Behavior::NextNodeIndex())"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingBehavior","type":"behavior"}],"objectGroups":[]},{"description":"Return the previous waypoint X position.","fullName":"Previous waypoint X position","functionType":"Expression","group":"Movement on the path (navigation mesh)","name":"PreviousNodeX","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["Object.Behavior::NodeX(Object.Behavior::NextNodeIndex() - 1)"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingBehavior","type":"behavior"}],"objectGroups":[]},{"description":"Return the previous waypoint Y position.","fullName":"Previous waypoint Y position","functionType":"Expression","group":"Movement on the path (navigation mesh)","name":"PreviousNodeY","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["Object.Behavior::NodeY(Object.Behavior::NextNodeIndex() - 1)"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingBehavior","type":"behavior"}],"objectGroups":[]},{"description":"Return the destination X position.","fullName":"Destination X position","functionType":"Expression","group":"Movement on the path (navigation mesh)","name":"DestinationX","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["Object.Behavior::NodeX(Object.Behavior::NodeCount() - 1)"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingBehavior","type":"behavior"}],"objectGroups":[]},{"description":"Return the destination Y position.","fullName":"Destination Y position","functionType":"Expression","group":"Movement on the path (navigation mesh)","name":"DestinationY","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["Object.Behavior::NodeY(Object.Behavior::NodeCount() - 1)"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingBehavior","type":"behavior"}],"objectGroups":[]},{"description":"Return the angle of movement of an object on its path.","fullName":"Angle of movement on its path","functionType":"Expression","group":"Movement on the path (navigation mesh)","name":"MovementAngle","sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["const object = objects[0];","const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");","const behavior = object.getBehavior(behaviorName);","","const angle = eventsFunctionContext.getArgument(\"Angle\");","const tolerance = eventsFunctionContext.getArgument(\"Tolerance\");","","eventsFunctionContext.returnValue = behavior.__NavMeshPathfinding.pathfinding.pathFollower.getMovementAngle(angle, tolerance);",""],"parameterObjects":"Object","useStrict":true,"eventsSheetExpanded":false}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingBehavior","type":"behavior"}],"objectGroups":[]},{"description":"Compare the angle of movement of an object on its path.","fullName":"Angle of movement on its path","functionType":"Condition","group":"Movement on the path (navigation mesh)","name":"MovementAngleIsAround","sentence":"Angle of movement of _PARAM0_ is _PARAM2_ (tolerance: _PARAM3_ degrees)","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"BuiltinCommonInstructions::CompareNumbers"},"parameters":["AngleDifference(Angle, Object.Behavior::MovementAngle())","<","Tolerance"]}],"actions":[{"type":{"value":"SetReturnBoolean"},"parameters":["True"]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingBehavior","type":"behavior"},{"description":"Angle (in degrees)","name":"Angle","type":"expression"},{"description":"Tolerance (in degrees)","name":"Tolerance","type":"expression"}],"objectGroups":[]},{"description":"the number of waypoints on the path.","fullName":"Speed on the path","functionType":"ExpressionAndCondition","group":"Movement on the path (navigation mesh)","name":"Speed","sentence":"the speed on the path","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["const object = objects[0];","const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");","const behavior = object.getBehavior(behaviorName);","","eventsFunctionContext.returnValue = behavior.__NavMeshPathfinding.pathfinding.pathFollower.getSpeed();",""],"parameterObjects":"Object","useStrict":true,"eventsSheetExpanded":false}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingBehavior","type":"behavior"}],"objectGroups":[]},{"description":"Draw the navigation mesh used for the object.\nThis action must be used after \"Move to a position\".","fullName":"Draw navigation mesh","functionType":"Action","group":"Debug","name":"DrawNavMesh","sentence":"Draw the navigation mesh used for _PARAM0_ on _PARAM2_","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["const object = objects[0];","const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");","const behavior = object.getBehavior(behaviorName);","","const shapePainters = eventsFunctionContext.getObjects(\"ShapePainter\");","","for (const shapePainter of shapePainters) {","    behavior.__NavMeshPathfinding.pathfinding.navMeshRenderer.render(runtimeScene, shapePainter);","}",""],"parameterObjects":"Object","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingBehavior","type":"behavior"},{"description":"Shape painter","name":"ShapePainter","supplementaryInformation":"PrimitiveDrawing::Drawer","type":"objectList"}],"objectGroups":[]},{"description":"the acceleration of the object.","fullName":"Acceleration","functionType":"ExpressionAndCondition","group":"Pathfinding configuration (navigation mesh)","name":"Acceleration","sentence":"the acceleration","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["Acceleration"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingBehavior","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"ActionWithOperator","getterName":"Acceleration","name":"SetAcceleration","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetNumberVariable"},"parameters":["Acceleration","=","Value"]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingBehavior","type":"behavior"}],"objectGroups":[]},{"description":"the maximum speed of the object.","fullName":"Maximum speed","functionType":"ExpressionAndCondition","group":"Pathfinding configuration (navigation mesh)","name":"MaxSpeed","sentence":"the maximum speed","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["MaxSpeed"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingBehavior","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"ActionWithOperator","getterName":"MaxSpeed","name":"SetMaxSpeed","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetNumberVariable"},"parameters":["MaxSpeed","=","Value"]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingBehavior","type":"behavior"}],"objectGroups":[]},{"description":"the rotation speed of the object.","fullName":"Rotation speed","functionType":"ExpressionAndCondition","group":"Pathfinding configuration (navigation mesh)","name":"AngularMaxSpeed","sentence":"the rotation speed","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["AngularMaxSpeed"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingBehavior","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"ActionWithOperator","getterName":"AngularMaxSpeed","name":"SetAngularMaxSpeed","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetNumberVariable"},"parameters":["AngularMaxSpeed","=","Value"]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingBehavior","type":"behavior"}],"objectGroups":[]},{"description":"the angle offset of the object.","fullName":"Angle offset","functionType":"ExpressionAndCondition","group":"Pathfinding configuration (navigation mesh)","name":"AngleOffset","sentence":"the angle offset","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["AngleOffset"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingBehavior","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"ActionWithOperator","getterName":"AngleOffset","name":"SetAngleOffset","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetNumberVariable"},"parameters":["AngleOffset","=","Value"]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingBehavior","type":"behavior"}],"objectGroups":[]},{"description":"the extra border size of the object.","fullName":"Extra border size","functionType":"ExpressionAndCondition","group":"Pathfinding configuration (navigation mesh)","name":"ExtraBorder","sentence":"the extra border size","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["ExtraBorder"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingBehavior","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"ActionWithOperator","getterName":"ExtraBorder","name":"SetExtraBorder","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetNumberVariable"},"parameters":["ExtraBorder","=","Value"]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingBehavior","type":"behavior"}],"objectGroups":[]},{"description":"the collision shape of the object.","fullName":"Collision shape","functionType":"ExpressionAndCondition","group":"Pathfinding configuration (navigation mesh)","name":"CollisionShape","sentence":"the collision shape","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnString"},"parameters":["CollisionShape"]}]}],"expressionType":{"supplementaryInformation":"[\"Bounding disk\",\"Dot at center\"]","type":"stringWithSelector"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingBehavior","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"ActionWithOperator","getterName":"CollisionShape","name":"SetCollisionShape","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetStringVariable"},"parameters":["CollisionShape","=","Value"]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingBehavior","type":"behavior"}],"objectGroups":[]},{"description":"Check if the object should rotate when following its path.","fullName":"Rotate object","functionType":"Condition","group":"Pathfinding configuration (navigation mesh)","name":"RotateObject","sentence":"_PARAM0_ rotate when following its path","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"BooleanVariable"},"parameters":["RotateObject","True",""]}],"actions":[{"type":{"value":"SetReturnBoolean"},"parameters":["True"]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingBehavior","type":"behavior"}],"objectGroups":[]},{"description":"Enable or disable the rotation of the object when following its path.","fullName":"Rotate object","functionType":"Action","getterName":"RotateObject","group":"Pathfinding configuration (navigation mesh)","name":"SetRotateObject","sentence":"Enable the rotation of _PARAM0_ on the path: _PARAM2_","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"BooleanVariable"},"parameters":["Value","True",""]}],"actions":[{"type":{"value":"SetBooleanVariable"},"parameters":["RotateObject","True",""]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"inverted":true,"value":"BooleanVariable"},"parameters":["Value","True",""]}],"actions":[{"type":{"value":"SetBooleanVariable"},"parameters":["RotateObject","False",""]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingBehavior","type":"behavior"},{"description":"Rotate object","name":"Value","type":"yesorno"}],"objectGroups":[]}],"propertyDescriptors":[{"value":"400","type":"Number","unit":"PixelAcceleration","label":"Acceleration","description":"","group":"","extraInformation":[],"name":"Acceleration"},{"value":"200","type":"Number","unit":"PixelSpeed","label":"Maximum speed","description":"","group":"","extraInformation":[],"name":"MaxSpeed"},{"value":"180","type":"Number","unit":"AngularSpeed","label":"Rotation speed","description":"","group":"Rotation","extraInformation":[],"name":"AngularMaxSpeed"},{"value":"","type":"Boolean","label":"Rotate object","description":"","group":"Rotation","extraInformation":[],"name":"RotateObject"},{"value":"0","type":"Number","unit":"DegreeAngle","label":"Angle offset","description":"","group":"Rotation","extraInformation":[],"name":"AngleOffset"},{"value":"Bounding disk","type":"Choice","label":"Collision shape","description":"","group":"Collision","extraInformation":["Bounding disk","Dot at center"],"name":"CollisionShape"},{"value":"0","type":"Number","unit":"Pixel","label":"Extra border size","description":"","group":"Collision","extraInformation":[],"name":"ExtraBorder"}],"sharedPropertyDescriptors":[]},{"description":"Flag objects as being an obstacle for pathfinding.","fullName":"Obstacle for navigation mesh pathfinding (experimental)","name":"NavMeshPathfindingObstacleBehavior","objectType":"","eventsFunctions":[{"fullName":"","functionType":"Action","name":"onCreated","sentence":"","events":[{"type":"BuiltinCommonInstructions::Comment","color":{"b":109,"g":230,"r":255,"textB":0,"textG":0,"textR":0},"comment":"Initiate and attach properties as objects variables"},{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"NavMeshPathfinding::DefineJavaScript"},"parameters":["",""]}]},{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["const object = objects[0];\r","const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");\r","const behavior = object.getBehavior(behaviorName);\r","behavior.__NavMeshPathfinding = behavior.__NavMeshPathfinding || {};\r","behavior.__NavMeshPathfinding.obstacle =\r","    new gdjs.__NavMeshPathfinding.NavMeshPathfindingObstacleBehavior(\r","        runtimeScene, behavior);\r",""],"parameterObjects":"Object","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingObstacleBehavior","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"Action","name":"doStepPreEvents","sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["const object = objects[0];\r","const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");\r","const behavior = object.getBehavior(behaviorName);\r","\r","behavior.__NavMeshPathfinding.obstacle.doStepPreEvents(runtimeScene);"],"parameterObjects":"Object","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingObstacleBehavior","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"Action","name":"onDeActivate","sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["const object = objects[0];\r","const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");\r","const behavior = object.getBehavior(behaviorName);\r","\r","behavior.__NavMeshPathfinding.obstacle.onDeActivate();"],"parameterObjects":"Object","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingObstacleBehavior","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"Action","name":"onActivate","sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["const object = objects[0];\r","const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");\r","const behavior = object.getBehavior(behaviorName);\r","\r","behavior.__NavMeshPathfinding.obstacle.onActivate();"],"parameterObjects":"Object","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingObstacleBehavior","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"Action","name":"onDestroy","sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["const object = objects[0];\r","const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");\r","const behavior = object.getBehavior(behaviorName);\r","\r","behavior.__NavMeshPathfinding.obstacle.onDestroy();"],"parameterObjects":"Object","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingObstacleBehavior","type":"behavior"}],"objectGroups":[]},{"description":"the cell size for obstacle collision mask rasterization. While an object is needed, this will apply to all objects using the behavior.","fullName":"Cell size","functionType":"ExpressionAndCondition","group":"Navigation mesh configuration","name":"CellSize","sentence":"the cell size","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["Object.Behavior::SharedPropertyCellSize()"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingObstacleBehavior","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"ActionWithOperator","getterName":"CellSize","name":"SetCellSize","private":true,"sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"NavMeshPathfinding::NavMeshPathfindingObstacleBehavior::SetSharedPropertyCellSize"},"parameters":["Object","Behavior","=","Value"]},{"type":{"value":"NavMeshPathfinding::NavMeshPathfindingObstacleBehavior::InvalidateNavMesh"},"parameters":["Object","Behavior",""]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingObstacleBehavior","type":"behavior"}],"objectGroups":[]},{"description":"the area left bound. The left bound of the area where objects can go in the scene. While an object is needed, this will apply to all objects using the behavior.","fullName":"Area left bound","functionType":"ExpressionAndCondition","group":"Navigation mesh configuration","name":"AreaLeftBound","sentence":"the area left bound","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["Object.Behavior::SharedPropertyAreaLeftBound()"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingObstacleBehavior","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"ActionWithOperator","getterName":"AreaLeftBound","name":"SetAreaLeftBound","private":true,"sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"NavMeshPathfinding::NavMeshPathfindingObstacleBehavior::SetSharedPropertyAreaLeftBound"},"parameters":["Object","Behavior","=","Value"]},{"type":{"value":"NavMeshPathfinding::NavMeshPathfindingObstacleBehavior::InvalidateNavMesh"},"parameters":["Object","Behavior",""]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingObstacleBehavior","type":"behavior"}],"objectGroups":[]},{"description":"the area top bound. The top bound of the area where objects can go in the scene. While an object is needed, this will apply to all objects using the behavior.","fullName":"Area top bound","functionType":"ExpressionAndCondition","group":"Navigation mesh configuration","name":"AreaTopBound","sentence":"the area top bound","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["Object.Behavior::SharedPropertyAreaTopBound()"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingObstacleBehavior","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"ActionWithOperator","getterName":"AreaTopBound","name":"SetAreaTopBound","private":true,"sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"NavMeshPathfinding::NavMeshPathfindingObstacleBehavior::SetSharedPropertyAreaTopBound"},"parameters":["Object","Behavior","=","Value"]},{"type":{"value":"NavMeshPathfinding::NavMeshPathfindingObstacleBehavior::InvalidateNavMesh"},"parameters":["Object","Behavior",""]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingObstacleBehavior","type":"behavior"}],"objectGroups":[]},{"description":"the area right bound. The right bound of the area where objects can go in the scene (default to the game resolution). While an object is needed, this will apply to all objects using the behavior.","fullName":"Area right bound","functionType":"ExpressionAndCondition","group":"Navigation mesh configuration","name":"AreaRightBound","sentence":"the area right bound","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["Object.Behavior::SharedPropertyAreaRightBound()"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingObstacleBehavior","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"ActionWithOperator","getterName":"AreaRightBound","name":"SetAreaRightBound","private":true,"sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"NavMeshPathfinding::NavMeshPathfindingObstacleBehavior::SetSharedPropertyAreaRightBound"},"parameters":["Object","Behavior","=","Value"]},{"type":{"value":"NavMeshPathfinding::NavMeshPathfindingObstacleBehavior::InvalidateNavMesh"},"parameters":["Object","Behavior",""]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingObstacleBehavior","type":"behavior"}],"objectGroups":[]},{"description":"the area bottom bound. The bottom bound of the area where objects can go in the scene (default to the game resolution). While an object is needed, this will apply to all objects using the behavior.","fullName":"Area bottom bound","functionType":"ExpressionAndCondition","group":"Navigation mesh configuration","name":"AreaBottomBound","sentence":"the area bottom bound","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["Object.Behavior::SharedPropertyAreaBottomBound()"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingObstacleBehavior","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"ActionWithOperator","getterName":"AreaBottomBound","name":"SetAreaBottomBound","private":true,"sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"NavMeshPathfinding::NavMeshPathfindingObstacleBehavior::SetSharedPropertyAreaBottomBound"},"parameters":["Object","Behavior","=","Value"]},{"type":{"value":"NavMeshPathfinding::NavMeshPathfindingObstacleBehavior::InvalidateNavMesh"},"parameters":["Object","Behavior",""]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingObstacleBehavior","type":"behavior"}],"objectGroups":[]},{"description":"Invalidate navigation mesh.","fullName":"Invalidate navigation mesh","functionType":"Action","name":"InvalidateNavMesh","private":true,"sentence":"Invalidate navigation mesh","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["const object = objects[0];","const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");","const behavior = object.getBehavior(behaviorName);","","eventsFunctionContext.returnValue = behavior.__NavMeshPathfinding.obstacle._manager.invalidateNavMesh();",""],"parameterObjects":"Object","useStrict":true,"eventsSheetExpanded":false}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingObstacleBehavior","type":"behavior"}],"objectGroups":[]}],"propertyDescriptors":[],"sharedPropertyDescriptors":[{"value":"Top-Down","type":"Choice","label":"Viewpoint","description":"","group":"","extraInformation":["Top-Down","Isometry 2:1 (26.565°)","True Isometry (30°)"],"name":"Viewpoint"},{"value":"10","type":"Number","unit":"Pixel","label":"Cell size","description":"Cell size for obstacle collision mask rasterization.","group":"","extraInformation":[],"name":"CellSize"},{"value":"0","type":"Number","unit":"Pixel","label":"Area left bound","description":"The left bound of the area where objects can go in the scene.","group":"","extraInformation":[],"name":"AreaLeftBound"},{"value":"0","type":"Number","unit":"Pixel","label":"Area top bound","description":"The top bound of the area where objects can go in the scene.","group":"","extraInformation":[],"name":"AreaTopBound"},{"value":"0","type":"Number","unit":"Pixel","label":"Area right bound","description":"The right bound of the area where objects can go in the scene (default to the game resolution).","group":"","extraInformation":[],"name":"AreaRightBound"},{"value":"0","type":"Number","unit":"Pixel","label":"Area bottom bound","description":"The bottom bound of the area where objects can go in the scene (default to the game resolution).","group":"","extraInformation":[],"name":"AreaBottomBound"},{"value":"","type":"Number","label":"","description":"","group":"","extraInformation":[],"hidden":true,"name":"IsometricRatio"}]},{"description":"Change the animation according to the movement direction.","fullName":"Navigation mesh pathfinding animator","name":"NavMeshPathfindingAnimator","objectType":"","eventsFunctions":[{"fullName":"","functionType":"Action","name":"onActivate","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"NavMeshPathfinding::NavMeshPathfindingAnimator::SetAnimationDirection"},"parameters":["Object","Behavior","Object.Behavior::Direction()",""]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingAnimator","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"Action","name":"doStepPostEvents","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"NavMeshPathfinding::NavMeshPathfindingBehavior::Speed"},"parameters":["Object","NavMeshPathfinding","=","0",""]}],"actions":[{"type":{"value":"AnimatableCapability::AnimatableBehavior::PauseAnimation"},"parameters":["Object","Animation"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"NavMeshPathfinding::NavMeshPathfindingBehavior::Speed"},"parameters":["Object","NavMeshPathfinding",">","0",""]}],"actions":[{"type":{"value":"AnimatableCapability::AnimatableBehavior::PlayAnimation"},"parameters":["Object","Animation"]}],"events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"BooleanVariable"},"parameters":["IsScalingAnimation","True",""]}],"actions":[{"type":{"value":"NavMeshPathfinding::NavMeshPathfindingAnimator::SetAnimationSpeedScale"},"parameters":["Object","Behavior",""]}]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetNumberVariable"},"parameters":["NewAnimationDirection","=","Object.Behavior::Direction()"]}],"events":[{"type":"BuiltinCommonInstructions::Comment","color":{"b":109,"g":230,"r":255,"textB":0,"textG":0,"textR":0},"comment":"Use a small margin is used to avoid to flicker between 2 directions."},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"BuiltinCommonInstructions::CompareNumbers"},"parameters":["abs(Object.Behavior::DirectionDifference(NewAnimationDirection, AnimationDirection))",">","0.5 + 0.03125"]}],"actions":[{"type":{"value":"NavMeshPathfinding::NavMeshPathfindingAnimator::SetAnimationDirection"},"parameters":["Object","Behavior","NewAnimationDirection",""]}]}],"variables":[{"folded":true,"name":"NewAnimationDirection","type":"number","value":0.0}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingAnimator","type":"behavior"}],"objectGroups":[]},{"description":"the animation name of the object.","fullName":"Animation name","functionType":"ExpressionAndCondition","name":"AnimationName","sentence":"the animation name","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnString"},"parameters":["AnimationName"]}]}],"expressionType":{"type":"string"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingAnimator","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"ActionWithOperator","getterName":"AnimationName","name":"SetAnimationName","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"StringVariable"},"parameters":["AnimationName","!=","Value"]}],"actions":[{"type":{"value":"SetStringVariable"},"parameters":["AnimationName","=","Value"]},{"type":{"value":"AnimatableCapability::AnimatableBehavior::SetName"},"parameters":["Object","Animation","=","AnimationName + ToString(AnimationDirection)"]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingAnimator","type":"behavior"}],"objectGroups":[]},{"description":"Check if the animation is scaled according to speed.","fullName":"Scale animation according to speed","functionType":"Condition","name":"IsScalingAnimation","sentence":"_PARAM0_ animation is scaled according to speed","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"BooleanVariable"},"parameters":["IsScalingAnimation","True",""]}],"actions":[{"type":{"value":"SetReturnBoolean"},"parameters":["True"]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingAnimator","type":"behavior"}],"objectGroups":[]},{"description":"Change whether the animation is scaled according to speed or not.","fullName":"Scale animation according to speed","functionType":"Action","name":"SetIsScalingAnimation","sentence":"Scale the animation of _PARAM0_ according to speed: _PARAM2_","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"inverted":true,"value":"BooleanVariable"},"parameters":["Value","True",""]}],"actions":[{"type":{"value":"SetBooleanVariable"},"parameters":["IsScalingAnimation","False",""]},{"type":{"value":"AnimatableCapability::AnimatableBehavior::SetSpeedScale"},"parameters":["Object","Animation","=","1"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"BooleanVariable"},"parameters":["Value","True",""]}],"actions":[{"type":{"value":"SetBooleanVariable"},"parameters":["IsScalingAnimation","True",""]},{"type":{"value":"NavMeshPathfinding::NavMeshPathfindingAnimator::SetAnimationSpeedScale"},"parameters":["Object","Behavior",""]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingAnimator","type":"behavior"},{"defaultValue":"yes","description":"IsScalingAnimation","name":"Value","optional":true,"type":"yesorno"}],"objectGroups":[]},{"description":"Change the animation speed scale according to the object speed.","fullName":"Animation speed scale","functionType":"Action","name":"SetAnimationSpeedScale","private":true,"sentence":"Change the animation speed scale according to _PARAM0_ speed","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"AnimatableCapability::AnimatableBehavior::SetSpeedScale"},"parameters":["Object","Animation","=","Object.NavMeshPathfinding::Speed() / Object.NavMeshPathfinding::MaxSpeed()"]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingAnimator","type":"behavior"}],"objectGroups":[]},{"description":"Return the object movement direction.","fullName":"Direction","functionType":"Expression","name":"Direction","private":true,"sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["(Object.NavMeshPathfinding::MovementAngle() + AngleOffset) * DirectionCount / 360"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingAnimator","type":"behavior"}],"objectGroups":[]},{"description":"Return the difference between 2 directions.","fullName":"Direction dirrerence","functionType":"Expression","name":"DirectionDifference","private":true,"sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["mod(mod(Direction - OtherDirection, DirectionCount) + DirectionCount / 2, DirectionCount) - DirectionCount / 2"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingAnimator","type":"behavior"},{"description":"Direction","name":"Direction","type":"expression"},{"description":"Other direction","name":"OtherDirection","type":"expression"}],"objectGroups":[]},{"description":"Change the animation direction of the object.","fullName":"Animation direction","functionType":"Action","name":"SetAnimationDirection","private":true,"sentence":"Change the animation direction of _PARAM0_ to _PARAM2_","events":[{"type":"BuiltinCommonInstructions::Comment","color":{"b":109,"g":230,"r":255,"textB":0,"textG":0,"textR":0},"comment":"Change the animation but keep the current frame number."},{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetNumberVariable"},"parameters":["AnimationDirection","=","mod(mod(round(Value), DirectionCount) + DirectionCount, DirectionCount)"]},{"type":{"value":"SetNumberVariable"},"parameters":["AnimationElapsedTime","=","Object.Animation::ElapsedTime()"]},{"type":{"value":"AnimatableCapability::AnimatableBehavior::SetName"},"parameters":["Object","Animation","=","AnimationName + ToString(AnimationDirection)"]},{"type":{"value":"AnimatableCapability::AnimatableBehavior::SetElapsedTime"},"parameters":["Object","Animation","=","AnimationElapsedTime"]}],"variables":[{"folded":true,"name":"AnimationElapsedTime","type":"number","value":0.0}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingAnimator","type":"behavior"},{"description":"Value","name":"Value","type":"expression"}],"objectGroups":[]}],"propertyDescriptors":[{"value":"","type":"Behavior","label":"Animatable capability","description":"","group":"","extraInformation":["AnimatableCapability::AnimatableBehavior"],"name":"Animation"},{"value":"","type":"Behavior","label":"Navigation mesh pathfinding","description":"","group":"","extraInformation":["NavMeshPathfinding::NavMeshPathfindingBehavior"],"name":"NavMeshPathfinding"},{"value":"true","type":"Boolean","label":"Scale animation according to speed","description":"","group":"Animation","extraInformation":[],"name":"IsScalingAnimation"},{"value":"Walk","type":"String","label":"Animation name","description":"Animations must be called \"Walk0\", \"Walk1\"... for left, down...","group":"Animation","extraInformation":[],"name":"AnimationName"},{"value":"8","type":"Number","unit":"Dimensionless","label":"Number of directions","description":"","group":"Direction","extraInformation":[],"name":"DirectionCount"},{"value":"0","type":"Number","unit":"DegreeAngle","label":"Angle offset","description":"Set to 90°, \"Walk0\" becomes the animation for down.","group":"Direction","extraInformation":[],"name":"AngleOffset"},{"value":"0","type":"Number","label":"","description":"","group":"","extraInformation":[],"hidden":true,"name":"AnimationDirection"}],"sharedPropertyDescriptors":[]}],"eventsBasedObjects":[]}],"externalLayouts":[{"associatedLayout":"MainScene","name":"UI","instances":[{"angle":0.0,"customSize":true,"depth":1.0,"height":202.0,"keepRatio":true,"layer":"UI","name":"TestPrint","persistentUuid":"e7cb25a4-6e12-47ca-bd41-caac2e2aa12e","width":373.0,"x":1490.0,"y":834.0,"zOrder":1,"numberProperties":[],"stringProperties":[],"initialVariables":[]}],"editionSettings":{"grid":false,"gridType":"rectangular","gridWidth":32.0,"gridHeight":32.0,"gridOffsetX":0.0,"gridOffsetY":0.0,"gridColor":10401023.0,"gridAlpha":0.8,"snap":false,"zoomFactor":0.2890516203134915,"windowMask":false}}]}